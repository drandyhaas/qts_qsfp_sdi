22 serialization::archive 19 0 0 0 0 7 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 0 0 6 0 0 0 12 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 3 dni 9 sandboxes 6 8872_0 3 sld 16 default_jtag.sdc 4220 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# This SDC is used to constrain a design containing logic driven by JTAG that is missing a clocking
# constraint on altera_reserved_tck. This SDC will add a default constraint if none is present, and 
# there are is at least one clock defined in the design.  We don't want to constrain altera_reserved_tck
# when there are no defined clocks since altera_reserved_tck will then become the highest priority clock.
# This will affect the place and route result of logic driven by other clocks in the design.

namespace eval intel_reserved_jtag_default_constraints {

    proc set_default_quartus_fit_timing_directive { } {
        # A10 & S10 support max 33.3Mhz clock
        set jtag_33Mhz_t_period 30
        
        create_clock -name {altera_reserved_tck} -period $jtag_33Mhz_t_period [get_ports {altera_reserved_tck}] 
        set_clock_groups -asynchronous -group {altera_reserved_tck} 
        # Force fitter to place register driving TDO pin to be as close to 
        # the JTAG controller as possible to maximize the slack outside of FPGA.
        if {$::TimeQuestInfo(family) == "Arria 10"} {
            set_max_delay -to [get_ports { altera_reserved_tdo } ] 0
        }
        
        # Declare false-paths for S10 JTAG Atom ( see HSD-ES:1408819417 )
        if {$::TimeQuestInfo(family) == "Stratix 10"} {
            set_false_path -from "*|atom_inst|atom~soc_sdm/padsig_io1.reg"
            set_false_path -from "*|atom_inst|atom~soc_sdm/padsig_io1.reg__nff"
        }
        
        # Set pessimistic input delays to properly establish timing relationship between tck and tms, tdi
        set input_delay_period 0.5
        set_input_delay -max -clock_fall -clock [get_clocks altera_reserved_tck] $input_delay_period [get_ports altera_reserved_tms]
        set_input_delay -min -clock_fall -clock [get_clocks altera_reserved_tck] [expr {0 - $input_delay_period}] [get_ports altera_reserved_tms]    
        set_input_delay -max -clock_fall -clock [get_clocks altera_reserved_tck] $input_delay_period [get_ports altera_reserved_tdi]
        set_input_delay -min -clock_fall -clock [get_clocks altera_reserved_tck] [expr {0 - $input_delay_period}] [get_ports altera_reserved_tdi]
    }

    proc add_contraints_if_appropriate { } {
        # Only constrain if the design contains user-declared clocks
        set number_of_user_clocks [get_collection_size [all_clocks]]

        if {$number_of_user_clocks > 0} {
            # Only constrain if altera_reserved_tck has not already been constrained
            set tck_ports [get_ports -nowarn altera_reserved_tck]
            if {[get_collection_size $tck_ports] > 0} {
                if {[get_collection_size [get_clocks -nowarn -of_objects $tck_ports]] == 0} {
                    post_message -type info "Adding default timing constraints to JTAG signals.  This will help to achieve basic functionality since no such constraints were provided by the user."
                    set_default_quartus_fit_timing_directive
                }
            }
        }
    }
}

# Only make these constraints for the fitter as they are hints, not suitable for timing sign-off
if { [string equal quartus_fit $::TimeQuestInfo(nameofexecutable)] } {
    # Define a different set of timing spec to influence place-and-route 
    # result in the jtag clock domain. The slacks outside of FPGA are 
    # maximized.
    intel_reserved_jtag_default_constraints::add_contraints_if_appropriate
}
 15 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 3 dni 3 sld 5 ipgen 13 alt_sld_fab_0 13 alt_sld_fab_0 36 altera_internal_oscillator_atom_1911 5 synth 35 altera_internal_oscillator_atom.sdc 984 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# The clock output is 250MHz
if {[get_collection_size [get_clocks altera_int_osc_clk -nowarn]] == 0} {
	create_clock -name altera_int_osc_clk -period 4.000 [get_nodes {*|intosc|oscillator_dut~oscillator_clock}]
} 15 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 3 dni 3 sld 5 ipgen 13 alt_sld_fab_0 13 alt_sld_fab_0 28 altera_jtag_dc_streaming_191 5 synth 35 altera_avalon_st_jtag_interface.sdc 911 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


set_false_path -from [get_registers *altera_jtag_src_crosser:*|sink_data_buffer*] -to [get_registers *altera_jtag_src_crosser:*|src_data*]
 15 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 3 dni 3 sld 5 ipgen 13 alt_sld_fab_0 13 alt_sld_fab_0 28 altera_reset_controller_1922 5 synth 27 altera_reset_controller.sdc 2326 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0

if {[get_current_instance] == ""} {set hpath ""} else {set hpath "[get_current_instance]|*"} 
post_message -type info "Following instance found in the design -  $hpath"

set aclr_collection [get_pins -compatibility_mode -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set num_sync_stage [get_registers -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[*]]
set num_sync_count [get_collection_size $num_sync_stage]   
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter == 0 &&  $clrn_counter == 0 && $num_sync_count > 0} {
    set_max_delay  -to [get_registers ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[[expr $num_sync_count-1]]] 100
    set_min_delay  -to [get_registers ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[[expr $num_sync_count-1]]] -100
}

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 15 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 3 dni 3 sld 5 ipgen 13 alt_sld_fab_0 13 alt_sld_fab_0 27 altera_signaltap_agent_1920 5 synth 20 intel_signal_tap.sdc 6003 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# $Revision: #1 
# $Date: 2017/07/31 
# $Author: zkumar 

#-------------------------------------------------------------------------------
# TimeQuest constraints to constrain the timing across asynchronous clock domain crossings.
# The idea is to minimize skew to between stp_status_bits_in_reg_acq (acq domain) and stp_status_bits_out_reg_tck (tck domain)
# 
# CDC takes place between these paths (in intel_stp_status_bits_cdc component)
#

# -----------------------------------------------------------------------------
# This procedure constrains the max_delay (not skew) between the status bit regs.
#
# The hierarchy path to the status_bits CDC instance is required as an 
# argument.
# -----------------------------------------------------------------------------
proc constrain_signaltap_status_bits_max_delay { path } {

    #set the to/from paths for stp_status_bits
    set path_from $path|stp_status_bits_in_reg_acq\[*\]
    set path_to $path|stp_status_bits_out_reg_tck\[*\]

    #check if the paths to be constrained exist or not
    set paths_from [get_registers -nowarn $path_from]
    set paths_to [get_registers -nowarn $path_to]
    set num_status_paths_from [get_collection_size $paths_from]
    set num_status_paths_to [get_collection_size $paths_to]
    ##post_message -type info "DEBUG: paths detected for *stp_status_bits_in_reg_acq* = $num_status_paths_from"
    ##post_message -type info "DEBUG: paths detected for *stp_status_bits_out_reg_tck* = $num_status_paths_to"

    #if either "to" or "from" paths donot exist, exit the .sdc gracefully
    if {$num_status_paths_to > 0} {
        
       set tck_clk [get_fanins $path_to -clock -stop_at_clocks]
       set num_tck_clk [get_collection_size $tck_clk]
    } else {
        set num_tck_clk 0
    }


    if {$num_status_paths_from == 0 || $num_status_paths_to == 0 || $num_tck_clk == 0 } {
    
        post_message -type info "Status exchange path between acquisition clock and communication clock in the Signal Tap instance, [get_current_instance] is synthesized out.  No constraint is added on this path."
        
    } else {
    
        post_message -type info "Constraints on the CDC paths between acquisition clock and communication clock are created in the Signal Tap instance, [get_current_instance]"
        #call to function to get the tck domain name and period
        ## post_message -type warning "DEBUG: my path = $path|stp_status_bits_out_reg_tck*"
        set max_delay_prd [expr [get_tck_info $path_to $tck_clk]]
        ## post_message -type warning "DEBUG: max delay is 1xtck_clk_prd = $max_delay_prd"

        #set the max delay as function of dst clk period (i.e. tck clk prd) so that -
        #1) to make the delay settings more relaxed (more than 1ns), between i/p and o/p status bits 
        #2) to ensure the max delay can be used when acq clk > tck clk and vice-versa
        #max delay is 1xtck clk period (because valid bit takes ~3 cycles to go from acq to tck domain)

        set_max_delay -from $paths_from  -to $paths_to  $max_delay_prd
    
    }  

}

# -----------------------------------------------------------------------------
# This procedure is to find out the tck clk name and period
#
# The hierarchy path to the status_bits CDC instance is required as an 
# argument.
# -----------------------------------------------------------------------------
proc get_tck_info { filter tck_clk_col} {
    ## post_message -type warning "DEBUG: Search for $filter"
    ## post_message -type warning "DEBUG: my_tck_clk = $tck_clk_col"

    # A10 & S10 support max 33.3Mhz clock (default, in case tck clk prd is not defined)
    set default_tck_prd 30
    
    foreach_in_collection clk $tck_clk_col {
        set tck_clk_node_name [get_node_info -name $clk]
        ## post_message -type warning "DEBUG: tck domain clk name: $tck_clk_node_name"
        set clks [get_clocks -nowarn -of_objects [get_registers $filter]]
        ## post_message -type warning "DEBUG: $clks [llength $clks] get_clocks -of_objects \[get_registers $filter\]"

        ##check if tck clk period has been previously declared or not
        if {[get_collection_size $clks] == 0} {
                ## post_message -type warning "DEBUG: tck clk period is not defined, setting max delay to 30ns (default 33MHz tck)"
                post_message -type info "The clock period of '$tck_clk_node_name' used in the Signal Tap instance, [get_current_instance] is not defined, setting max delay to 30ns (default 33MHz tck)"
                set tck_clk_prd $default_tck_prd
                ## post_message -type warning "DEBUG: tck domain period (default): $tck_clk_prd"
        } else {
            # In the case of multiple clock definitions, arbitrarily use the first clock in the list
            foreach_in_collection clk $clks {
                set tck_clk_prd [get_clock_info $clk -period]
                ## post_message -type warning "DEBUG: tck domain period: $tck_clk_prd"  
                break
	    }
        }        

       
    }

    return $tck_clk_prd

}



constrain_signaltap_status_bits_max_delay "[get_current_instance]|sld_signaltap_inst|sld_signaltap_body|sld_signaltap_body|jtag_acq_clk_xing|intel_stp_status_bits_cdc_u1"
 15 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 3 dni 3 sld 5 ipgen 13 alt_sld_fab_0 13 alt_sld_fab_0 15 st_dc_fifo_1950 5 synth 41 alt_sld_fab_0_st_dc_fifo_1950_w4zc75y.sdc 5852 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#-------------------------------------------------------------------------------
# TimeQuest constraints to constrain the timing across asynchronous clock domain crossings.
# The idea is to minimize skew to less than one launch clock period to keep the gray encoding, 
# and to minimize latency on the pointer crossings.
#
# The paths are from the Gray Code read and write pointers to their respective synchronizer banks.
#
# *** Important note *** 
#
# Do not declare the FIFO clocks as asynchronous at the top level, or false path these crossings,
# because that will override these constraints.
#-------------------------------------------------------------------------------
set all_dc_fifo [get_entity_instances alt_sld_fab_0_st_dc_fifo_1950_w4zc75y]

set_max_delay -from [get_registers {*|in_wr_ptr_gray[*]}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:write_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] 200
set_min_delay -from [get_registers {*|in_wr_ptr_gray[*]}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:write_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] -200

set_max_delay -from [get_registers {*|out_rd_ptr_gray[*]}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:read_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] 200
set_min_delay -from [get_registers {*|out_rd_ptr_gray[*]}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:read_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] -200

set_net_delay -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8 -from [get_pins -compatibility_mode {*|in_wr_ptr_gray[*]*}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:write_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] 
set_net_delay -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8 -from [get_pins -compatibility_mode {*|out_rd_ptr_gray[*]*}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:read_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}]


foreach dc_fifo_inst $all_dc_fifo {
   if { [ llength [query_collection -report -all [get_registers -nowarn $dc_fifo_inst|in_wr_ptr_gray[*]]]] > 0  } {
      set_max_skew -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8  -from [get_registers $dc_fifo_inst|in_wr_ptr_gray[*]] -to [get_registers $dc_fifo_inst|write_crosser|sync[*].u|din_s1] 
   }

   if { [ llength [query_collection -report -all [get_registers -nowarn $dc_fifo_inst|out_rd_ptr_gray[*]]]] > 0 } {
      set_max_skew -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8  -from [get_registers $dc_fifo_inst|out_rd_ptr_gray[*]] -to [get_registers $dc_fifo_inst|read_crosser|sync[*].u|din_s1] 
   }
}

set aclr_collection_wr [get_pins -compatibility_mode -nocase -nowarn *|write_reset_sync|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection_wr [get_pins -compatibility_mode -nocase -nowarn *|write_reset_sync|altera_reset_synchronizer_int_chain*|clrn]
set aclr_counter_wr [get_collection_size $aclr_collection_wr]
set clrn_counter_wr [get_collection_size $clrn_collection_wr]



if {$aclr_counter_wr > 0} {
set_false_path -to [get_pins -compatibility_mode -nocase *|write_reset_sync|altera_reset_synchronizer_int_chain*|aclr]
}



if {$clrn_counter_wr > 0} {
set_false_path -to [get_pins -compatibility_mode -nocase *|write_reset_sync|altera_reset_synchronizer_int_chain*|clrn]
}




set aclr_collection_rd [get_pins -compatibility_mode -nocase -nowarn *|read_reset_sync|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection_rd [get_pins -compatibility_mode -nocase -nowarn *|read_reset_sync|altera_reset_synchronizer_int_chain*|clrn]
set aclr_counter_rd [get_collection_size $aclr_collection_rd]
set clrn_counter_rd [get_collection_size $clrn_collection_rd]



if {$aclr_counter_rd > 0} {
set_false_path -to [get_pins -compatibility_mode -nocase *|read_reset_sync|altera_reset_synchronizer_int_chain*|aclr]
}



if {$clrn_counter_rd > 0} {
set_false_path -to [get_pins -compatibility_mode -nocase *|read_reset_sync|altera_reset_synchronizer_int_chain*|clrn]
}

# add in timing constraints across asynchronous clock domain crossings for simple dual clock memory inference

# -----------------------------------------------------------------------------
# This procedure constrains the skew between the pointer bits, and should
# be called from the top level SDC, once per instance of the FIFO.
#
# The hierarchy path to the FIFO instance is required as an 
# argument.
# -----------------------------------------------------------------------------
proc constrain_altera_avalon_dc_fifo_ptr_skew { path } {

    set_max_skew -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8 -from [ get_registers $path|in_wr_ptr_gray\[*\] ] -to [ get_registers $path|write_crosser|sync\[*\].u|din_s1 ]
    set_max_skew -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8 -from [ get_registers $path|out_rd_ptr_gray\[*\] ] -to [ get_registers $path|read_crosser|sync\[*\].u|din_s1 ]

}

 1
