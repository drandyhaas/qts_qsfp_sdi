22 serialization::archive 19 0 0 0 0 7 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 0 0 22 0 0 0 13 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 2 ip 5 q_sys 14 q_sys_master_0 28 altera_jtag_dc_streaming_191 5 synth 35 altera_avalon_st_jtag_interface.sdc 911 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


set_false_path -from [get_registers *altera_jtag_src_crosser:*|sink_data_buffer*] -to [get_registers *altera_jtag_src_crosser:*|src_data*]
 13 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 2 ip 5 q_sys 14 q_sys_master_0 28 altera_reset_controller_1922 5 synth 27 altera_reset_controller.sdc 2326 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0

if {[get_current_instance] == ""} {set hpath ""} else {set hpath "[get_current_instance]|*"} 
post_message -type info "Following instance found in the design -  $hpath"

set aclr_collection [get_pins -compatibility_mode -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set num_sync_stage [get_registers -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[*]]
set num_sync_count [get_collection_size $num_sync_stage]   
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter == 0 &&  $clrn_counter == 0 && $num_sync_count > 0} {
    set_max_delay  -to [get_registers ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[[expr $num_sync_count-1]]] 100
    set_min_delay  -to [get_registers ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[[expr $num_sync_count-1]]] -100
}

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 13 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 2 ip 14 qsfp_xcvr_test 38 qsfp_xcvr_test_xcvr_native_s10_htile_1 33 altera_xcvr_native_s10_htile_1930 5 synth 46 alt_xcvr_native_global_constraints_ugm7okq.sdc 9069 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# ---------------------------------------------------------------- #
# -                                                              - #
# --- THIS IS AN AUTO-GENERATED FILE!                          --- #
# --- Do not change the contents of this file.                 --- # 
# --- Your changes will be lost once the IP is regenerated!    --- #
# ---                                                          --- #
# --- This file contains the global timing constraints for     --- #
# --- Native PHY IP                                            --- #
# ---    * Clock creation and other constraints are contained  --- #
# ---      ${ip_name}_alt_xcvr_native_ugm7okq.sdc              --- #
# -                                                              - # 
# ---------------------------------------------------------------- #

set script_dir [file dirname [info script]] 
set split_qsys_output_name [split qsfp_xcvr_test_xcvr_native_s10_htile_1_altera_xcvr_native_s10_htile_1930_ugm7okq "_"]
set xcvr_nphy_index [lsearch $split_qsys_output_name "altera"]
if {$xcvr_nphy_index < 0} {
  set list_top_inst_name $split_qsys_output_name
} else {
  set list_top_inst_name [lreplace $split_qsys_output_name $xcvr_nphy_index end]
}
set top_inst_name [join $list_top_inst_name "_"]
source "${script_dir}/${top_inst_name}_ip_parameters_ugm7okq.tcl"

# Find the current Native PHY instance name in the design
set instance_name [get_current_instance]


#-------------------------------------------------- #
#---                                            --- #
#--- SET_FALSE_PATH for TX BONDING              --- #
#---                                            --- #
#-------------------------------------------------- #

set pld_tx_clk_dcm_pin_col [get_pins -compat -nowarn $instance_name|g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_tx_clk*_dcm]

# Remove all paths for TX bonding signals
if {[dict get $native_phy_ip_params bonded_mode_profile0] == "pma_pcs" && [get_collection_size $pld_tx_clk_dcm_pin_col] > 0 } {

  # Cutting fake paths between continguously placed, but separately bonded Native PHY IP instances
  set pld_clk_dcm_reg_col    [get_registers -nowarn *|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_tx_clk*_dcm.reg]

  if {[get_collection_size $pld_clk_dcm_reg_col] > 0} {
    set_false_path -through $pld_tx_clk_dcm_pin_col -to $pld_clk_dcm_reg_col
  }
}

#-------------------------------------------------- #
#---                                            --- #
#--- Internal loopback path                     --- #
#---                                            --- #
#-------------------------------------------------- #

set duplex_mode     [dict get $native_phy_ip_params duplex_mode_profile0]

# Cut internal loopback paths from TX instance when simplex is enabled and merging TX and RX simplex into same channel
if { $duplex_mode == "tx" } {
  set tx_fabric_data_out_col            [get_pins -compat -nowarn $instance_name|g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|aib_fabric_tx_data_out*]
  set tx_aibnd_idata_col                [get_pins -compat -nowarn $instance_name|g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_aibnd_tx.inst_ct1_hssi_aibnd_tx|idat*]
  set rx_transfer_clk_reg_col           [get_registers -nowarn    *g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx~aib_fabric_rx_transfer_clk.reg]
  set aib_tx_internal_div_reg_col       [get_registers -nowarn    $instance_name|g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~aib_tx_internal_div.reg]
  set aib_fabric_pma_aib_tx_clk_col     [get_registers -nowarn    $instance_name|g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~aib_fabric_pma_aib_tx_clk.reg]
  set aib_fabric_pma_aib_tx_clk_pin_col [get_pins -compat -nowarn $instance_name|g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|aib_fabric_pma_aib_tx_clk]

  if {[get_collection_size $pld_tx_clk_dcm_pin_col] > 0  &&  [get_collection_size $rx_transfer_clk_reg_col] > 0} {
    set_false_path -through $pld_tx_clk_dcm_pin_col -to $rx_transfer_clk_reg_col
    if {[get_collection_size $tx_fabric_data_out_col] > 0 && [get_collection_size $tx_aibnd_idata_col] > 0} {
      set_false_path -from $pld_tx_clk_dcm_pin_col -through $tx_fabric_data_out_col -through $tx_aibnd_idata_col -to $rx_transfer_clk_reg_col
    }
  }

  if {[get_collection_size $aib_fabric_pma_aib_tx_clk_pin_col] > 0 && [get_collection_size $tx_fabric_data_out_col] > 0 && [get_collection_size $tx_aibnd_idata_col] > 0 && [get_collection_size $rx_transfer_clk_reg_col] > 0} {
    set_false_path -from $aib_fabric_pma_aib_tx_clk_pin_col -through $tx_fabric_data_out_col -through $tx_aibnd_idata_col -to $rx_transfer_clk_reg_col
  }

  if {[get_collection_size $aib_fabric_pma_aib_tx_clk_col] > 0 && [get_collection_size $tx_fabric_data_out_col] > 0 && [get_collection_size $tx_aibnd_idata_col] > 0 && [get_collection_size $rx_transfer_clk_reg_col] > 0} {
    set_false_path -from $aib_fabric_pma_aib_tx_clk_col -through $tx_fabric_data_out_col -through $tx_aibnd_idata_col -to $rx_transfer_clk_reg_col
  }

  if {[get_collection_size $aib_tx_internal_div_reg_col] > 0 && [get_collection_size $aib_fabric_pma_aib_tx_clk_pin_col] > 0 && [get_collection_size $rx_transfer_clk_reg_col] > 0} {
    set_false_path -from $aib_tx_internal_div_reg_col -through $aib_fabric_pma_aib_tx_clk_pin_col -to $rx_transfer_clk_reg_col
  }
}

  # -------------------------------------------------------------------------------------------------- #
  # --- set false path for physical adjacent channel transfer clock connections to other phy IPs   --- #
  # -------------------------------------------------------------------------------------------------- #
  set aib_tx_internal_div_reg_col [get_registers -nowarn $instance_name|g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~aib_tx_internal_div.reg]
  set my_aib_fabric_transfer_clk_col [get_registers -nowarn $instance_name|g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~*aib_fabric_tx_transfer_clk.reg]
  set oth_aib_fabric_transfer_clk_col [get_registers -nowarn *|g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~*aib_fabric_tx_transfer_clk.reg]
  if { [get_collection_size $my_aib_fabric_transfer_clk_col] > 0 } {
    set oth_aib_fabric_transfer_clk_col [remove_from_collection $oth_aib_fabric_transfer_clk_col $my_aib_fabric_transfer_clk_col]
  }
  if { [get_collection_size $aib_tx_internal_div_reg_col] > 0 && [get_collection_size $oth_aib_fabric_transfer_clk_col] > 0 } {
    set_false_path -from $aib_tx_internal_div_reg_col -to $oth_aib_fabric_transfer_clk_col 
  }
 
#-------------------------------------------------- #
#---                                            --- #
#--- DISABLE MIN_PULSE_WIDTH CHECK on fPLL      --- #
#---                                            --- #
#-------------------------------------------------- #

# Disable min_width_pulse for fPLL counter nodes
set all_ports_list [get_ports *]
foreach_in_collection port $all_ports_list {

  set fpll_counter_nodes_list [get_nodes -nowarn [get_node_info -name $port]~inputFITTER_INSERTED_FITTER_INSERTED~fpll_c?_div]

  if {[get_collection_size $fpll_counter_nodes_list] > 0} {
    foreach_in_collection fpll_counter_node $fpll_counter_nodes_list {
      disable_min_pulse_width [get_node_info -name $fpll_counter_node]
    }
  }
}


 13 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 2 ip 14 qsfp_xcvr_test 38 qsfp_xcvr_test_xcvr_native_s10_htile_1 33 altera_xcvr_native_s10_htile_1930 5 synth 44 alt_xcvr_native_helper_functions_ugm7okq.tcl 58185 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# -------------------------------------------------------------------------- #
# - 
# --- This file contains helper functions for Native PHY SDC file
# -
# -------------------------------------------------------------------------- #
set script_dir [file dirname [info script]]

load_package sdc_ext
load_package design

if {![info exists native_debug]} {
  global ::native_debug
}

set native_debug 0

# Create dictionary to map clocks to their respective target node
if {[info exists alt_xcvr_native_s10_target_clock_list_dict]} {
   unset alt_xcvr_native_s10_target_clock_list_dict
}
global ::alt_xcvr_native_s10_target_clock_list_dict
set alt_xcvr_native_s10_target_clock_list_dict [dict create]

# -------------------------------------------------------------------------- #
# ---                                                                    --- #
# --- Procedure to initialize the database of all required pins and      --- #
# --- registers to create clocks                                         --- #
# ---                                                                    --- #
# -------------------------------------------------------------------------- #
proc native_initialize_db_ugm7okq { native_db } {

  # upvar links one variable to another variable at specified level of execution
  upvar $native_db local_native_db

  # Set the GLOBAL_corename in ip_parameters.tcl 
  global ::GLOBAL_corename
  global ::native_debug

  # Delete the database if it exists
  if [info exists local_native_db] {
    msg_vdebug "IP SDC: Database existed before, deleting it now"
    unset local_native_db
  } 

  set local_native_db [dict create]

  msg_vdebug "IP SDC: Initializing S10 Native PHY database for CORE $::GLOBAL_corename"

  # Find the current Native PHY instance name in the design
  set instance_name [get_current_instance]

  # Create dictionary of pins
  msg_vdebug "IP SDC: Finding port-to-pin mapping for CORE: $::GLOBAL_corename INSTANCE: $instance_name"
  set all_pins [dict create]
  native_get_pins_ugm7okq $all_pins
  
  # Set the associative array
  dict set local_native_db $instance_name $all_pins

}


# -------------------------------------------------------------------------- #
# ---                                                                    --- #
# --- Procedure to find all the pins and registers for nodes of interest --- #
# ---                                                                    --- #
# -------------------------------------------------------------------------- #
proc native_get_pins_ugm7okq { all_pins } {

  global ::native_debug

  # We need to make a local copy of the allpins associative array
  upvar all_pins native_pins

  # ------------------------------------------------------------------------- #
  # Define the pins here 
  # Include regex to grab pins for multiple channels

  # Dummy refclk source node
  set aib_tx_clk_source_node g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~aib_tx_clk_source
  set aib_rx_clk_source_node g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx~aib_rx_clk_source

  # Dummy flipflop to add large Tco to ensure timing failure in transfers between channels
  set aib_tx_internal_div_reg_node g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~aib_tx_internal_div.reg
  set aib_rx_internal_div_reg_node g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx~aib_rx_internal_div.reg

  # Output clocks from main adapter to core
  set tx_clkout_pin  g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_pcs_tx_clk_out1_dcm
  set tx_clkout2_pin g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_pcs_tx_clk_out2_dcm
  set rx_clkout_pin  g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|pld_pcs_rx_clk_out1_dcm
  set rx_clkout2_pin g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|pld_pcs_rx_clk_out2_dcm

  # Input clocks to main adapter from aib
  set aib_fabric_rx_transfer_clk_pin g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|aib_fabric_rx_transfer_clk

  # hclk
  set hclk_pin                       g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|pld_pma_hclk_hioint
  set aib_hclk_internal_div_reg_node g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx~aib_hclk_internal_div.reg

  # ------------------------------------------------------------------------- #
  # Create a dictionary for each clock pin 
  set native_pins [dict create]

  # ------------------------------------------------------------------------- #
  set aib_tx_clk_source_id [get_nodes -nowarn $aib_tx_clk_source_node]

  if {[get_collection_size $aib_tx_clk_source_id] > 0} {
    foreach_in_collection clk $aib_tx_clk_source_id {
      dict lappend native_pins tx_pma_parallel_clk [get_node_info -name $clk] 
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: After getting AIB TX CLK SOURCE node info: [dict get $native_pins tx_pma_parallel_clk]"
    }

    dict set native_pins tx_pma_parallel_clk [join [lsort -dictionary [dict get $native_pins tx_pma_parallel_clk]]]

  } else {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: Could not find pins for AIB TX CLK SOURCE"
    }
  }

  # ------------------------------------------------------------------------- #
  set aib_rx_clk_source_id [get_nodes -nowarn $aib_rx_clk_source_node]

  if {[get_collection_size $aib_rx_clk_source_id] > 0} {
    foreach_in_collection clk $aib_rx_clk_source_id {
      dict lappend native_pins rx_pma_parallel_clk [get_node_info -name $clk] 
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: After getting AIB TX CLK SOURCE node info: [dict get $native_pins rx_pma_parallel_clk]"
    }

    dict set native_pins rx_pma_parallel_clk [join [lsort -dictionary [dict get $native_pins rx_pma_parallel_clk]]]

  } else {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: Could not find nodes for AIB RX CLK SOURCE"
    }
  }

  # ------------------------------------------------------------------------- #
  set aib_tx_internal_div_reg_id [get_registers -nowarn $aib_tx_internal_div_reg_node]

  if {[get_collection_size $aib_tx_internal_div_reg_id] > 0} {
    foreach_in_collection clk $aib_tx_internal_div_reg_id {
      dict lappend native_pins tx_pcs_x2_clk [get_node_info -name $clk] 
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: After getting AIB TX INTERNAL DIV REG node info: [dict get $native_pins tx_pcs_x2_clk]"
    }

    dict set native_pins tx_pcs_x2_clk [join [lsort -dictionary [dict get $native_pins tx_pcs_x2_clk]]]

  } else {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: Could not find registers for AIB TX INTERNAL DIV REG"
    }
  }

  # ------------------------------------------------------------------------- #
  set aib_rx_internal_div_reg_id [get_registers -nowarn $aib_rx_internal_div_reg_node]

  if {[get_collection_size $aib_rx_internal_div_reg_id] > 0} {
    foreach_in_collection clk $aib_rx_internal_div_reg_id {
      dict lappend native_pins rx_pcs_x2_clk [get_node_info -name $clk] 
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: After getting AIB RX INTERNAL DIV REG node info: [dict get $native_pins rx_pcs_x2_clk]"
    }

    dict set native_pins rx_pcs_x2_clk [join [lsort -dictionary [dict get $native_pins rx_pcs_x2_clk]]]

  } else {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: Could not find registers for AIB RX INTERNAL DIV REG"
    }
  }

  # ------------------------------------------------------------------------- #
  set tx_clkout_id [get_pins -compatibility_mode -nowarn $tx_clkout_pin]

  if {[get_collection_size $tx_clkout_id] == 0} {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: pld_pcs_tx_clk_out1_dcm does not exist."
    }
  }

  if {[get_collection_size $tx_clkout_id] > 0} {
    foreach_in_collection clk $tx_clkout_id {
      dict lappend native_pins tx_clkout [get_pin_info -name $clk] 
      # Pipe clocks
      dict lappend native_pins tx_clkout_pipe_g1 [get_pin_info -name $clk]
      dict lappend native_pins tx_clkout_pipe_g2 [get_pin_info -name $clk]
      dict lappend native_pins tx_clkout_pipe_g3 [get_pin_info -name $clk] 
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: After getting TX CLKOUT node info: [dict get $native_pins tx_clkout]"
    }

    dict set native_pins tx_clkout [join [lsort -dictionary [dict get $native_pins tx_clkout]]]
    dict set native_pins tx_clkout_pipe_g1 [join [lsort -dictionary [dict get $native_pins tx_clkout_pipe_g1]]]
    dict set native_pins tx_clkout_pipe_g2 [join [lsort -dictionary [dict get $native_pins tx_clkout_pipe_g2]]]
    dict set native_pins tx_clkout_pipe_g3 [join [lsort -dictionary [dict get $native_pins tx_clkout_pipe_g3]]]

  } else {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: Could not find pins for TX CLKOUT"
    }
  }

  # ------------------------------------------------------------------------- #
  set tx_clkout2_id [get_pins -compatibility_mode -nowarn $tx_clkout2_pin]

  if {[get_collection_size $tx_clkout2_id] == 0} {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: pld_pcs_tx_clk_out2_dcm does not exist."
    }
  }

  if {[get_collection_size $tx_clkout2_id] > 0} {
    foreach_in_collection clk $tx_clkout2_id {
      dict lappend native_pins tx_clkout2 [get_pin_info -name $clk] 
      # Pipe clocks
      dict lappend native_pins tx_clkout2_pipe_g1 [get_pin_info -name $clk]
      dict lappend native_pins tx_clkout2_pipe_g2 [get_pin_info -name $clk]
      dict lappend native_pins tx_clkout2_pipe_g3 [get_pin_info -name $clk]
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: After getting TX CLKOUT2 node info: [dict get $native_pins tx_clkout2]"
    }

    dict set native_pins tx_clkout2 [join [lsort -dictionary [dict get $native_pins tx_clkout2]]]
    dict set native_pins tx_clkout2_pipe_g1 [join [lsort -dictionary [dict get $native_pins tx_clkout2_pipe_g1]]]
    dict set native_pins tx_clkout2_pipe_g2 [join [lsort -dictionary [dict get $native_pins tx_clkout2_pipe_g2]]]
    dict set native_pins tx_clkout2_pipe_g3 [join [lsort -dictionary [dict get $native_pins tx_clkout2_pipe_g3]]]

  } else {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: Could not find pins for TX CLKOUT2"
    }
  }

  # ------------------------------------------------------------------------- #
  set rx_clkout_id [get_pins -compatibility_mode -nowarn $rx_clkout_pin]

  if {[get_collection_size $rx_clkout_id] == 0} {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: pld_pcs_rx_clk_out1_dcm does not exist."
    }
  }

  if {[get_collection_size $rx_clkout_id] > 0} {
    foreach_in_collection clk $rx_clkout_id {
      dict lappend native_pins rx_clkout [get_pin_info -name $clk]
      # Pipe clocks
      dict lappend native_pins rx_clkout_pipe_g1 [get_pin_info -name $clk]
      dict lappend native_pins rx_clkout_pipe_g2 [get_pin_info -name $clk]
      dict lappend native_pins rx_clkout_pipe_g3 [get_pin_info -name $clk]
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: After getting RX CLKOUT node info: [dict get $native_pins rx_clkout]"
    }

    dict set native_pins rx_clkout [join [lsort -dictionary [dict get $native_pins rx_clkout]]]
    dict set native_pins rx_clkout_pipe_g1 [join [lsort -dictionary [dict get $native_pins rx_clkout_pipe_g1]]]
    dict set native_pins rx_clkout_pipe_g2 [join [lsort -dictionary [dict get $native_pins rx_clkout_pipe_g2]]]
    dict set native_pins rx_clkout_pipe_g3 [join [lsort -dictionary [dict get $native_pins rx_clkout_pipe_g3]]]

  } else {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: Could not find pins for RX CLKOUT"
    }
  }

  # ------------------------------------------------------------------------- #
  set rx_clkout2_id [get_pins -compatibility_mode -nowarn $rx_clkout2_pin]

  if {[get_collection_size $rx_clkout2_id] == 0} {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: pld_pcs_rx_clk_out2_dcm does not exist."
    }
  }

  if {[get_collection_size $rx_clkout2_id] > 0} {
    foreach_in_collection clk $rx_clkout2_id {
      dict lappend native_pins rx_clkout2 [get_pin_info -name $clk]
      # Pipe clocks
      dict lappend native_pins rx_clkout2_pipe_g1 [get_pin_info -name $clk]
      dict lappend native_pins rx_clkout2_pipe_g2 [get_pin_info -name $clk]
      dict lappend native_pins rx_clkout2_pipe_g3 [get_pin_info -name $clk]
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: After getting RX CLKOUT2 node info: [dict get $native_pins rx_clkout2]"
    }

    dict set native_pins rx_clkout2 [join [lsort -dictionary [dict get $native_pins rx_clkout2]]]
    dict set native_pins rx_clkout2_pipe_g1 [join [lsort -dictionary [dict get $native_pins rx_clkout2_pipe_g1]]]
    dict set native_pins rx_clkout2_pipe_g2 [join [lsort -dictionary [dict get $native_pins rx_clkout2_pipe_g2]]]
    dict set native_pins rx_clkout2_pipe_g3 [join [lsort -dictionary [dict get $native_pins rx_clkout2_pipe_g3]]]

  } else {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: Could not find pins for RX CLKOUT2"
    }
  }

  # ------------------------------------------------------------------------- #
  set rx_transfer_clk_id [get_pins -compatibility_mode -nowarn $aib_fabric_rx_transfer_clk_pin]

  if {[get_collection_size $rx_transfer_clk_id] > 0} {
    foreach_in_collection clk $rx_transfer_clk_id {
      dict lappend native_pins rx_transfer_clk [get_pin_info -name $clk]
      dict lappend native_pins rx_transfer_clk2 [get_pin_info -name $clk] 
      dict lappend native_pins rx_transfer_clk_pipe_g1  [get_pin_info -name $clk]
      dict lappend native_pins rx_transfer_clk2_pipe_g1 [get_pin_info -name $clk] 
      dict lappend native_pins rx_transfer_clk_pipe_g2  [get_pin_info -name $clk]
      dict lappend native_pins rx_transfer_clk2_pipe_g2 [get_pin_info -name $clk] 
      dict lappend native_pins rx_transfer_clk_pipe_g3  [get_pin_info -name $clk]
      dict lappend native_pins rx_transfer_clk2_pipe_g3 [get_pin_info -name $clk] 
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: After getting RX TRANSFER CLK node info: [dict get $native_pins rx_transfer_clk]"
    }

    dict set native_pins rx_transfer_clk [join [lsort -dictionary [dict get $native_pins rx_transfer_clk]]]
    dict set native_pins rx_transfer_clk2 [join [lsort -dictionary [dict get $native_pins rx_transfer_clk2]]]
    dict set native_pins rx_transfer_clk_pipe_g1  [join [lsort -dictionary [dict get $native_pins rx_transfer_clk_pipe_g1]]]
    dict set native_pins rx_transfer_clk2_pipe_g1 [join [lsort -dictionary [dict get $native_pins rx_transfer_clk2_pipe_g1]]]
    dict set native_pins rx_transfer_clk_pipe_g2  [join [lsort -dictionary [dict get $native_pins rx_transfer_clk_pipe_g2]]]
    dict set native_pins rx_transfer_clk2_pipe_g2 [join [lsort -dictionary [dict get $native_pins rx_transfer_clk2_pipe_g2]]]
    dict set native_pins rx_transfer_clk_pipe_g3  [join [lsort -dictionary [dict get $native_pins rx_transfer_clk_pipe_g3]]]
    dict set native_pins rx_transfer_clk2_pipe_g3 [join [lsort -dictionary [dict get $native_pins rx_transfer_clk2_pipe_g3]]]

  } else {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: Could not find pins for RX TRANSFER CLK"
    }
  }

  # ------------------------------------------------------------------------- #
  set hclk_pin_id [get_pins -compatibility_mode -nowarn $hclk_pin]

  if {[get_collection_size $hclk_pin_id] > 0} {
    foreach_in_collection clk $hclk_pin_id {
      dict lappend native_pins hclk [get_pin_info -name $clk] 
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: After getting HCLK node info: [dict get $native_pins hclk]"
    }

    dict set native_pins hclk [join [lsort -dictionary [dict get $native_pins hclk]]]

  } else {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: Could not find pins for HCLK"
    }
  }

  # ------------------------------------------------------------------------- #
  set aib_hclk_internal_div_reg_id [get_registers -nowarn $aib_hclk_internal_div_reg_node]

  if {[get_collection_size $aib_hclk_internal_div_reg_id] > 0} {
    foreach_in_collection clk $aib_hclk_internal_div_reg_id {
      dict lappend native_pins hclk_internal_div_reg [get_node_info -name $clk] 
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: After getting AIB HCLK INTERNAL DIV REG node info: [dict get $native_pins hclk_internal_div_reg]"
    }

    dict set native_pins hclk_internal_div_reg [join [lsort -dictionary [dict get $native_pins hclk_internal_div_reg]]]

  } else {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: Could not find registers for AIB HCLK INTERNAL DIV REG"
    }
  }

}

# -------------------------------------------------------------------------------- #
# ---                                                                          --- #
# --- Procedure to call procedure to create clocks all channels in an instance --- #
# ---                                                                          --- #
# -------------------------------------------------------------------------------- #
proc native_prepare_to_create_clocks_all_ch_ugm7okq { instance num_channels mode mode_clks profile_cnt profile alt_xcvr_native_s10_pins clk_freq_dict multiply_factor_dict divide_factor_dict all_profile_clocks_names } {
  global ::native_debug

  set list_of_clk_names [list]

  foreach clk_group $mode_clks { # Each mode can have multiple clocks; iterate over them
    if { $native_debug } {
      post_message -type info "IP SDC: Clock group in $mode_clks is: $clk_group"
    }

    if { [dict exists $alt_xcvr_native_s10_pins $instance $clk_group] } {

      set clk_pins [dict get $alt_xcvr_native_s10_pins $instance $clk_group]

      if { $native_debug } {
        post_message -type info "IP SDC: Pins for $clk_group: $clk_pins"
      }

      if { [llength $clk_pins] > 0 } { # Check to see if the corresponding pins exists 

        #Remap any backward slashes '' in the pins
        set clk_pins [string map {\\ \\\\} $clk_pins] 

        if { $mode == "tx_source_clks" || $mode == "rx_source_clks"} {
          set clk_freq [dict get $clk_freq_dict $clk_group]

          # Create clks for all channels for a clk group in mode clk
          lappend list_of_clk_names [native_create_clocks_all_ch_ugm7okq $instance $clk_group $num_channels $clk_freq $clk_pins $profile_cnt $profile]

        } else {
          set clk_freq ""
          set multiply_factor [dict get $multiply_factor_dict $clk_group]
          set divide_factor   [dict get $divide_factor_dict   $clk_group]

          if { $clk_group == "tx_pcs_x2_clk" } {
            set source_nodes  [dict get $alt_xcvr_native_s10_pins $instance tx_pma_parallel_clk]
            set master_clocks [dict get $all_profile_clocks_names $profile  tx_source_clks]

          } elseif { $clk_group == "rx_pcs_x2_clk" } {
            set source_nodes  [dict get $alt_xcvr_native_s10_pins $instance rx_pma_parallel_clk]
            set master_clocks [dict get $all_profile_clocks_names $profile  rx_source_clks]

          } elseif { $clk_group == "hclk_internal_div_reg" } {
            set source_nodes  [dict get $alt_xcvr_native_s10_pins $instance rx_pma_parallel_clk]
            set master_clocks [dict get $all_profile_clocks_names $profile  rx_source_clks]

          } elseif { $mode == "tx_mode_clks" } {
            set source_nodes  [dict get $alt_xcvr_native_s10_pins $instance tx_pcs_x2_clk]
            set master_clocks [dict get $all_profile_clocks_names $profile  tx_internal_div_reg_clks]

          } elseif { $mode == "rx_mode_clks" } {
            
            # For rx_clkout2, check if RX is in register mode and rx_transfer_clk was created
            set full_instance_split [ split $instance | ]  
            set full_instance_split [lreplace $full_instance_split end end]
            set short_inst_name [join $full_instance_split "|"]
            set rx_transfer_clk_col [get_clocks -nowarn ${short_inst_name}*rx_transfer_clk|ch*]

            if {[get_collection_size $rx_transfer_clk_col] > 0} {
              set rx_transfer_clk_name_list [list]
              foreach_in_collection clk $rx_transfer_clk_col {
                lappend rx_transfer_clk_name_list [get_clock_info -name $clk]
              }
              set rx_transfer_clk_name_list [join [lsort -dictionary $rx_transfer_clk_name_list]]

              set source_nodes  [dict get $alt_xcvr_native_s10_pins $instance rx_transfer_clk]
              set master_clocks $rx_transfer_clk_name_list
            } else {
              set source_nodes  [dict get $alt_xcvr_native_s10_pins $instance rx_pcs_x2_clk]
              set master_clocks [dict get $all_profile_clocks_names $profile  rx_internal_div_reg_clks]
            }

          } elseif { $mode == "hclk_mode" } {
            set source_nodes  [dict get $alt_xcvr_native_s10_pins $instance hclk_internal_div_reg]
            set master_clocks [dict get $all_profile_clocks_names $profile  hclk_internal_div_reg_clks]

          } else {
            post_message -type warning "IP SDC Warning: Cannot find source node for $clk_group key in group $mode"
          }

          #Remap any backward slashes '' in the source clock nodes
          set source_nodes [string map {\\ \\\\} $source_nodes] 

          # Create clks for all channels for a clk group in mode clk
          lappend list_of_clk_names [native_create_clocks_all_ch_ugm7okq $instance $clk_group $num_channels $clk_freq $clk_pins $profile_cnt $profile $source_nodes $master_clocks $multiply_factor $divide_factor]
        }
      }

     } else {
       if {$native_debug == 1} {
         post_message -type warning "IP SDC Warning: $clk_group key does not exist in pins dictionary"
       }
     }
  } ; # foreach clk_group in mode_clks

  return $list_of_clk_names

}

# ----------------------------------------------------------------------------- #
# ---                                                                       --- #
# --- Procedure to create HSSI clocks for all channels in an instance       --- #
# ---                                                                       --- #
# ----------------------------------------------------------------------------- #
proc native_create_clocks_all_ch_ugm7okq { instance clk_group num_channels freq clk_list profile_cnt profile args } {
  global ::native_debug

  set clock_name_list [list]

  # Remove the 'xcvr_native_s10_0' from each full instance name
  set full_instance_split [ split $instance | ]  
  set full_instance_split [lreplace $full_instance_split end end]
  set short_inst_name [join $full_instance_split "|"]

  # Replace any '[' and ']' characters with with '?' since Tcl string matching doesn't work with explicit '[' and ']' characters
  set regex_instance [regsub -all {\[} $instance {?}]
  set regex_instance [regsub -all {\]} $regex_instance {?}]

  # Iterate through all channels
  for { set channel 0 } { $channel < $num_channels } { incr channel } {

    # Match channel node with nodes in the clock group
    set channel_node_regexp $regex_instance|g_xcvr_native_insts?$channel?.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_?x.inst_ct1_hssi_pldadapt_?x*
    set channel_node_regexp [string map {\\ \\\\} $channel_node_regexp]
    set matching_clk_nodes  [lsearch -inline $clk_list $channel_node_regexp]
    set matching_clk_nodes  [string map {\\ \\\\} $matching_clk_nodes]

    if { $native_debug == 1 } {
      post_message -type info "IP SDC: Matching Channel $channel nodes: $matching_clk_nodes"
    }

    # Iterate through all nodes in the clock group
    foreach clk_node $matching_clk_nodes {

      # Remove the instance name from the clock node due to auto promotion in SDC_ENTITY
      set no_inst_clk_node [string replace $clk_node 0 [string length $instance]]
  
      # Shorten the clock name if multiple profiles are not used
      if { $profile_cnt > 1 } { 
        set clock_name ${short_inst_name}|profile$profile|$clk_group|ch$channel
      } else {
        set clock_name ${short_inst_name}|$clk_group|ch$channel
      }
      # Add the clock name to the list 
      lappend clock_name_list $clock_name
      
      # Check if clock with same name already exists, if so skip clock creation
      set matching_clocks_list [get_clocks -nowarn $clock_name]

      if { [get_collection_size $matching_clocks_list] > 0 } {
        foreach_in_collection matching_clk $matching_clocks_list {

          # Check if clock is declared AND defined (i.e. create_clock or create_generated_clock was used)
          if { [is_clock_defined $clock_name] == 1 } {
            if { $native_debug == 1 } {
              post_message -type warning "Clock already exists with name $clock_name with period [get_clock_info $matching_clk -period]ns on node [get_object_info -name [get_clock_info $matching_clk -targets]]"
            }

          # Clock was declared, but not defined, so we need to create the clock still (i.e. "declare_clock" command was used)
          } else {

            if { $args != "" } {
              set source_nodes  [lindex $args 0]
              set master_clocks [lindex $args 1]
  
              set clk_source_node  [lindex $source_nodes  $channel]
              set clk_master_clock [lindex $master_clocks $channel]

              # Remove the instance name from the clock source node due to auto promotion in SDC_ENTITY
              set no_inst_clk_source_node [string replace $clk_source_node 0 [string length $instance]]

              set multiply_factor [lindex $args 2] 
              set divide_factor   [lindex $args end]

              # Call procedure to create generated clock for given clock node 
              native_create_clock_ugm7okq $clk_group $clock_name $freq $no_inst_clk_node $channel $no_inst_clk_source_node $clk_master_clock $multiply_factor $divide_factor

            } else {

              # Call procedure to create source clock for given clock node 
              native_create_clock_ugm7okq $clk_group $clock_name $freq $no_inst_clk_node $channel
            }
          }
        }; #foreach_in_collection matching_clk matching_clocks_list

      # Create clock if no clock exists already with same name
      } else { 


        if { $args != "" } {
          set source_nodes  [lindex $args 0]
          set master_clocks [lindex $args 1]
  
          set clk_source_node  [lindex $source_nodes  $channel]
          set clk_master_clock [lindex $master_clocks $channel]

          # Remove the instance name from the clock source node due to auto promotion in SDC_ENTITY
          set no_inst_clk_source_node [string replace $clk_source_node 0 [string length $instance]]

          set multiply_factor [lindex $args 2] 
          set divide_factor   [lindex $args end]

          # Call procedure to create generated clock for given clock node 
          native_create_clock_ugm7okq $clk_group $clock_name $freq $no_inst_clk_node $channel $no_inst_clk_source_node $clk_master_clock $multiply_factor $divide_factor

        } else {

          # Call procedure to create source clock for given clock node 
          native_create_clock_ugm7okq $clk_group $clock_name $freq $no_inst_clk_node $channel
        }
      }

    }; # foreach clk in clk_list
  }; # foreach channel

  # Return the list of clock names  
  return $clock_name_list

}

# ----------------------------------------------------------------------------- #
# ---                                                                       --- #
# --- Procedure to create single HSSI clock for given node and clock name   --- #
# ---                                                                       --- #
# ----------------------------------------------------------------------------- #
proc native_create_clock_ugm7okq { clk_group clock_name freq clk_node channel args } {
  global ::native_debug
  global ::alt_xcvr_native_s10_target_clock_list_dict

  if { $native_debug == 1 } {
    post_message -type info "IP SDC: Clock name = $clock_name"
  }
  
  # Use "create_clock" for source nodes
  if { $clk_group == "tx_pma_parallel_clk" || $clk_group == "rx_pma_parallel_clk" } {
  
    create_clock \
        -name    $clock_name \
        -period "$freq MHz" \
                 $clk_node -add
  
    # Add clock to target node key in the target clock list dictionary
    dict lappend alt_xcvr_native_s10_target_clock_list_dict $clk_node $clock_name

    if { $native_debug == 1 } {
      post_message -type info "IP SDC: Clocks on target node $clk_node"
      post_message -type info "                => [dict get $alt_xcvr_native_s10_target_clock_list_dict $clk_node]"
    }

  # Use "create_generated_clock" for the downstream nodes (*~aib_tx/rx_internal_div.reg and MAIB output pins)
  } elseif { $args != "" } {
  
    set clk_source_node  [lindex $args 0]
    set clk_master_clock [lindex $args 1]
    set multiply_factor  [lindex $args 2] 
    set divide_factor    [lindex $args end]
  
    if { $native_debug == 1 } {
            post_message -type info "IP SDC: Source node is $clk_source_node"
            post_message -type info "        Master clock is $clk_master_clock"
    }
  
    create_generated_clock \
        -name         $clock_name \
        -source       $clk_source_node \
        -master_clock $clk_master_clock \
        -multiply_by  $multiply_factor \
        -divide_by    $divide_factor \
                      $clk_node -add

    # Add clock to target node key in the target clock list dictionary
    dict lappend alt_xcvr_native_s10_target_clock_list_dict $clk_node $clock_name

    if { $native_debug == 1 } {
      post_message -type info "IP SDC: Clocks on target node $clk_node"
      post_message -type info "                => [dict get $alt_xcvr_native_s10_target_clock_list_dict $clk_node]"
    }

  }

}


# ----------------------------------------------------------------------------- #
# ---                                                                       --- #
# --- Procedure to adjust min pulse requirement for coreclkin2 to be        --- #
# --- frequency-dependency                                                  --- #
# ---                                                                       --- #
# ----------------------------------------------------------------------------- #
proc native_check_special_min_pulse_ugm7okq { clock_name } {
  global ::native_debug
  set pass 1  

  # Find old active clocks, and then set all clocks active
  set old_active_clocks [get_active_clocks]
  set_active_clocks [all_clocks]
  
  set clock_spec_collection [get_clocks $clock_name]
  foreach_in_collection clock_spec $clock_spec_collection { }

  # Get clock period
  set period [get_clock_info -period $clock_spec]
  set frequency [expr 1 / $period * 1000]
  
  # Determine min pulse adjustment
  set frequency_list [list 0.0         501.0              600.0                 700.0                 800.0                 900.0                1000.0]
  set min_pulse_list [list 0.0 [expr 400.0-400.0] [expr 400.0 - 366.7]  [expr 400.0 - 342.9] [expr 400.0 - 325.0]  [expr 400.0 - 311.1] [expr 400.0 - 300.0] ]
  
  # Determine min pulse spec adjustment
  set i 0
  set min_pulse_adjustment 0.0 
  foreach xfreq $frequency_list {
     if { $frequency <= $xfreq } {
        set min_pulse_adjustment [lindex $min_pulse_list [expr $i - 1]]
        break
     }
     incr i
  }
  
  # Get min pulse information
  set min_pulse_info [get_min_pulse_width $clock_name]
  set min_pulse_slack [lindex [lindex $min_pulse_info 0] 0]

  # If after the adjusment we are still negative, then output the min pulse report, and indicate the failure
  if {[expr $min_pulse_slack + $min_pulse_adjustment] < 0 } {
     report_min_pulse_width -nworst 100 -detail full_path -panel_name "Minimum Pulse Width: $clock_name" [get_clocks $clock_name]
     post_message -type critical_warning "Min Pulse Requirements on Tile Transfer not met; see DDR report for more details"
     set pass 0
  }

  # Also make sure, nothing else is connected on this clock domain
  set setup_from_paths_col    [get_timing_paths -from $clock_spec -setup]
  set setup_to_paths_col      [get_timing_paths -to   $clock_spec -setup]
  set hold_from_paths_col     [get_timing_paths -from $clock_spec -hold]
  set hold_to_paths_col       [get_timing_paths -to   $clock_spec -hold]
  set recovery_from_paths_col [get_timing_paths -from $clock_spec -recovery]
  set recovery_to_paths_col   [get_timing_paths -to   $clock_spec -recovery]
  set removal_from_paths_col  [get_timing_paths -from $clock_spec -removal]
  set removal_to_paths_col    [get_timing_paths -to   $clock_spec -removal]

  set num_setup_from_paths    [get_collection_size $setup_from_paths_col]
  set num_setup_to_paths      [get_collection_size $setup_to_paths_col]
  set num_hold_from_paths     [get_collection_size $hold_from_paths_col]
  set num_hold_to_paths       [get_collection_size $hold_to_paths_col]
  set num_recovery_from_paths [get_collection_size $recovery_from_paths_col]
  set num_recovery_to_paths   [get_collection_size $recovery_to_paths_col]
  set num_removal_from_paths  [get_collection_size $removal_from_paths_col]
  set num_removal_to_paths    [get_collection_size $removal_to_paths_col]

  if { $native_debug == 1 } {
    post_message -type info "IP SDC: "
    post_message -type info "       num_setup_from    = $num_setup_from_paths"
    post_message -type info "       num_setup_to      = $num_setup_to_paths"
    post_message -type info "       num_hold_from     = $num_hold_from_paths"
    post_message -type info "       num_hold_to       = $num_hold_to_paths"
    post_message -type info "       num_recovery_from = $num_recovery_from_paths"
    post_message -type info "       num_recovery_to   = $num_recovery_to_paths"
    post_message -type info "       num_removal_from  = $num_removal_from_paths"
    post_message -type info "       num_removal_to    = $num_removal_to_paths"
  }

  if {($num_setup_from_paths > 0) || ($num_setup_to_paths > 0) || ($num_hold_from_paths > 0) || ($num_hold_to_paths > 0) || ($num_recovery_from_paths > 0) || ($num_recovery_to_paths > 0) || ($num_removal_from_paths > 0) || ($num_removal_to_paths > 0)} {
     set pass 1

     # ----------------------------------------------------
     # Print out path information for SETUP FROM paths
     # ----------------------------------------------------
     if { $num_setup_from_paths > 0 } {

       # Initialize the number of found bond fifo paths to zero
       set num_bond_fifo_setup_paths 0

       foreach_in_collection path $setup_from_paths_col {

         # Check the arrival path points to see if one of them is the one of the bond_fifo pins (we should ignore this transfer)
         set arrival_pts_col [get_path_info -arrival_points $path]
         set found_bond_fifo_setup_path 0

         foreach_in_collection point $arrival_pts_col {

           # Only check the node points
           set pt_node_id [get_point_info -node $point]

           if { $pt_node_id != "" } {
             set pt_node_name [get_node_info -name $pt_node_id]
             set ds_out_rden_pin_regex "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_rden"
             set us_out_rden_pin_regex "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_rden"
             set ds_out_dv_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_dv"
             set us_out_dv_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_dv"


             if { [string match $ds_out_rden_pin_regex $pt_node_name] || [string match $us_out_rden_pin_regex $pt_node_name] || [string match $ds_out_dv_pin_regex $pt_node_name] || [string match $us_out_dv_pin_regex $pt_node_name] } {
               # Increment the number of found bond_fifo setup paths
               incr found_bond_fifo_setup_path
               incr num_bond_fifo_setup_paths
               break
             }

           }
         }; #foreach point in arrival_pts_col

         # Check to ensure the slack is positive
         set path_slack [get_path_info -slack $path]
         if { $path_slack < 0 } {
           set found_bond_fifo_setup_path 0 
         }

         # Print out the path info if no bond_fifo path was found
         if { $found_bond_fifo_setup_path == 0 } {
           set source_node [get_node_info  -name [get_path_info -from $path]]
           set dest_node   [get_node_info  -name [get_path_info -to $path]]
           set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
           set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
           post_message -type critical_warning "Unexpected timed setup path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
         }
       }; #foreach path in setup_from_paths_col

       # If the number of bond_fifo paths found matches the number of setup paths, then we can ignore the transfers
       if { $num_bond_fifo_setup_paths != $num_setup_from_paths } {
         set pass 0
       }
     }

     # ----------------------------------------------------
     # Print out path information for SETUP TO paths
     # ----------------------------------------------------
     if { $num_setup_to_paths > 0 } {

       # Initialize the number of found bond fifo paths to zero
       set num_bond_fifo_setup_paths 0

       foreach_in_collection path $setup_to_paths_col {

         # Check the arrival path points to see if one of them is the one of the bond_fifo pins (we should ignore this transfer)
         set arrival_pts_col [get_path_info -arrival_points $path]
         set found_bond_fifo_setup_path 0

         foreach_in_collection point $arrival_pts_col {

           # Only check the node points
           set pt_node_id [get_point_info -node $point]

           if { $pt_node_id != "" } {
             set pt_node_name [get_node_info -name $pt_node_id]
             set ds_out_rden_pin_regex "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_rden"
             set us_out_rden_pin_regex "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_rden"
             set ds_out_dv_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_dv"
             set us_out_dv_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_dv"


             if { [string match $ds_out_rden_pin_regex $pt_node_name] || [string match $us_out_rden_pin_regex $pt_node_name] || [string match $ds_out_dv_pin_regex $pt_node_name] || [string match $us_out_dv_pin_regex $pt_node_name] } {
               # Increment the number of found bond_fifo setup paths
               incr found_bond_fifo_setup_path
               incr num_bond_fifo_setup_paths
               break
             }

           }
         }; #foreach point in arrival_pts_col

         # Check to ensure the slack is positive
         set path_slack [get_path_info -slack $path]
         if { $path_slack < 0 } {
           set found_bond_fifo_setup_path 0 
         }

         # Print out the path info if no bond_fifo path was found
         if { $found_bond_fifo_setup_path == 0 } {
           set source_node [get_node_info  -name [get_path_info -from $path]]
           set dest_node   [get_node_info  -name [get_path_info -to $path]]
           set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
           set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
           post_message -type critical_warning "Unexpected timed setup path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
         }
       }; #foreach path in setup_to_paths_col

       # If the number of bond_fifo paths found matches the number of setup paths, then we can ignore the transfers
       if { $num_bond_fifo_setup_paths != $num_setup_to_paths } {
         set pass 0
       }
     }

     # ----------------------------------------------------
     # Print out path information for HOLD FROM paths
     # ----------------------------------------------------
     if { $num_hold_from_paths > 0 } {

       # Initialize the number of found bond fifo paths to zero
       set num_bond_fifo_hold_paths 0

       foreach_in_collection path $hold_from_paths_col {

         # Check the arrival path points to see if one of them is the one of the bond_fifo pins (we should ignore this transfer)
         set arrival_pts_col [get_path_info -arrival_points $path]
         set found_bond_fifo_hold_path 0

         foreach_in_collection point $arrival_pts_col {

           # Only check the node points
           set pt_node_id [get_point_info -node $point]

           if { $pt_node_id != "" } {
             set pt_node_name [get_node_info -name $pt_node_id]
             set ds_out_rden_pin_regex "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_rden"
             set us_out_rden_pin_regex "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_rden"
             set ds_out_dv_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_dv"
             set us_out_dv_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_dv"


             if { [string match $ds_out_rden_pin_regex $pt_node_name] || [string match $us_out_rden_pin_regex $pt_node_name] || [string match $ds_out_dv_pin_regex $pt_node_name] || [string match $us_out_dv_pin_regex $pt_node_name] } {
               # Increment the number of found bond_fifo hold paths
               incr found_bond_fifo_hold_path
               incr num_bond_fifo_hold_paths
               break
             }

           }
         }; #foreach point in arrival_pts_col

         # Check to ensure the slack is positive
         set path_slack [get_path_info -slack $path]
         if { $path_slack < 0 } {
           set found_bond_fifo_hold_path 0 
         }

         # Print out the path info if no bond_fifo path was found
         if { $found_bond_fifo_hold_path == 0 } {
           set source_node [get_node_info  -name [get_path_info -from $path]]
           set dest_node   [get_node_info  -name [get_path_info -to $path]]
           set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
           set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
           post_message -type critical_warning "Unexpected timed hold path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
         }
       }; #foreach path in hold_from_paths_col

       # If the number of bond_fifo paths found matches the number of hold paths, then we can ignore the transfers
       if { $num_bond_fifo_hold_paths != $num_hold_from_paths } {
         set pass 0
       }
     }

     # ----------------------------------------------------
     # Print out path information for HOLD TO paths
     # ----------------------------------------------------
     if { $num_hold_to_paths > 0 } {

       # Initialize the number of found bond fifo paths to zero
       set num_bond_fifo_hold_paths 0

       foreach_in_collection path $hold_to_paths_col {

         # Check the arrival path points to see if one of them is the one of the bond_fifo pins (we should ignore this transfer)
         set arrival_pts_col [get_path_info -arrival_points $path]
         set found_bond_fifo_hold_path 0

         foreach_in_collection point $arrival_pts_col {

           # Only check the node points
           set pt_node_id [get_point_info -node $point]

           if { $pt_node_id != "" } {
             set pt_node_name [get_node_info -name $pt_node_id]
             set ds_out_rden_pin_regex "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_rden"
             set us_out_rden_pin_regex "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_rden"
             set ds_out_dv_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_dv"
             set us_out_dv_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_dv"


             if { [string match $ds_out_rden_pin_regex $pt_node_name] || [string match $us_out_rden_pin_regex $pt_node_name] || [string match $ds_out_dv_pin_regex $pt_node_name] || [string match $us_out_dv_pin_regex $pt_node_name] } {
               # Increment the number of found bond_fifo hold paths
               incr found_bond_fifo_hold_path
               incr num_bond_fifo_hold_paths
               break
             }

           }
         }; #foreach point in arrival_pts_col

         # Check to ensure the slack is positive
         set path_slack [get_path_info -slack $path]
         if { $path_slack < 0 } {
           set found_bond_fifo_hold_path 0 
         }

         # Print out the path info if no bond_fifo path was found
         if { $found_bond_fifo_hold_path == 0 } {
           set source_node [get_node_info  -name [get_path_info -from $path]]
           set dest_node   [get_node_info  -name [get_path_info -to $path]]
           set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
           set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
           post_message -type critical_warning "Unexpected timed hold path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
         }
       }; #foreach path in hold_to_paths_col

       # If the number of bond_fifo paths found matches the number of hold paths, then we can ignore the transfers
       if { $num_bond_fifo_hold_paths != $num_hold_to_paths } {
         set pass 0
       }
     }

     # ----------------------------------------------------
     # Print out path information for RECOVERY FROM paths
     # ----------------------------------------------------
     if { $num_recovery_from_paths > 0 } {
       foreach_in_collection path $recovery_from_paths_col {
         set source_node [get_node_info  -name [get_path_info -from $path]]
         set dest_node   [get_node_info  -name [get_path_info -to $path]]
         set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
         set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
         post_message -type critical_warning "Unexpected timed recovery path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
       }

       # Set pass to zero
			 set pass 0

     }

     # ----------------------------------------------------
     # Print out path information for REMOVAL FROM paths
     # ----------------------------------------------------
     if { $num_removal_from_paths > 0 } {
       foreach_in_collection path $removal_from_paths_col {
         set source_node [get_node_info -name [get_path_info -from $path]]
         set dest_node   [get_node_info -name [get_path_info -to $path]]
         set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
         set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
         post_message -type critical_warning "Unexpected timed removal path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
       }

       # Set pass to zero
			 set pass 0

     }

     # ----------------------------------------------------
     # Print out path information for RECOVERY TO paths
     # ----------------------------------------------------
     if { $num_recovery_to_paths > 0 } {

       # Initialize the number of found reset paths to zero
       set num_reset_recovery_paths 0

       foreach_in_collection path $recovery_to_paths_col {

         # Check the arrival path points to see if one of them is the reset pin (we should ignore this transfer)
         set arrival_pts_col [get_path_info -arrival_points $path]
         set found_reset_recovery_path 0

         foreach_in_collection point $arrival_pts_col {

           # Only check the node points
           set pt_node_id [get_point_info -node $point]

           if { $pt_node_id != "" } {
             set pt_node_name [get_node_info -name $pt_node_id]
             set reset_adapt_pin_regex "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_adapter_tx_pld_rst_n"
             set reset_pcs_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_pcs_tx_pld_rst_n"
             set reset_pma_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_pma_txpma_rstb"

             if {[string match $reset_adapt_pin_regex $pt_node_name] || [string match $reset_pcs_pin_regex $pt_node_name] || [string match $reset_pma_pin_regex $pt_node_name]} {
               # Increment the number of found reset recovery paths
               incr found_reset_recovery_path
               incr num_reset_recovery_paths
               break
             }

           }
         }; #foreach point in arrival_pts_col

         # Check to ensure the slack is positive
         set path_slack [get_path_info -slack $path]
         if { $path_slack < 0 } {
           set found_reset_recovery_path 0 
         }

         # Print out the path info if no reset path was found
         if { $found_reset_recovery_path == 0 } {
           set source_node [get_node_info  -name [get_path_info -from $path]]
           set dest_node   [get_node_info  -name [get_path_info -to $path]]
           set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
           set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
           post_message -type critical_warning "Unexpected timed recovery path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
         }
       }; #foreach path in recovery_to_paths_col

       # If the number of reset paths found matches the number of recovery paths, then we can ignore the transfers
       if { $num_reset_recovery_paths != $num_recovery_to_paths } {
         # Set pass to zero
			   set pass 0

         if { $native_debug == 1 } {
           post_message -type warning "IP SDC: num_reset_recovery_paths = $num_reset_recovery_paths"
         }
       }
     }

     # ----------------------------------------------------
     # Print out path information for REMOVAL TO paths
     # ----------------------------------------------------
     if { $num_removal_to_paths > 0 } {

       # Initialize the number of found reset paths to zero
       set num_reset_removal_paths 0

       foreach_in_collection path $removal_to_paths_col {

         # Check the arrival path points to see if one of them is the reset pin (we should ignore this transfer)
         set arrival_pts_col [get_path_info -arrival_points $path]
         set found_reset_removal_path 0

         foreach_in_collection point $arrival_pts_col {

           # Only check the node points
           set pt_node_id [get_point_info -node $point]

           if { $pt_node_id != "" } {
             set pt_node_name [get_node_info -name $pt_node_id]
             set reset_adapt_pin_regex "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_adapter_tx_pld_rst_n"
             set reset_pcs_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_pcs_tx_pld_rst_n"
             set reset_pma_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_pma_txpma_rstb"

             if {[string match $reset_adapt_pin_regex $pt_node_name] || [string match $reset_pcs_pin_regex $pt_node_name] || [string match $reset_pma_pin_regex $pt_node_name]} {
               # Increment the number of found reset recovery paths
               incr found_reset_removal_path
               incr num_reset_removal_paths
               break
             }

           }
         }; #foreach point in arrival_pts_col

         # Check to ensure the slack is positive
         set path_slack [get_path_info -slack $path]
         if { $path_slack < 0 } {
           set found_reset_removal_path 0 
         }

         # Print out the path info if no reset path was found
         if { $found_reset_removal_path == 0 } {
           set source_node [get_node_info  -name [get_path_info -from $path]]
           set dest_node   [get_node_info  -name [get_path_info -to $path]]
           set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
           set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
           post_message -type critical_warning "Unexpected timed removal path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
         }
       }; #foreach path in removal_to_paths_col

       # If the number of reset paths found matches the number of removal paths, then we can ignore the transfers
       if { $num_reset_removal_paths != $num_removal_to_paths } {
         # Set pass to zero
			   set pass 0

         if { $native_debug == 1 } {
           post_message -type warning "IP SDC: num_reset_removal_paths = $num_reset_removal_paths"
         }
       }
    }

  }; #if { num_setup_from_paths > 0 || ... || ... }
  
  # Check if min pulse width passed
  if { $pass == 0 } {
     post_message -type critical_warning "Timing requirements not met"
  }
  
  # Before returning set the active clocks to the ones that were active before entering this function 
  set_active_clocks $old_active_clocks 
}


 13 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 2 ip 14 qsfp_xcvr_test 38 qsfp_xcvr_test_xcvr_native_s10_htile_1 33 altera_xcvr_native_s10_htile_1930 5 synth 39 alt_xcvr_native_re_cal_chnl_ugm7okq.sdc 6476 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# ---------------------------------------------------------------- #
# -                                                              - #
# --- THIS IS AN AUTO-GENERATED FILE!                          --- #
# --- Do not change the contents of this file.                 --- # 
# --- Your changes will be lost once the IP is regenerated!    --- #
# ---                                                          --- #
# --- This file contains the clock creation constraints for    --- #
# --- recalibration soft IP                                    --- #
# -                                                              - # 
# ---------------------------------------------------------------- #

# Source the IP parameters Tcl file
set script_dir [file dirname [info script]] 
set split_qsys_output_name [split qsfp_xcvr_test_xcvr_native_s10_htile_1_altera_xcvr_native_s10_htile_1930_ugm7okq "_"]
set xcvr_nphy_index [lsearch $split_qsys_output_name "altera"]
if {$xcvr_nphy_index < 0} {
  set list_top_inst_name $split_qsys_output_name
} else {
  set list_top_inst_name [lreplace $split_qsys_output_name $xcvr_nphy_index end]
}
set top_inst_name [join $list_top_inst_name "_"]
source "${script_dir}/${top_inst_name}_ip_parameters_ugm7okq.tcl"

# Get the number of channels in the Native PHY IP
set num_channels [dict get $native_phy_ip_params channels_profile0]

# Find the current Native PHY instance name in the design
set instance_name [get_current_instance]

# Grab the entity name for the XCVR reset sequencer (needed because the recal clocks are derived 
# from the internal oscillator clock which feeds the XCVR reset sequencer)
set alt_xcvr_reset_seq_entity_inst [get_entity_instances {altera_xcvr_reset_sequencer_s10}]
set alt_xcvr_reset_seq_entity_inst_list [split $alt_xcvr_reset_seq_entity_inst |]
set alt_xcvr_reset_seq_entity_inst_list  [lreplace $alt_xcvr_reset_seq_entity_inst_list end end]
set alt_xcvr_reset_seq_entity_inst_final_name [join $alt_xcvr_reset_seq_entity_inst_list |]

#-------------------------------------------------- #
#---                                            --- #
#--- CLOCK CREATION                             --- #
#---                                            --- #
#-------------------------------------------------- #

# For each channel
for {set i 0} {$i < $num_channels} {incr i} {

  # Get the clk_div8 registers
  set recal_clk_div8_col [get_registers -nowarn $instance_name|g_recal[$i].alt_xcvr_recal|clk_div8]
  if { [get_collection_size $recal_clk_div8_col] > 0 } {
  
    # Get the internal oscillator fanin to the clk_div2 register
    set clk_div8_fanin_col [get_fanins -stop_at_clocks $recal_clk_div8_col]
  
    set int_osc_clk_name ""
    foreach_in_collection fanin $clk_div8_fanin_col {
      set temp_fanin_name [get_node_info -name $fanin]
      if {[string match *$alt_xcvr_reset_seq_entity_inst_final_name*_divided_osc_clk|q $temp_fanin_name]} {
        set int_osc_clk_name $temp_fanin_name
        break
      }
    }
  
    # -------------------------------------------------- #
    # --- CLK_DIV2 CREATION                          --- #
    # -------------------------------------------------- #
    foreach_in_collection clk_div8 $recal_clk_div8_col {
  
      set clk_div8_node_name [get_node_info -name $clk_div8]
  
      if {$int_osc_clk_name != ""} {
  
        create_generated_clock \
          -name $instance_name|recal_clk_div8|ch$i \
          -divide_by 8 \
          -source $int_osc_clk_name \
          $clk_div8_node_name
      }; # if statement
     }; #foreach in recal_clk_div8_col
  }; #if clk_div8
}; #for i < num_channels


#-------------------------------------------------- #
#---                                            --- #
#--- SET FALSE PATHS TO SYNCHRONIZERS           --- #
#---                                            --- #
#-------------------------------------------------- #

# start_synchronizer
set start_synchronizer_col [get_registers -nowarn $instance_name|g_recal[*].alt_xcvr_recal|start_synchronizer|resync_chains[*].synchronizer_nocut|din_s1]
if {[get_collection_size $start_synchronizer_col] > 0} {
  foreach_in_collection resync_reg $start_synchronizer_col {
    set_false_path -to $resync_reg
  }
}

# alt_xcvr_resync_avmm1_busy
set alt_xcvr_resync_avmm1_busy_col [get_registers -nowarn $instance_name|g_recal[*].alt_xcvr_recal|alt_xcvr_resync_avmm1_busy|resync_chains[*].synchronizer_nocut|din_s1]
if {[get_collection_size $alt_xcvr_resync_avmm1_busy_col] > 0} {
  foreach_in_collection resync_reg $alt_xcvr_resync_avmm1_busy_col {
    set_false_path -to $resync_reg
  }
}

# alt_xcvr_resync_bg_en
set alt_xcvr_resync_bg_en_col [get_registers -nowarn $instance_name|g_recal[*].alt_xcvr_recal|alt_xcvr_resync_bg_en|resync_chains[*].synchronizer_nocut|din_s1]
if {[get_collection_size $alt_xcvr_resync_bg_en_col] > 0} {
  foreach_in_collection resync_reg $alt_xcvr_resync_bg_en_col {
    set_false_path -to $resync_reg
  }
}

# alt_xcvr_resync_recal_waitrequest
set alt_xcvr_resync_recal_waitrequest_col [get_registers -nowarn $instance_name|g_recal[*].alt_xcvr_recal|recal_wreq_synchronizer|resync_chains[*].synchronizer_nocut|din_s1]
if {[get_collection_size $alt_xcvr_resync_recal_waitrequest_col] > 0} {
  foreach_in_collection resync_reg $alt_xcvr_resync_recal_waitrequest_col {
    set_false_path -to $resync_reg
  }
}
# alt_xcvr_resync_reset
set alt_xcvr_resync_reset_col [get_pins -nowarn $instance_name|g_recal[*].alt_xcvr_recal|alt_xcvr_resync_reset*|resync_chains[*].synchronizer_nocut|d*|clrn]
if {[get_collection_size $alt_xcvr_resync_reset_col] > 0} {
  foreach_in_collection resync_reg $alt_xcvr_resync_reset_col {
    set_false_path -through $resync_reg
  }
}



 13 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 2 ip 14 qsfp_xcvr_test 38 qsfp_xcvr_test_xcvr_native_s10_htile_1 33 altera_xcvr_native_s10_htile_1930 5 synth 84 qsfp_xcvr_test_xcvr_native_s10_htile_1_altera_xcvr_native_s10_htile_1930_ugm7okq.sdc 97865 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# ---------------------------------------------------------------- #
# -                                                              - #
# --- THIS IS AN AUTO-GENERATED FILE!                          --- #
# --- Do not change the contents of this file.                 --- # 
# --- Your changes will be lost once the IP is regenerated!    --- #
# ---                                                          --- #
# --- This file contains the timing constraints for Native PHY --- #
# ---    * The helper functions are defined in                 --- #
# ---      alt_xcvr_native_helper_functions_ugm7okq.tcl        --- #
# -                                                              - # 
# ---------------------------------------------------------------- #

set script_dir [file dirname [info script]] 
set split_qsys_output_name [split qsfp_xcvr_test_xcvr_native_s10_htile_1_altera_xcvr_native_s10_htile_1930_ugm7okq "_"]
set xcvr_nphy_index [lsearch $split_qsys_output_name "altera"]
if {$xcvr_nphy_index < 0} {
  set list_top_inst_name $split_qsys_output_name
} else {
  set list_top_inst_name [lreplace $split_qsys_output_name $xcvr_nphy_index end]
}
set top_inst_name [join $list_top_inst_name "_"]
source "${script_dir}/${top_inst_name}_ip_parameters_ugm7okq.tcl"
source "${script_dir}/alt_xcvr_native_helper_functions_ugm7okq.tcl"

# Debug switch. Change to 1 in alt_xcvr_native_helper_functions_ugm7okq.tcl to get more run-time debug information
if {![info exists native_debug]} {
  global ::native_debug
}

# ---------------------------------------------------------------- #
# -                                                              - #
# --- Build cache for all pins and registers required to apply --- #
# --- timing constraints                                       --- #
# -                                                              - #
# ---------------------------------------------------------------- #
native_initialize_db_ugm7okq nativedb_ugm7okq

# ---------------------------------------------------------------- #
# --- Set all the instances of this core                       --- #
# ---------------------------------------------------------------- #
set alt_xcvr_native_s10_instances [ dict keys $nativedb_ugm7okq ]

if {[info exists alt_xcvr_native_s10_pins]} {
   unset alt_xcvr_native_s10_pins
}
set alt_xcvr_native_s10_pins [dict create]

# ---------------------------------------------------------------- #
# -                                                              - #
# --- Iterate through each instance and apply the necessary    --- #
# --- timing constraints                                       --- #
# -                                                              - #
# ---------------------------------------------------------------- #
foreach inst $alt_xcvr_native_s10_instances {

  if { [ dict exists $alt_xcvr_native_s10_pins $inst ] } {
    dict unset alt_xcvr_native_s10_pins $inst
    
    if { $native_debug == 1} {
      post_message -type info "IP SDC: Array pins for instance $inst existed before, unsetting them"
    }

  } 
  dict set alt_xcvr_native_s10_pins $inst [dict get $nativedb_ugm7okq $inst]

  # Delete the clock names array if it exists 
  if [info exists all_profile_clocks_names] {
    unset all_profile_clocks_names
  }
  set all_profile_clocks_names [dict create]

  # -------------------------------------------------------------- #
  # --- Iterate over the profiles                              --- #
  # -------------------------------------------------------------- #
  set profile_cnt [dict get $native_phy_ip_params profile_cnt]
  set tx_enabled_on_any_profile    0
  set max_num_channels             0
  for {set i 0} {$i < $profile_cnt} {incr i} {

    if {$native_debug == 1} {
      post_message -type info "========================================================================================"
      post_message -type info "IP SDC: PROFILE $i"
    }

    set num_channels [dict get $native_phy_ip_params channels_profile$i]
    set max_num_channels  [expr { $num_channels > $max_num_channels? $num_channels : $max_num_channels} ]

    # ------------------------------------------------------------------------------- # 
    # --- Determine the FIFO operation mode (phase-compensation or register mode) --- #
    # ------------------------------------------------------------------------------- #
    if {[dict get $native_phy_ip_params tx_fifo_mode_profile$i] == "Register"} {
      set tx_fifo_mode "register"
    } else {
      set tx_fifo_mode "pc_fifo"
    }

    if {[dict get $native_phy_ip_params rx_fifo_mode_profile$i] == "Register" || [dict get $native_phy_ip_params rx_fifo_mode_profile$i] == "Phase compensation-Register" } {
      set rx_fifo_mode "register"
    } else {
      set rx_fifo_mode "pc_fifo"
    }

    if {$native_debug == 1} {
      post_message -type info "========================================================================================"
      post_message -type info "IP SDC: TX mode inferred in SDC is $tx_fifo_mode"
      post_message -type info "IP SDC: RX mode inferred in SDC is $rx_fifo_mode"
      post_message -type info "IP SDC: The procotol mode is [dict get $native_phy_ip_params protocol_mode_profile$i]"
      post_message -type info "IP SDC: The standard PCS-PMA interface width is [dict get $native_phy_ip_params std_pcs_pma_width_profile$i]"
      post_message -type info "IP SDC: The enhanced PCS-PMA interface width is [dict get $native_phy_ip_params enh_pcs_pma_width_profile$i]"
      post_message -type info "IP SDC: The data rate is [dict get $native_phy_ip_params set_data_rate_profile$i] Mbps."
    }

    set tx_fifo_transfer_mode [dict get $native_phy_ip_params l_tx_fifo_transfer_mode_profile$i]
    set rx_fifo_transfer_mode [dict get $native_phy_ip_params l_rx_fifo_transfer_mode_profile$i]

    # ----------------------------------------------------------------------------- #
    # --- Set the selected clock from mux for tx/rx_clkout and tx/rx_clkout2    --- #
    # ----------------------------------------------------------------------------- #
    set tx_clkout_sel [dict get $native_phy_ip_params tx_clkout_sel_profile$i]
    set tx_clkout2_sel [dict get $native_phy_ip_params tx_clkout2_sel_profile$i]

    set rx_clkout_sel [dict get $native_phy_ip_params rx_clkout_sel_profile$i]
    set rx_clkout2_sel [dict get $native_phy_ip_params rx_clkout2_sel_profile$i]

    if {$native_debug == 1} {
      post_message -type info "IP SDC: Clock output of tx_clkout is $tx_clkout_sel"
      post_message -type info "IP SDC: Clock output of tx_clkout2 is $tx_clkout2_sel"
      post_message -type info "IP SDC: Clock output of rx_clkout is $rx_clkout_sel"
      post_message -type info "IP SDC: Clock output of rx_clkout2 is $rx_clkout2_sel"
    }

    # ------------------------------------------------------------------------------ #
    # --- Determine the datapath based on the selected protocol mode             --- #
    # ------------------------------------------------------------------------------ #
    set datapath_select [dict get $native_phy_ip_params datapath_select_profile$i]
    set protocol_mode   [dict get $native_phy_ip_params protocol_mode_profile$i]
    set duplex_mode     [dict get $native_phy_ip_params duplex_mode_profile$i]

    # ----------------------------------------------------------------------------- #
    # --- Determine the PCS-PMA width based on which datapath was selected      --- #
    # ----------------------------------------------------------------------------- #
    if {$datapath_select == "Enhanced"} {
      set pcs_pma_width [dict get $native_phy_ip_params enh_pcs_pma_width_profile$i]
    } elseif {$datapath_select == "Standard"} {
      set pcs_pma_width [dict get $native_phy_ip_params std_pcs_pma_width_profile$i]
    } elseif {$datapath_select == "PCS Direct"} {
      set pcs_pma_width [dict get $native_phy_ip_params pcs_direct_width_profile$i]
    } else {
      post_message -type error "IP SDC: Datapath did not match any of the valid options (Standard, Enhanced, PCS Direct)."
    }
    
    # ----------------------------------------------------------------------------- #
    # --- Determine the pma_div_clkout factor                                   --- #
    # ----------------------------------------------------------------------------- #
    set tx_pma_div_clkout_divider [dict get $native_phy_ip_params tx_pma_div_clkout_divider_profile$i]
    set rx_pma_div_clkout_divider [dict get $native_phy_ip_params rx_pma_div_clkout_divider_profile$i]

    if {$tx_pma_div_clkout_divider == 0} {
      set tx_pma_div_clkout_divider 1
    }
    if {$rx_pma_div_clkout_divider == 0} {
      set rx_pma_div_clkout_divider 1
    }

    # ----------------------------------------------------------------------------- #
    # --- Byte serializer and byte deserializer                                 --- #
    # ----------------------------------------------------------------------------- #
    set std_tx_byte_ser_mode [dict get $native_phy_ip_params std_tx_byte_ser_mode_profile$i]
    if {$std_tx_byte_ser_mode == "Serialize x2" && $datapath_select == "Standard"} {
      set byte_ser 2
    } elseif {$std_tx_byte_ser_mode == "Serialize x4" && $datapath_select == "Standard"} {
      set byte_ser 4
    } else {
      set byte_ser 1
    }

    set std_rx_byte_deser_mode [dict get $native_phy_ip_params std_rx_byte_deser_mode_profile$i]
    if {$std_rx_byte_deser_mode == "Deserialize x2" && $datapath_select == "Standard"} {
      set byte_deser 2
    } elseif {$std_rx_byte_deser_mode == "Deserialize x4" && $datapath_select == "Standard"} {
      set byte_deser 4
    } else {
      set byte_deser 1
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: Byte serializer is $byte_ser"
      post_message -type info "IP SDC: Byte deserializer is $byte_deser"
    }

    # ----------------------------------------------------------------------------- #
    # --- Calculate the parallel PMA clock frequency                            --- #
    # ----------------------------------------------------------------------------- #
    set data_rate [expr double([dict get $native_phy_ip_params set_data_rate_profile$i])]
    set pma_parallel_clock [ expr $data_rate / $pcs_pma_width ]

    set tx_transfer_clk_freq [expr double($data_rate / ($pcs_pma_width * $byte_ser)) ]
    set rx_transfer_clk_freq [expr double($data_rate / ($pcs_pma_width * $byte_deser)) ]

    if { $tx_fifo_transfer_mode != "x1" } {
        set tx_transfer_clk_freq [expr $tx_transfer_clk_freq * 2 ]
    }

    if { $rx_fifo_transfer_mode != "x1" } {
        set rx_transfer_clk_freq [expr $rx_transfer_clk_freq * 2 ]
    }

    if { $native_debug ==1 } {
      post_message -type info "IP SDC: PMA parallel CLK is $pma_parallel_clock MHz"
      post_message -type info "IP SDC: Clock output of TX transfer clock is $tx_transfer_clk_freq MHz"
      post_message -type info "IP SDC: Clock output of RX transfer clock is $rx_transfer_clk_freq MHz"
    }

    # ----------------------------------------------------------------------------- #
    # --- Unset the profile_clocks dictionary if it exists                      --- #
    # ----------------------------------------------------------------------------- #
    if [info exists profile_clocks] {
      unset profile_clocks
    }
    set profile_clocks [dict create]

    if {[info exists freq] } {
      unset freq
    }
    set freq [dict create]

    if {[info exists multiply_factor_dict] } {
      unset multiply_factor_dict
    }
    set multiply_factor_dict [dict create]

    if {[info exists divide_factor_dict] } {
      unset divide_factor_dict
    }
    set divide_factor_dict [dict create]

    # ----------------------------------------------------------------------------- #
    # --- Create TX mode clocks and clock frequencies                           --- #
    # ----------------------------------------------------------------------------- #
    # For each TX clock output (tx_clkout and tx_clkout2), the selected clock from
    # main adapter clock mux is checked.
    #
    # 1. PCS_CLKOUT     : frequency is PCS parallel clock (with serialization factor)
    #
    # 2. PCS_x2_CLKOUT  :
    #     - If transfer mode is x2 (full-rate) or x1x2 (double-rate): x2 parallel clock
    #           > Unless Standard PCS, PCS-PMA width == 20, and byte serializer is
    #             disabled: parallel clock
    #     - If transfer mode is x1 (half-rate): parallel clock
    #     - **NOTE** Native PHY parameter tx_transfer_clk_freq already accounts for 
    #                byte serializer and provides correct frequency based on transfer
    #                mode (except in case of Standard PCS, PMA-PLD = 20)
    #
    # 3. PMA_DIV_CLKOUT :
    #     - If tx_pma_div_clkout == 33, 40, 66: data rate / (pma_div * 2)
    #     - If tx_pma_div_clkout == 1, 2: parallel clock / pma_div
    #
    # **NOTE** Both FIFO (Phase-Compensation) and Register mode have the same nodes
    #          because TX Register mode is fed from the core (core_clkin)
    #
    if {[dict get $native_phy_ip_params tx_enable_profile$i]} {

      set tx_enabled_on_any_profile   1

      # -------------------------------------------------------------------------------
      # AIB TX CLK SOURCE - PMA parallel clock
      # -------------------------------------------------------------------------------
      dict set profile_clocks tx_source_clks tx_pma_parallel_clk
      dict set freq tx_pma_parallel_clk $pma_parallel_clock

      # -------------------------------------------------------------------------------
      # AIB TX INTERNAL DIV REG - transfer clock
      # -------------------------------------------------------------------------------
      dict set profile_clocks tx_internal_div_reg_clks tx_pcs_x2_clk
    
      if {$tx_fifo_transfer_mode != "x1"} {
         dict set multiply_factor_dict tx_pcs_x2_clk 2
         dict set divide_factor_dict   tx_pcs_x2_clk [expr 1*($byte_ser)]
      } else {
         dict set multiply_factor_dict tx_pcs_x2_clk 1
         dict set divide_factor_dict   tx_pcs_x2_clk [expr 1*($byte_ser)]
      }
      # -------------------------------------------------------------------------------
      # TX_CLKOUT - output clocks
      # -------------------------------------------------------------------------------
      if {$tx_clkout_sel == "pcs_clkout" } {
        dict set profile_clocks tx_mode_clks tx_clkout
        
        # If TX transfer mode is x1 then tx_transfer_clk is correct (parallel clock)
        # Otherwise for x2 or x1x2, tx_transfer_clk is twice parallel_clock
        if {$tx_fifo_transfer_mode == "x1"} {
          dict set multiply_factor_dict tx_clkout 1
          dict set divide_factor_dict   tx_clkout 1
        } else {
          dict set multiply_factor_dict tx_clkout 1
          dict set divide_factor_dict   tx_clkout 2
        }

      } elseif {$tx_clkout_sel == "pcs_x2_clkout" } {
        dict set profile_clocks tx_mode_clks tx_clkout

        # If TX transfer mode is x2/x1x2, Standard PCS, PCS-PMA width == 20, and byte serializer is disabled => parallel clock
        if {($tx_fifo_transfer_mode == "x2" || $tx_fifo_transfer_mode == "x1x2") &&
              (($datapath_select == "Standard" && $pcs_pma_width == 20 && $std_tx_byte_ser_mode == "Disabled") ||
             ($datapath_select == "PCS Direct" && $pcs_pma_width == 20))} {
          dict set multiply_factor_dict tx_clkout 1
          dict set divide_factor_dict   tx_clkout 2
        } else {
          dict set multiply_factor_dict tx_clkout 1
          dict set divide_factor_dict   tx_clkout 1
        }

      } elseif {$tx_clkout_sel == "pma_div_clkout" } {
        dict set profile_clocks tx_mode_clks tx_clkout

        if {$tx_pma_div_clkout_divider == 33 || $tx_pma_div_clkout_divider == 40 || $tx_pma_div_clkout_divider == 66 } {

          if {$tx_fifo_transfer_mode == "x1"} {
            dict set multiply_factor_dict tx_clkout [expr $byte_ser * $pcs_pma_width]
            dict set divide_factor_dict   tx_clkout [expr round($tx_pma_div_clkout_divider * 2)]
          } else {
            dict set multiply_factor_dict tx_clkout [expr $byte_ser * $pcs_pma_width]
            dict set divide_factor_dict   tx_clkout [expr round($tx_pma_div_clkout_divider * 2 * 2)]
          }

        } else {

          if {$tx_fifo_transfer_mode == "x1"} {
            dict set multiply_factor_dict tx_clkout 1
            dict set divide_factor_dict   tx_clkout $tx_pma_div_clkout_divider
          } else {
            dict set multiply_factor_dict tx_clkout 1
            dict set divide_factor_dict   tx_clkout [expr $tx_pma_div_clkout_divider * 2]
          }

        }
      } else {
        post_message -type error "IP SDC: TX CLKOUT did not match any of the valid clock options. Check the TX Clock Options."
      }

      # -------------------------------------------------------------------------------
      # TX_CLKOUT2 - output clocks
      # -------------------------------------------------------------------------------
      if {[dict get $native_phy_ip_params enable_port_tx_clkout2_profile$i] == 1} {
        if {$tx_clkout2_sel == "pcs_clkout" } {
          dict lappend profile_clocks tx_mode_clks tx_clkout2

          # If TX transfer mode is x1 then tx_transfer_clk is correct (parallel clock)
          # Otherwise for x2 or x1x2, tx_transfer_clk is twice parallel_clock
          if {$tx_fifo_transfer_mode == "x1"} {
            dict set multiply_factor_dict tx_clkout2 1
            dict set divide_factor_dict   tx_clkout2 1
          } else {
            dict set multiply_factor_dict tx_clkout2 1
            dict set divide_factor_dict   tx_clkout2 2
          }

        } elseif {$tx_clkout2_sel == "pcs_x2_clkout" } {
          dict lappend profile_clocks tx_mode_clks tx_clkout2

          # If TX transfer mode is x2/x1x2, Standard PCS, PCS-PMA width == 20, and byte serializer is disabled => parallel clock
          if {(($tx_fifo_transfer_mode == "x2" || $tx_fifo_transfer_mode == "x1x2") &&
                $datapath_select == "Standard" && $pcs_pma_width == 20 && $std_tx_byte_ser_mode == "Disabled") ||
               ($datapath_select == "PCS Direct" && $pcs_pma_width == 20)} {
            dict set multiply_factor_dict tx_clkout2 1
            dict set divide_factor_dict   tx_clkout2 2
          } else {
            dict set multiply_factor_dict tx_clkout2 1
            dict set divide_factor_dict   tx_clkout2 1
          }
           
        } elseif {$tx_clkout2_sel == "pma_div_clkout" } {
         dict lappend profile_clocks tx_mode_clks tx_clkout2

          if {$tx_pma_div_clkout_divider == 33 || $tx_pma_div_clkout_divider == 40 || $tx_pma_div_clkout_divider == 66 } {

            if {$tx_fifo_transfer_mode == "x1"} {
              dict set multiply_factor_dict tx_clkout2 [expr $byte_ser * $pcs_pma_width]
              dict set divide_factor_dict   tx_clkout2 [expr round($tx_pma_div_clkout_divider * 2)]
            } else {
              dict set multiply_factor_dict tx_clkout2 [expr $byte_ser * $pcs_pma_width]
              dict set divide_factor_dict   tx_clkout2 [expr round($tx_pma_div_clkout_divider * 2 * 2)]
            }

          } else {

            if {$tx_fifo_transfer_mode == "x1"} {
              dict set multiply_factor_dict tx_clkout2 1
              dict set divide_factor_dict   tx_clkout2 $tx_pma_div_clkout_divider
            } else {
              dict set multiply_factor_dict tx_clkout2 1
              dict set divide_factor_dict   tx_clkout2 [expr $tx_pma_div_clkout_divider * 2]
            }
          }

        } else {
          post_message -type error "IP SDC: TX CLKOUT2 did not match any of the valid clock options. Check the TX Clock Options."
        }
      } else {
        if {$native_debug == 1} {
          post_message -type info "IP SDC: TX CLKOUT2 port is not enabled"
        }
      }

    } ; # if tx_enable_profile

    # ----------------------------------------------------------------------------- #
    # --- Create RX mode clocks and clock frequencies                           --- #
    # ----------------------------------------------------------------------------- #
    # For each RX clock output (rx_clkout and rx_clkout2), the selected clock from
    # main adapter clock mux is checked.
    #
    # 1. PCS_CLKOUT     : frequency is PCS parallel clock (with deserialization factor)
    #
    # 2. PCS_x2_CLKOUT  :
    #     - If transfer mode is x2 (full-rate) or x1x2 (double-rate): x2 parallel clock
    #     - If transfer mode is x1 (half-rate): parallel clock
    #     - **NOTE** Native PHY parameter rx_transfer_clk_freq already accounts for 
    #                byte deserializer and provides correct frequency based on transfer
    #                mode.
    #
    # 3. PMA_DIV_CLKOUT :
    #     - If rx_pma_div_clkout == 33, 40, 66: data rate / (pma_div * 2)
    #     - If rx_pma_div_clkout == 1, 2: parallel clock / pma_div
    #
    # **NOTE** FIFO (Phase-Compensation) and Register mode have the different nodes
    #          when selected clock is pcs_x2_clock because RX transfer clock is fed to
    #          main adapter FIFO read and write before the clock mux in register mode
    #          (only ONE rx_transfer_clk is created).
    #
    if {[dict get $native_phy_ip_params rx_enable_profile$i]} {

      # -------------------------------------------------------------------------------
      # AIB RX CLK SOURCE - PMA parallel clock
      # -------------------------------------------------------------------------------
      dict set profile_clocks rx_source_clks rx_pma_parallel_clk
      dict set freq rx_pma_parallel_clk $pma_parallel_clock

      # -------------------------------------------------------------------------------
      # AIB RX INTERNAL DIV REG - transfer clock
      # -------------------------------------------------------------------------------
      dict set profile_clocks rx_internal_div_reg_clks rx_pcs_x2_clk
     
      if {$rx_fifo_transfer_mode != "x1"} {
         dict set multiply_factor_dict rx_pcs_x2_clk 2
         dict set divide_factor_dict   rx_pcs_x2_clk [expr 1*($byte_deser)]
      } else {
         dict set multiply_factor_dict rx_pcs_x2_clk 1
         dict set divide_factor_dict   rx_pcs_x2_clk [expr 1*($byte_deser)]
      }

      # -------------------------------------------------------------------------------
      # RX_CLKOUT - output clocks
      # -------------------------------------------------------------------------------
      if {$rx_fifo_mode == "pc_fifo"} {
        if {$rx_clkout_sel == "pcs_clkout" } {
          dict set profile_clocks rx_mode_clks rx_clkout

          if {$rx_fifo_transfer_mode == "x1"} {
            dict set multiply_factor_dict rx_clkout 1
            dict set divide_factor_dict   rx_clkout 1
          } else {
            dict set multiply_factor_dict rx_clkout 1
            dict set divide_factor_dict   rx_clkout 2
          }

        } elseif {$rx_clkout_sel == "pcs_x2_clkout" } {
          dict set profile_clocks rx_mode_clks rx_clkout
          dict set multiply_factor_dict rx_clkout 1
          dict set divide_factor_dict   rx_clkout 1
 
        } elseif {$rx_clkout_sel == "pma_div_clkout" } {
          dict set profile_clocks rx_mode_clks rx_clkout

          if {$rx_pma_div_clkout_divider == 33 || $rx_pma_div_clkout_divider == 40 || $rx_pma_div_clkout_divider == 66 } {

            if {$rx_fifo_transfer_mode == "x1"} {
              dict set multiply_factor_dict rx_clkout [expr $byte_deser * $pcs_pma_width]
              dict set divide_factor_dict   rx_clkout [expr round($rx_pma_div_clkout_divider * 2)]
            } else {
              dict set multiply_factor_dict rx_clkout [expr $byte_deser * $pcs_pma_width]
              dict set divide_factor_dict   rx_clkout [expr round($rx_pma_div_clkout_divider * 2 * 2)]
            }

          } else {

            if {$rx_fifo_transfer_mode == "x1"} {
              dict set multiply_factor_dict rx_clkout 1
              dict set divide_factor_dict   rx_clkout $rx_pma_div_clkout_divider
            } else {
              dict set multiply_factor_dict rx_clkout 1
              dict set divide_factor_dict   rx_clkout [expr $rx_pma_div_clkout_divider * 2]
            }
          }

        } else {
          post_message -type error "IP SDC: RX CLKOUT did not match any of the valid clock options. Check the RX Clock Options."
        }
      } else { # RX FIFO is in register mode
        if {$rx_clkout_sel == "pcs_x2_clkout" } {
          dict set profile_clocks rx_mode_clks rx_transfer_clk
          dict set multiply_factor_dict rx_transfer_clk 1
          dict set divide_factor_dict   rx_transfer_clk 1

        } else {
          post_message -type error "IP SDC: RX CLKOUT did not match any of the valid clock options. Check the RX Clock Options."
        }
      }

      # -------------------------------------------------------------------------------
      # RX_CLKOUT2 - output clocks
      # -------------------------------------------------------------------------------
      if {[dict get $native_phy_ip_params enable_port_rx_clkout2_profile$i] == 1} {
        if {$rx_clkout2_sel == "pcs_clkout" } {
          dict lappend profile_clocks rx_mode_clks rx_clkout2

          if {$rx_fifo_transfer_mode == "x1"} {
            dict set multiply_factor_dict rx_clkout2 1
            dict set divide_factor_dict   rx_clkout2 1
          } else {
            dict set multiply_factor_dict rx_clkout2 1
            dict set divide_factor_dict   rx_clkout2 2
          }

        } elseif {$rx_clkout2_sel == "pcs_x2_clkout" } {

          if {$rx_fifo_mode == "pc_fifo"} {
            dict lappend profile_clocks rx_mode_clks rx_clkout2
            dict set multiply_factor_dict rx_clkout2 1
            dict set divide_factor_dict   rx_clkout2 1
          } elseif {$rx_fifo_mode == "register" && $rx_clkout_sel != "pcs_x2_clkout"} {
            dict lappend profile_clocks rx_mode_clks rx_transfer_clk2      
            dict set multiply_factor_dict rx_transfer_clk2 1
            dict set divide_factor_dict   rx_transfer_clk2 1
          }

        } elseif {$rx_clkout2_sel == "pma_div_clkout" } {
          dict lappend profile_clocks rx_mode_clks rx_clkout2

          if {$rx_pma_div_clkout_divider == 33 || $rx_pma_div_clkout_divider == 40 || $rx_pma_div_clkout_divider == 66 } {

            if {$rx_fifo_transfer_mode == "x1"} {
              dict set multiply_factor_dict rx_clkout2 [expr $byte_deser * $pcs_pma_width]
              dict set divide_factor_dict   rx_clkout2 [expr round($rx_pma_div_clkout_divider * 2)]
            } else {
              dict set multiply_factor_dict rx_clkout2 [expr $byte_deser * $pcs_pma_width]
              dict set divide_factor_dict   rx_clkout2 [expr round($rx_pma_div_clkout_divider * 2 * 2)]
            }

          } elseif {$rx_pma_div_clkout_divider == 2 && $pcs_pma_width == 10} {
            if {$rx_fifo_transfer_mode == "x1"} {
              dict set multiply_factor_dict rx_clkout2 1
              dict set divide_factor_dict   rx_clkout2 [expr round($rx_pma_div_clkout_divider / 2)]
            } else {
              dict set multiply_factor_dict rx_clkout2 1
              dict set divide_factor_dict   rx_clkout2 [expr $rx_pma_div_clkout_divider * 2]
            }          

          } else {

            if {$rx_fifo_transfer_mode == "x1"} {
              dict set multiply_factor_dict rx_clkout2 1
              dict set divide_factor_dict   rx_clkout2 $rx_pma_div_clkout_divider
            } else {
              dict set multiply_factor_dict rx_clkout2 1
              dict set divide_factor_dict   rx_clkout2 [expr $rx_pma_div_clkout_divider * 2]
            }
          }

        } else {
          post_message -type error "IP SDC: RX CLKOUT2 did not match any of the valid clock options. Check the RX Clock Options"
        }

      } else {
        if {$native_debug == 1} {
          post_message -type info "IP SDC: RX CLKOUT2 port is not enabled"
        }
      }
    } ; # if rx_enable_profile

    # ----------------------------------------------------------------------------- #
    # --- Create PIPE clocks and clock frequencies                              --- #
    # ----------------------------------------------------------------------------- #

    # -------------------------------------------------------------------------------
    # HCLK
    # If we are in Gen 3 and we have hip... we have a 1Gig clock (might need to change for hip... as it comes out to the core...)
    #--------------------------------------------------------------------------------
    set hclk_freq ""
    if {[dict get $native_phy_ip_params enable_hip_profile$i] == 1} {
      set hclk_freq 1000
    } else {
      set hclk_freq 500
    }

    if {$protocol_mode == "pipe_g1" || $protocol_mode == "pipe_g2" || $protocol_mode == "pipe_g3"} {

      # Find the maximum precision of RX transfer clock frequency
      set rx_pma_parallel_clk_split [split $pma_parallel_clock "."]
      set rx_max_precision          [expr [string length [lindex $rx_pma_parallel_clk_split end]]]

      # Ensure that multiply and divide factors are less than 999999999
      if {[llength $rx_pma_parallel_clk_split] > 1 && [string length $pma_parallel_clock ] > 10} {
        set rx_max_precision [expr $rx_max_precision - [string length [lindex $rx_pma_parallel_clk_split 0]]]
      }

      dict set profile_clocks       hclk_internal_div_reg_clks hclk_internal_div_reg
      dict set multiply_factor_dict hclk_internal_div_reg [expr round($hclk_freq * (10 ** $rx_max_precision))]
      dict set divide_factor_dict   hclk_internal_div_reg [expr round($pma_parallel_clock * (10 ** $rx_max_precision))]

      dict set profile_clocks       hclk_mode hclk
      dict set multiply_factor_dict hclk 1
      dict set divide_factor_dict   hclk 1
    }

    # -------------------------------------------------------------------------------
    # PIPE Gen2
    # Create Gen2 and Gen1 clocks for PIPE Gen2 and PIPE Gen3
    # -------------------------------------------------------------------------------
    if {$protocol_mode == "pipe_g2" || $protocol_mode == "pipe_g3"} {

      # TX PIPE Gen2
      dict lappend profile_clocks tx_mode_clks tx_clkout_pipe_g2
      dict set multiply_factor_dict tx_clkout_pipe_g2 [dict get $multiply_factor_dict tx_clkout]
      dict set divide_factor_dict   tx_clkout_pipe_g2 [dict get $divide_factor_dict   tx_clkout]

      # TX PIPE Gen1
      dict lappend profile_clocks tx_mode_clks tx_clkout_pipe_g1
      dict set multiply_factor_dict tx_clkout_pipe_g1 [dict get $multiply_factor_dict tx_clkout_pipe_g2]
      dict set divide_factor_dict   tx_clkout_pipe_g1 [expr round([dict get $divide_factor_dict tx_clkout_pipe_g2] * 2)]

      # Remove original tx_clkout from profile_clocks and freq dictionaries
      set list_of_tx_clkouts [dict get $profile_clocks tx_mode_clks]
      set tx_clkout_index [lsearch $list_of_tx_clkouts tx_clkout]
      if {$tx_clkout_index < 0} {
        if {$native_debug == 1} {
          post_message -type warning "IP SDC: Cannot find key tx_clkout while creating PIPE clocks in list $list_of_tx_clkouts"
        }
      } else {
        dict set profile_clocks tx_mode_clks [lreplace $list_of_tx_clkouts $tx_clkout_index $tx_clkout_index]
      }

      set multiply_factor_dict [dict remove $multiply_factor_dict tx_clkout]
      set divide_factor_dict   [dict remove $divide_factor_dict   tx_clkout]

      # TX_CLKOUT2
      if {[dict get $native_phy_ip_params enable_port_tx_clkout2_profile$i] == 1} {

        # TX PIPE Gen2
        dict lappend profile_clocks tx_mode_clks tx_clkout2_pipe_g2
        dict set multiply_factor_dict tx_clkout2_pipe_g2 [dict get $multiply_factor_dict tx_clkout2]
        dict set divide_factor_dict   tx_clkout2_pipe_g2 [dict get $divide_factor_dict   tx_clkout2]

        # TX PIPE Gen1
        dict lappend profile_clocks tx_mode_clks tx_clkout2_pipe_g1
        dict set multiply_factor_dict tx_clkout2_pipe_g1 [dict get $multiply_factor_dict tx_clkout2_pipe_g2]
        dict set divide_factor_dict   tx_clkout2_pipe_g1 [expr round([dict get $divide_factor_dict tx_clkout2_pipe_g2] * 2)]

        # Remove original tx_clkout2 from profile_clocks and freq dictionaries
        set list_of_tx_clkouts [dict get $profile_clocks tx_mode_clks]
        set tx_clkout2_index [lsearch $list_of_tx_clkouts tx_clkout2]
        if {$tx_clkout2_index < 0} {
          if {$native_debug == 1} {
            post_message -type warning "IP SDC: Cannot find key tx_clkout2 while creating PIPE clocks in list $list_of_tx_clkouts"
          }
        } else {
          dict set profile_clocks tx_mode_clks [lreplace $list_of_tx_clkouts $tx_clkout2_index $tx_clkout2_index]
        }

        set multiply_factor_dict [dict remove $multiply_factor_dict tx_clkout2]
        set divide_factor_dict   [dict remove $divide_factor_dict   tx_clkout2]
 
      }

      if {$native_debug == 1} {
        post_message -type info "IP SDC: TX mode clocks - [dict get $profile_clocks tx_mode_clks]"
      }

      # RX PIPE
      if {[dict exists $profile_clocks rx_transfer_clk]} {

        # RX PIPE Gen2
        dict lappend profile_clocks rx_mode_clks rx_transfer_clk_pipe_g2
        dict set multiply_factor_dict rx_transfer_clk_pipe_g2 [dict get $multiply_factor_dict rx_transfer_clk]
        dict set divide_factor_dict   rx_transfer_clk_pipe_g2 [dict get $divide_factor_dict   rx_transfer_clk]

        # RX PIPE Gen1
        dict lappend profile_clocks rx_mode_clks rx_transfer_clk_pipe_g1
        dict set multiply_factor_dict rx_transfer_clk_pipe_g1 [dict get $multiply_factor_dict rx_transfer_clk_pipe_g2]
        dict set divide_factor_dict   rx_transfer_clk_pipe_g1 [expr round([dict get $divide_factor_dict rx_transfer_clk_pipe_g2] * 2)]

        # Remove original rx_transfer_clk from profile_clocks and freq dictionaries
        set list_of_rx_clkouts [dict get $profile_clocks rx_mode_clks]
        set rx_clkout_index [lsearch $list_of_rx_clkouts rx_transfer_clk]
        if {$rx_clkout_index < 0} {
          if {$native_debug == 1} {
            post_message -type warning "IP SDC: Cannot find key rx_transfer_clk while creating PIPE clocks in list $list_of_rx_clkouts"
          }
        } else {
          dict set profile_clocks rx_mode_clks [lreplace $list_of_rx_clkouts $rx_clkout_index $rx_clkout_index]
        }

        set multiply_factor_dict [dict remove $multiply_factor_dict rx_transfer_clk]
        set divide_factor_dict   [dict remove $divide_factor_dict   rx_transfer_clk]

      } else {
        # RX PIPE Gen2
        dict lappend profile_clocks rx_mode_clks rx_clkout_pipe_g2
        dict set multiply_factor_dict rx_clkout_pipe_g2 [dict get $multiply_factor_dict rx_clkout]
        dict set divide_factor_dict   rx_clkout_pipe_g2 [dict get $divide_factor_dict   rx_clkout]

        # RX PIPE Gen1
        dict lappend profile_clocks rx_mode_clks rx_clkout_pipe_g1
        dict set multiply_factor_dict rx_clkout_pipe_g1 [dict get $multiply_factor_dict rx_clkout_pipe_g2]
        dict set divide_factor_dict   rx_clkout_pipe_g1 [expr round([dict get $divide_factor_dict rx_clkout_pipe_g2] * 2)]

        # Remove original rx_clkout from profile_clocks and freq dictionaries
        set list_of_rx_clkouts [dict get $profile_clocks rx_mode_clks]
        set rx_clkout_index [lsearch $list_of_rx_clkouts rx_clkout]
        if {$rx_clkout_index < 0} {
          if {$native_debug == 1} {
            post_message -type warning "IP SDC: Cannot find key rx_clkout while creating PIPE clocks in list $list_of_rx_clkouts"
          }
        } else {
          dict set profile_clocks rx_mode_clks [lreplace $list_of_rx_clkouts $rx_clkout_index $rx_clkout_index]
        }
        #set freq [dict remove $freq rx_clkout]
        set multiply_factor_dict [dict remove $multiply_factor_dict rx_clkout]
        set divide_factor_dict   [dict remove $divide_factor_dict   rx_clkout]

      }

      # RX_CLKOUT2
      if {[dict get $native_phy_ip_params enable_port_rx_clkout2_profile$i] == 1} {
        if {[dict exists $profile_clocks rx_transfer_clk2]} {
          # RX PIPE Gen2
          dict lappend profile_clocks rx_mode_clks rx_transfer_clk2_pipe_g2
          dict set multiply_factor_dict rx_transfer_clk2_pipe_g2 [dict get $multiply_factor_dict rx_transfer_clk2]
          dict set divide_factor_dict   rx_transfer_clk2_pipe_g2 [dict get $divide_factor_dict   rx_transfer_clk2]

          # RX PIPE Gen1
          dict lappend profile_clocks rx_mode_clks rx_transfer_clk2_pipe_g1
          dict set multiply_factor_dict rx_transfer_clk2_pipe_g1 [dict get $multiply_factor_dict rx_transfer_clk2_pipe_g2]
          dict set divide_factor_dict   rx_transfer_clk2_pipe_g1 [expr round([dict get $divide_factor_dict rx_transfer_clk2_pipe_g2] * 2)]

          # Remove original rx_transfer_clk2 from profile_clocks and freq dictionaries
          set list_of_rx_clkouts [dict get $profile_clocks rx_mode_clks]
          set rx_clkout2_index [lsearch $list_of_rx_clkouts rx_transfer_clk2]
          if {$rx_clkout2_index < 0} {
            if {$native_debug == 1} {
              post_message -type warning "IP SDC: Cannot find key rx_transfer_clk2 while creating PIPE clocks in list $list_of_rx_clkouts"
            }
          } else {
            dict set profile_clocks rx_mode_clks [lreplace $list_of_rx_clkouts $rx_clkout_index $rx_clkout_index]
          }
          set multiply_factor_dict [dict remove $multiply_factor_dict rx_transfer_clk2]
          set divide_factor_dict   [dict remove $divide_factor_dict   rx_transfer_clk2]

        } else {
          # RX PIPE Gen2
          dict lappend profile_clocks rx_mode_clks rx_clkout2_pipe_g2
          dict set multiply_factor_dict rx_clkout2_pipe_g2 [dict get $multiply_factor_dict rx_clkout2]
          dict set divide_factor_dict   rx_clkout2_pipe_g2 [dict get $divide_factor_dict   rx_clkout2]

          # RX PIPE Gen1
          dict lappend profile_clocks rx_mode_clks rx_clkout2_pipe_g1
          dict set multiply_factor_dict rx_clkout2_pipe_g1 [dict get $multiply_factor_dict rx_clkout2_pipe_g2]
          dict set divide_factor_dict   rx_clkout2_pipe_g1 [expr round([dict get $divide_factor_dict rx_clkout2_pipe_g2] * 2)]

          # Remove original rx_clkout from profile_clocks and freq dictionaries
          set list_of_rx_clkouts [dict get $profile_clocks rx_mode_clks]
          set rx_clkout2_index [lsearch $list_of_rx_clkouts rx_clkout2]
          if {$rx_clkout2_index < 0} {
            if {$native_debug == 1} {
              post_message -type warning "IP SDC: Cannot find key rx_clkout2 while creating PIPE clocks in list $list_of_rx_clkouts"
            }
          } else {
            dict set profile_clocks rx_mode_clks [lreplace $list_of_rx_clkouts $rx_clkout2_index $rx_clkout2_index]
          }
          #set freq [dict remove $freq rx_clkout2]
          set multiply_factor_dict [dict remove $multiply_factor_dict rx_clkout2]
          set divide_factor_dict   [dict remove $divide_factor_dict   rx_clkout2]

        }
      }

      if {$native_debug == 1} {
        post_message -type info "IP SDC: RX mode clocks - [dict get $profile_clocks rx_mode_clks]"
      }

    } ; # if pipe_gen2 || pipe_gen3

    # -------------------------------------------------------------------------------
    # PIPE Gen3 clock
    # -------------------------------------------------------------------------------
    if {$protocol_mode == "pipe_g3"} {

      dict lappend profile_clocks tx_mode_clks tx_clkout_pipe_g3
      dict set multiply_factor_dict tx_clkout_pipe_g3 [expr round([dict get $multiply_factor_dict tx_clkout_pipe_g2] * 2)]
      dict set divide_factor_dict   tx_clkout_pipe_g3 [dict get $divide_factor_dict tx_clkout_pipe_g2]

      if {[dict get $native_phy_ip_params enable_port_tx_clkout2_profile$i] == 1} {
        dict lappend profile_clocks tx_mode_clks tx_clkout2_pipe_g3
        dict set multiply_factor_dict tx_clkout2_pipe_g3 [expr round([dict get $multiply_factor_dict tx_clkout2_pipe_g2] * 2)]
        dict set divide_factor_dict   tx_clkout2_pipe_g3 [dict get $divide_factor_dict tx_clkout2_pipe_g2]
      }

      if {[dict exists $profile_clocks rx_transfer_clk]} {
        dict lappend profile_clocks rx_mode_clks rx_transfer_clk_pipe_g3

      } else {
        dict lappend profile_clocks rx_mode_clks rx_clkout_pipe_g3
        dict set multiply_factor_dict rx_clkout_pipe_g3 [expr round([dict get $multiply_factor_dict rx_clkout_pipe_g2] * 2)]
        dict set divide_factor_dict   rx_clkout_pipe_g3 [dict get $divide_factor_dict rx_clkout_pipe_g2]
      }

      if {[dict get $native_phy_ip_params enable_port_rx_clkout2_profile$i] == 1} {
        if {[dict exists $profile_clocks rx_transfer_clk2]} {
          dict lappend profile_clocks rx_mode_clks rx_transfer_clk2_pipe_g3  
          dict set multiply_factor_dict rx_transfer_clk2_pipe_g3 [expr round([dict get $multiply_factor_dict rx_transfer_clk2_pipe_g2] * 2)]
          dict set divide_factor_dict   rx_transfer_clk2_pipe_g3 [dict get $divide_factor_dict rx_transfer_clk2_pipe_g2]

        } else {
          dict lappend profile_clocks rx_mode_clks rx_clkout2_pipe_g3
          dict set multiply_factor_dict rx_clkout2_pipe_g3 [expr round([dict get $multiply_factor_dict rx_clkout2_pipe_g2] * 2)]
          dict set divide_factor_dict   rx_clkout2_pipe_g3 [dict get $divide_factor_dict rx_clkout2_pipe_g2]

        }
      }
    }

    if { $native_debug == 1 } {
      dict for {key clocks} $profile_clocks {
        post_message -type info "IP SDC: Profile Clocks are $key: $clocks"
      }
    }

    # ----------------------------------------------------------------------------- #
    # --- Round the clock frequencies to 6 decimal places or less               --- #
    # ----------------------------------------------------------------------------- #
    dict for {clk freq_clk} $freq {
      dict set freq $clk [expr (round($freq_clk*1000000)/1000000.0)]
    }

    # ----------------------------------------------------------------------------- #
    # --- Create clocks for each mode                                           --- #
    # ----------------------------------------------------------------------------- #
    if {$native_debug == 1} {
      post_message -type info "========================================================================================"
      post_message -type info "IP SDC: Creating HSSI clocks for each channel"
    }

    dict for {mode mode_clks} $profile_clocks {
      set list_of_clk_names [list]

      if {$native_debug == 1} {
        post_message -type info "----------------------------------------------------------------------------------------"
        post_message -type info "IP SDC: Creating HSSI clocks for each channel in $mode group"
      }

      set list_of_clk_names [native_prepare_to_create_clocks_all_ch_ugm7okq $inst $num_channels $mode $mode_clks $profile_cnt $i $alt_xcvr_native_s10_pins $freq $multiply_factor_dict $divide_factor_dict $all_profile_clocks_names]
      dict set all_profile_clocks_names $i $mode [join [lsort -dictionary $list_of_clk_names]]

      if {$native_debug == 1} {
        post_message -type info "IP SDC: All Profile $i clocks for $mode: [dict get $all_profile_clocks_names $i $mode]"
      }
    } ; # dict for {mode mode_clks}


    # ----------------------------------------------------------------------------- #
    # --- Set async clock group for PIPE clocks                                 --- #
    # ----------------------------------------------------------------------------- #
    if {$protocol_mode == "pipe_g2" || $protocol_mode == "pipe_g3"} {
      if { $native_debug } {
        post_message -type info "========================================================================================"
        post_message -type info "IP SDC: Setting async clock groups for PIPE clocks"
      }

      set arg ""
      set curr_profile_clock_names [dict get $all_profile_clocks_names $i] 

      # Construct the arguments for set_clock_groups 
      # Template: set_clock_groups -asynchronous -group {<profile0 clks>} -group {<profile1 clks>} ... 
      for {set j 1} {$j < 3} {incr j} {
        set list_pipe_clk_names ""

        dict for {mode clk_mode_names} $curr_profile_clock_names {
          if {$mode == "tx_mode_clks" || $mode == "rx_mode_clks"} {

            set pipe_regexp "*_pipe_g$j*"
            set pipe_clk_names [lsearch -all -inline $clk_mode_names $pipe_regexp]

            if {$pipe_clk_names != ""} {
              set list_pipe_clk_names [concat $list_pipe_clk_names $pipe_clk_names]
            } else {
              if { $native_debug } {
                post_message -type warning "IP SDC: Cannot match regexp $pipe_regexp with clock names in list $clk_mode_names"
              }
            }
          }
        }
        set group "-group "
        set arg [concat $arg $group] 
        set arg [concat $arg "{$list_pipe_clk_names}"]
      }

      if {$protocol_mode == "pipe_g3"} {
        set list_pipe_clk_names ""

        dict for {mode clk_mode_names} $curr_profile_clock_names {
          if {$mode == "tx_mode_clks" || $mode == "rx_mode_clks"} {

            set pipe_regexp "*_pipe_g3*"
            set pipe_clk_names [lsearch -all -inline $clk_mode_names $pipe_regexp]

            if {$pipe_clk_names != ""} {
              set list_pipe_clk_names [concat $list_pipe_clk_names $pipe_clk_names]
            } else {
              if { $native_debug } {
                post_message -type warning "IP SDC: Cannot match regexp $pipe_regexp with clock names in list $clk_mode_names"
              }
            }
          }
        }
        set group "-group "
        set arg [concat $arg $group] 
        set arg [concat $arg "{$list_pipe_clk_names}"]
      }

      set cmd ""
      set cmd [concat $cmd "set_clock_groups -physically_exclusive "]
      set cmd [concat $cmd $arg]
      eval $cmd

      if { $native_debug } {
        post_message -type info "IP SDC: Setting async clock groups for PIPE clocks with command $cmd"
      }
    }

    #--------------------------------------------- #
    #---                                       --- #
    #--- MAX_SKEW_CONSTRAINT FOR BONDED MODE   --- #
    #---                                       --- #
    #--------------------------------------------- #
    if {[dict get $native_phy_ip_params bonded_mode_profile$i] == "pma_pcs"} {
      if { $native_debug } {
        post_message -type info "========================================================================================"
        post_message -type info "IP SDC: Setting max skew constraints for TX digital resets in PMA-PCS bonded mode"
      }

      # PMA and PCS resets need half the transfer clock period
      # Adapter resets need half the PMA parallel clock period
      set pma_parallel_clk_max_skew_value [expr ((1/($pma_parallel_clock / $byte_ser)) * 1000) / 2]
      set tx_transfer_clk_max_skew_value  [expr ((1/($tx_transfer_clk_freq / $byte_ser)) * 1000) / 2]
      set rx_transfer_clk_max_skew_value  [expr ((1/($rx_transfer_clk_freq / $byte_ser)) * 1000) / 2]

      # Round the clock frequencies to 6 decimal places or less
      set pma_parallel_clk_max_skew_value [expr (round($pma_parallel_clk_max_skew_value*1000)/1000.0)]
      set tx_transfer_clk_max_skew_value  [expr (round($tx_transfer_clk_max_skew_value*1000)/1000.0)]
      set rx_transfer_clk_max_skew_value  [expr (round($rx_transfer_clk_max_skew_value*1000)/1000.0)]

      # -------------------------------------------------------------------------------
      # TX set_max_skew
      # -------------------------------------------------------------------------------
      # Set max skew constraint for TX analog and digital resets when bonded
      set tx_analog_reset_reg_col         [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.tx_anlg_reset_seq|reset_out_stage*]
      set tx_aib_reset_out_stage_reg_col  [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.tx_dig_reset_seq|aib_reset_out_stage*]
      set tx_pcs_reset_out_stage_reg_col  [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.tx_dig_reset_seq|pcs_reset_out_stage*]
      set tx_transfer_clk_reg_col         [get_registers -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~*aibadpt__aib_fabric_tx_transfer_clk.reg]
      set tx_pld_adapter_tx_pld_rst_n_col [get_pins -nowarn -compat g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_adapter_tx_pld_rst_n]

      # TX PMA
      if {[get_collection_size $tx_analog_reset_reg_col] > 0 && [dict exist $all_profile_clocks_names $i tx_internal_div_reg_clks] && [get_collection_size $tx_transfer_clk_reg_col] > 0} {
        set_max_skew -exclude to_clock -from $tx_analog_reset_reg_col -to $tx_transfer_clk_reg_col $tx_transfer_clk_max_skew_value -nowarn
      }

      # TX Adapter
      if {[get_collection_size $tx_aib_reset_out_stage_reg_col] > 0 && [get_collection_size $tx_pld_adapter_tx_pld_rst_n_col] > 0} {
        set_max_skew -exclude to_clock -from $tx_aib_reset_out_stage_reg_col -to $tx_pld_adapter_tx_pld_rst_n_col $pma_parallel_clk_max_skew_value -nowarn
      }

      # TX PCS
      if {[get_collection_size $tx_pcs_reset_out_stage_reg_col] > 0 && [dict exist $all_profile_clocks_names $i tx_internal_div_reg_clks] && [get_collection_size $tx_transfer_clk_reg_col] > 0} {
        set_max_skew -exclude to_clock -from $tx_pcs_reset_out_stage_reg_col -to $tx_transfer_clk_reg_col $tx_transfer_clk_max_skew_value -nowarn
      }

      # -------------------------------------------------------------------------------
      # RX set_max_skew
      # -------------------------------------------------------------------------------
      # Set max skew constraint for RX analog and digital resets when bonded
      set rx_analog_reset_reg_col         [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.rx_anlg_reset_seq|reset_out_stage*]
      set rx_aib_reset_out_stage_reg_col  [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.rx_dig_reset_seq|aib_reset_out_stage*]
      set rx_pcs_reset_out_stage_reg_col  [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.rx_dig_reset_seq|pcs_reset_out_stage*]
      set rx_transfer_clk_reg_col         [get_registers -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx~*aibadpt__aib_fabric_rx_transfer_clk.reg]
      set rx_pld_adapter_rx_pld_rst_n_col [get_pins -nowarn -compat g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|pld_adapter_rx_pld_rst_n]

      # RX PMA
      if {[get_collection_size $rx_analog_reset_reg_col] > 0 && [dict exist $all_profile_clocks_names $i rx_internal_div_reg_clks] && [get_collection_size $rx_transfer_clk_reg_col] > 0} {
        set_max_skew -exclude to_clock -from $rx_analog_reset_reg_col -to $rx_transfer_clk_reg_col $rx_transfer_clk_max_skew_value -nowarn
      }

      # RX Adapter
      if {[get_collection_size $rx_aib_reset_out_stage_reg_col] > 0 && [get_collection_size $rx_pld_adapter_rx_pld_rst_n_col] > 0} {
        set_max_skew -exclude to_clock -from $rx_aib_reset_out_stage_reg_col -to $rx_pld_adapter_rx_pld_rst_n_col $pma_parallel_clk_max_skew_value -nowarn
      }

      # RX PCS
      if {[get_collection_size $rx_pcs_reset_out_stage_reg_col] > 0 && [dict exist $all_profile_clocks_names $i rx_internal_div_reg_clks] && [get_collection_size $rx_transfer_clk_reg_col] > 0} {
        set_max_skew -exclude to_clock -from $rx_pcs_reset_out_stage_reg_col -to $rx_transfer_clk_reg_col $rx_transfer_clk_max_skew_value -nowarn
      }

    }


    #-------------------------------------------------- #
    #---                                            --- #
    #--- DISABLE MIN_PULSE_WIDTH CHECK              --- #
    #---                                            --- #
    #-------------------------------------------------- #
    # Disable min_width_pulse for TX source clocks
    if {[dict exists $all_profile_clocks_names $i tx_source_clks]} {
      set tx_source_clks_list [dict get $all_profile_clocks_names $i tx_source_clks]
      foreach tx_src_clk $tx_source_clks_list {
        disable_min_pulse_width $tx_src_clk
      }
    }

    # Disable min_width_pulse for RX source clocks
    if {[dict exists $all_profile_clocks_names $i rx_source_clks]} {
      set rx_source_clks_list [dict get $all_profile_clocks_names $i rx_source_clks]
      foreach rx_src_clk $rx_source_clks_list {
        disable_min_pulse_width $rx_src_clk
      }
    }


    #-------------------------------------------------- #
    #---                                            --- #
    #--- CLOCK DISTORTION ALONG CLOCK PATH          --- #
    #---                                            --- #
    #-------------------------------------------------- #
  
    # (Cr IO Buffer+EMIB)(3%)+ Nadder IO Buffer)(3%) + (Nadder Adapter)(3%)
    # (Nadder Adapter)(3%) already distortion is accounted for in HSSI timing models
  
    # -------------------------------------------------------------------------------
    # TX clock uncertainty on output parallel XCVR clocks
    # -------------------------------------------------------------------------------
    if { [dict exists $all_profile_clocks_names $i tx_mode_clks] } {
      
      set tx_mode_clks_list [dict get $all_profile_clocks_names $i tx_mode_clks]
  
      foreach tx_clk_name $tx_mode_clks_list {
  
        set tx_clkout_period [get_clock_info -period $tx_clk_name]
  
        # (Cr IO Buffer+EMIB)(3%)+ Nadder IO Buffer)(3%)
        set tx_clkout_uncertainty_percent 0.06

        # Limit to 3 digits after the decimal to avoid warnings
        set tx_clkout_uncertainty_final_value [expr double($tx_clkout_uncertainty_percent*$tx_clkout_period)]
        set tx_clkout_uncertainty_final_value [expr round($tx_clkout_uncertainty_final_value  * 1000)]
        set tx_clkout_uncertainty_final_value [expr double($tx_clkout_uncertainty_final_value / 1000.0)]
  
        # (Cr IO Buffer+EMIB)(3%)+ Nadder IO Buffer)(3%) 
        # No need for rise_from/rise_to to other clocks since the rise edge should still be ideal, and it's only the fall edge that has uncertainty.
        # Distortion does not affect same-edge transfers. Only high-frequency jitter effects cause issues to same-edge transfers as common-clock-pessimism-removal would fix any issues.
        set tx_mode_other_clks     [remove_from_collection [get_clocks  $tx_mode_clks_list] [get_clocks $tx_clk_name]]
        if { [get_collection_size $tx_mode_other_clks] > 0} {
             set_clock_uncertainty -add -fall_from $tx_clk_name -to    $tx_mode_other_clks   $tx_clkout_uncertainty_final_value
             set_clock_uncertainty -add -fall_to   $tx_clk_name -from  $tx_mode_other_clks   $tx_clkout_uncertainty_final_value
        }
 
      }
    }
  
    # -------------------------------------------------------------------------------
    # RX clock uncertainty on output parallel XCVR clocks
    # -------------------------------------------------------------------------------
    if { [dict exists $all_profile_clocks_names $i rx_mode_clks] } {
      
      set rx_mode_clks_list [dict get $all_profile_clocks_names $i rx_mode_clks]

     # workaround when RX FIFO MODE is register and reconfig profile > 1 due to object not matched
     if  {[dict get $native_phy_ip_params rx_fifo_mode_profile$i] == "Register" && $rx_clkout_sel == "pcs_x2_clkout" && $profile_cnt > 1} {
        } else {
      foreach rx_clk_name $rx_mode_clks_list {
  
        set rx_clkout_period [get_clock_info -period $rx_clk_name]
  
        # (Cr IO Buffer+EMIB)(3%)+ Nadder IO Buffer)(3%)
        set rx_clkout_uncertainty_percent 0.06

        # Limit to 3 digits after the decimal to avoid warnings
        set rx_clkout_uncertainty_final_value [expr double($rx_clkout_uncertainty_percent*$rx_clkout_period)]
        set rx_clkout_uncertainty_final_value [expr round($rx_clkout_uncertainty_final_value  * 1000)]
        set rx_clkout_uncertainty_final_value [expr double($rx_clkout_uncertainty_final_value / 1000.0)]

        # Distortion from DCC circuit is only valid on opposite-edge transfers (i.e. rise-fall and fall-rise)
        set_clock_uncertainty -add -rise_from $rx_clk_name -fall_to $rx_clk_name $rx_clkout_uncertainty_final_value
        set_clock_uncertainty -add -fall_from $rx_clk_name -rise_to $rx_clk_name $rx_clkout_uncertainty_final_value
  
        # (Cr IO Buffer+EMIB)(3%)+ Nadder IO Buffer)(3%)
        # No need for rise_from/rise_to to other clocks since the rise edge should still be ideal, and it's only the fall edge that has uncertainty.
        # Distortion does not affect same-edge transfers. Only high-frequency jitter effects cause issues to same-edge transfers as common-clock-pessimism-removal would fix any issues. 
        set rx_mode_other_clks     [remove_from_collection [get_clocks  $rx_mode_clks_list] [get_clocks $rx_clk_name]]
        if { [get_collection_size $rx_mode_other_clks] > 0} {
             set_clock_uncertainty -add -fall_from $rx_clk_name -to    $rx_mode_other_clks   $rx_clkout_uncertainty_final_value
             set_clock_uncertainty -add -fall_to   $rx_clk_name -from  $rx_mode_other_clks   $rx_clkout_uncertainty_final_value
        }
       }
      }
    }


    #-------------------------------------------------- #
    #---                                            --- #
    #--- SET_FALSE_PATH for TX and RX BONDING       --- #
    #---                                            --- #
    #-------------------------------------------------- #

    # Remove all paths for RX bonding signals if in PIPE mode (Native PCIe IP covers the case for PCIe)
    if {$protocol_mode == "pipe_g1" || $protocol_mode == "pipe_g2" || $protocol_mode == "pipe_g3"} {

      set aib_fabric_rx_transfer_clk_col [get_registers    -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx~aib_fabric_rx_transfer_clk.reg]
      set bond_rx_fifo_us_out_wren_col   [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_us_out_wren]
      set bond_rx_fifo_ds_in_wren_col    [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_ds_in_wren]
      set bond_rx_fifo_ds_out_wren_col   [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_ds_out_wren]
      set bond_rx_fifo_us_in_wren_col    [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_us_in_wren]

      set pld_rx_clk_dcm_reg_col       [get_registers    -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx~pld_rx_clk*_dcm.reg]
      set bond_rx_fifo_us_out_rden_col [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_us_out_rden]
      set bond_rx_fifo_ds_in_rden_col  [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_ds_in_rden]
      set bond_rx_fifo_ds_out_rden_col [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_ds_out_rden]
      set bond_rx_fifo_us_in_rden_col  [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_us_in_rden]

      if {[get_collection_size $aib_fabric_rx_transfer_clk_col] > 0 &&  [get_collection_size $bond_rx_fifo_us_out_wren_col] > 0 && [get_collection_size $bond_rx_fifo_ds_in_wren_col] > 0} {    
        set_false_path -from $aib_fabric_rx_transfer_clk_col -through $bond_rx_fifo_us_out_wren_col -through $bond_rx_fifo_ds_in_wren_col -to $aib_fabric_rx_transfer_clk_col
      }

      if {[get_collection_size $aib_fabric_rx_transfer_clk_col] > 0 &&  [get_collection_size $bond_rx_fifo_ds_out_wren_col] > 0 && [get_collection_size $bond_rx_fifo_us_in_wren_col] > 0} {    
        set_false_path -from $aib_fabric_rx_transfer_clk_col -through $bond_rx_fifo_ds_out_wren_col -through $bond_rx_fifo_us_in_wren_col -to $aib_fabric_rx_transfer_clk_col
      }

      if {[get_collection_size $pld_rx_clk_dcm_reg_col] > 0 &&  [get_collection_size $bond_rx_fifo_us_out_rden_col] > 0 && [get_collection_size $bond_rx_fifo_ds_in_rden_col] > 0} {    
        set_false_path -from $pld_rx_clk_dcm_reg_col  -through $bond_rx_fifo_us_out_rden_col -through $bond_rx_fifo_ds_in_rden_col -to $pld_rx_clk_dcm_reg_col
      }

      if {[get_collection_size $pld_rx_clk_dcm_reg_col] > 0 &&  [get_collection_size $bond_rx_fifo_ds_out_rden_col] > 0 && [get_collection_size $bond_rx_fifo_us_in_rden_col] > 0} {    
        set_false_path -from  $pld_rx_clk_dcm_reg_col -through $bond_rx_fifo_ds_out_rden_col -through $bond_rx_fifo_us_in_rden_col -to $pld_rx_clk_dcm_reg_col
      }

    }

  } ; # foreach profile


  #--------------------------------------------- #
  #---                                       --- #
  #--- Adjusting the min pulse width for     --- #
  #--- coreclkin2 requirement to be          --- #
  #--- frequency-dependent                   --- #
  #---                                       --- #
  #--------------------------------------------- #
  
  # Create dictionary of all the clocks and their nodes
  set min_pulse_all_clocks_list [all_clocks]
  set min_pulse_all_clocks_nodes_dict [dict create]
  
  foreach_in_collection clk $min_pulse_all_clocks_list {
    set clk_name [get_clock_info -name $clk]
    # Check if clock is declared, but NOT defined (i.e. create_clock or create_generated_clock has NOT been used yet)
    if { [is_clock_defined $clk_name] == 1 } {
      set clk_node_col [get_clock_info -targets $clk_name]
	
      foreach_in_collection clk_node $clk_node_col {
        set clk_node_name [get_node_info -name $clk_node]
        dict set min_pulse_all_clocks_nodes_dict $clk_node_name $clk_name
      }
    }
  }
   
  # -------------------------------------------------------------------------------
  # TX coreclkin2
  # -------------------------------------------------------------------------------
  set tx_coreclkin2_col [get_pins -nowarn -compat g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_tx_clk2_dcm]

  # Get fanins for tx_coreclkin2
  if {[get_collection_size $tx_coreclkin2_col] > 0} {
    set tx_coreclkin_fanin_col [get_fanins -clock -stop_at_clocks $tx_coreclkin2_col]
	
    # Find clock name on the fanin
    if {[get_collection_size $tx_coreclkin_fanin_col]} {
	
      foreach_in_collection fanin_node $tx_coreclkin_fanin_col {
        set fanin_node_name [get_node_info -name $fanin_node]

	      if {[dict exists $min_pulse_all_clocks_nodes_dict $fanin_node_name]} {
		      set fanin_clock_name [dict get $min_pulse_all_clocks_nodes_dict $fanin_node_name]
         set_active_clocks [remove_from_collection [get_active_clocks] [get_clocks $fanin_clock_name]]
          
          # Remap any backward slashes '' in the pins
          set fanin_clock_name [string map {\\ \\\\} $fanin_clock_name]

          # Adjust the min pulse width requirement based on frequency
          add_ddr_report_command "native_check_special_min_pulse_ugm7okq $fanin_clock_name"
        } elseif {[regexp {aib_tx_internal_div\.reg$} $fanin_node_name]} {
              post_message -type warning "can't find clock expected to feed transceiver. Please ensure the .ip of providing clock to transceiver is listed in the QSF or QIP before the .ip of the transceiver."   
        }
      }
    }
  }


  # -------------------------------------------------------------------------------
  # RX coreclkin2
  # -------------------------------------------------------------------------------
  set rx_coreclkin2_col [get_pins -nowarn -compat g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|pld_rx_clk2_dcm]

  # Get fanins for rx_coreclkin2
  if {[get_collection_size $rx_coreclkin2_col] > 0} {
    set rx_coreclkin_fanin_col [get_fanins -clock -stop_at_clocks $rx_coreclkin2_col]
	
    # Find clock name on the fanin
    if {[get_collection_size $rx_coreclkin_fanin_col]} {
	
      foreach_in_collection fanin_node $rx_coreclkin_fanin_col {
        set fanin_node_name [get_node_info -name $fanin_node]

	      if {[dict exists $min_pulse_all_clocks_nodes_dict $fanin_node_name]} {
		      set fanin_clock_name [dict get $min_pulse_all_clocks_nodes_dict $fanin_node_name]
          set_active_clocks [remove_from_collection [get_active_clocks] [get_clocks $fanin_clock_name]]
         
          # Remap any backward slashes '' in the pins
          set fanin_clock_name [string map {\\ \\\\} $fanin_clock_name]

          # Adjust the min pulse width requirement based on frequency
          add_ddr_report_command "native_check_special_min_pulse_ugm7okq $fanin_clock_name"
        } elseif {[regexp {aib_rx_internal_div\.reg$} $fanin_node_name]} {
              post_message -type warning "can't find clock expected to feed transceiver. Please ensure the .ip of providing clock to transceiver is listed in the QSF or QIP before the .ip of the transceiver."   
        }
      }
    }
  }


  #--------------------------------------------- #
  #---                                       --- #
  #--- ASYNC CLOCK GROUP FOR RECONFIGURATION --- #
  #---                                       --- #
  #--------------------------------------------- #
  if {$profile_cnt > 1 } {
    if { $native_debug == 1 } {
      post_message -type info "========================================================================================"
      post_message -type info "IP SDC: Setting async clock groups for multi-profile"
    }

    set arg ""

    for {set i 0} {$i < $profile_cnt} {incr i} {
      set profile_clk_names ""

      dict for {mode clk_name} $profile_clocks {
        # Construct the arguments for set_clock_groups 
        # Template: set_clock_groups -asynchronous -group {<profile0 clks>} -group {<profile1 clks>} ...
        if {[dict exists $all_profile_clocks_names $i $mode]} {
          set profile_clk_names [concat $profile_clk_names [dict get $all_profile_clocks_names $i $mode]]
        }
      }

      set profile_clk_names [join $profile_clk_names]
      set group "-group "
      set arg [concat $arg $group] 
      set arg [concat $arg "{$profile_clk_names}"]

      if { $native_debug } {
        post_message -type info "IP SDC: Profile $i clocks: $profile_clk_names"
      }
    }

    set cmd ""
    set cmd [concat $cmd "set_clock_groups -physically_exclusive "]
    set cmd [concat $cmd $arg]
    eval $cmd

    if { $native_debug } {
      post_message -type info "IP SDC: Setting async clock groups for reconfiguration: $cmd"
    }

  }


  #-------------------------------------------------- #
  #---                                            --- #
  #--- Internal loopback path                     --- #
  #---                                            --- #
  #-------------------------------------------------- #
  set aib_fabric_pma_aib_tx_clk_col  [get_registers -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~aib_fabric_pma_aib_tx_clk.reg]
  set aib_fabric_tx_data_lpbk_col    [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|aib_fabric_tx_data_lpbk*]
  set aib_fabric_rx_transfer_clk_col [get_registers -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx~aib_fabric_rx_transfer_clk.reg]
  set pld_tx_clk2_dcm_reg_col        [get_registers -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~pld_tx_clk2_dcm.reg]
  set pld_tx_clk1_dcm_reg_col        [get_registers -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~pld_tx_clk1_dcm.reg]

  # Cut the paths for the internal loopback paths
  if {[get_collection_size $aib_fabric_pma_aib_tx_clk_col] > 0 && [get_collection_size $aib_fabric_tx_data_lpbk_col] > 0 && [get_collection_size $aib_fabric_rx_transfer_clk_col] > 0} {
    set_false_path -from $aib_fabric_pma_aib_tx_clk_col -through $aib_fabric_tx_data_lpbk_col -to $aib_fabric_rx_transfer_clk_col
  }

  # Cut paths for internal loopback paths when bonding is enabled
  if {[get_collection_size $pld_tx_clk2_dcm_reg_col] > 0 && [get_collection_size $aib_fabric_tx_data_lpbk_col] > 0 && [get_collection_size $aib_fabric_rx_transfer_clk_col] > 0} {
    set_false_path -from $pld_tx_clk2_dcm_reg_col -through $aib_fabric_tx_data_lpbk_col -to $aib_fabric_rx_transfer_clk_col
  }
  if {[get_collection_size $pld_tx_clk1_dcm_reg_col] > 0 && [get_collection_size $aib_fabric_tx_data_lpbk_col] > 0 && [get_collection_size $aib_fabric_rx_transfer_clk_col] > 0} {
    set_false_path -from $pld_tx_clk1_dcm_reg_col -through $aib_fabric_tx_data_lpbk_col -to $aib_fabric_rx_transfer_clk_col
  }


    # -------------------------------------------------------------------------------------------------- #
    # --- set false path for adjacent channel connections introduced by clock skew control modeling  --- #
    # -------------------------------------------------------------------------------------------------- #
    if { $tx_enabled_on_any_profile && $max_num_channels > 1 } {
        set aib_pld_tx_clk_pin_col [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_tx_clk?_dcm] 
        set aib_pld_tx_clk_pin_col  [add_to_collection $aib_pld_tx_clk_pin_col [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_tx_clk?_rowclk] ]
        set aib_tx_internal_div_reg_col [get_registers -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~aib_tx_internal_div.reg]
        set aib_fabric_transfer_clk_col [get_registers -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~*aib_fabric_tx_transfer_clk.reg]
        if { [get_collection_size $aib_fabric_transfer_clk_col] > 0 } {
          if { [get_collection_size $aib_tx_internal_div_reg_col] > 0 } {
             set_false_path -from $aib_tx_internal_div_reg_col -to $aib_fabric_transfer_clk_col 
          }
          if { [get_collection_size $aib_pld_tx_clk_pin_col] > 0 } {
            set_false_path -through $aib_pld_tx_clk_pin_col -to $aib_fabric_transfer_clk_col
          }
        }
    } ; # tx_enabled_on_any_profile && max_num_channels > 1 
      


  #--------------------------------------------- #
  #---                                       --- #
  #--- SET_FALSE_PATH to reset synchronizers --- #
  #---                                       --- #
  #--------------------------------------------- #
  
  # TX and RX analog reset synchronizers
  set tx_analog_reset_resync_reg [get_keepers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.tx_anlg_reset_seq|g_anlg_trs_inst[*].reset_synchronizers|resync_chains[0].synchronizer_nocut|din_s1]                                                                                                      
  set tx_analog_reset_resync_reg [add_to_collection $tx_analog_reset_resync_reg [get_keepers -nowarn  g_ehip_reset.alt_xcvr_native_anlg_reset_seq_wrapper_inst|g_trs.tx_anlg_reset_seq|g_anlg_trs_inst[*].reset_synchronizers|resync_chains[0].synchronizer_nocut|din_s1] ]

  set rx_analog_reset_resync_reg [get_keepers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.rx_anlg_reset_seq|g_anlg_trs_inst[*].reset_synchronizers|resync_chains[0].synchronizer_nocut|din_s1]
  set rx_analog_reset_resync_reg [add_to_collection $rx_analog_reset_resync_reg [get_keepers -nowarn  g_ehip_reset.alt_xcvr_native_anlg_reset_seq_wrapper_inst|g_trs.rx_anlg_reset_seq|g_anlg_trs_inst[*].reset_synchronizers|resync_chains[0].synchronizer_nocut|din_s1] ]

  # TX and RX digital reset synchronizers
  set tx_digital_reset_resync_reg             [get_keepers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.tx_dig_reset_seq|reset_synchronizers|resync_chains[*].synchronizer_nocut|din_s1]
  set tx_digital_transfer_ready_resync_reg    [get_keepers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.tx_dig_reset_seq|transfer_ready_synchronizers|resync_chains[*].synchronizer_nocut|din_s1]
  set tx_digital_release_aib_first_resync_reg [get_keepers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.tx_dig_reset_seq|release_aib_first_synchronizers|resync_chains[0].synchronizer_nocut|din_s1]
  set rx_digital_reset_resync_reg             [get_keepers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.rx_dig_reset_seq|reset_synchronizers|resync_chains[*].synchronizer_nocut|din_s1]
  set rx_digital_transfer_ready_resync_reg    [get_keepers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.rx_dig_reset_seq|transfer_ready_synchronizers|resync_chains[*].synchronizer_nocut|din_s1]
  set rx_digital_release_aib_first_resync_reg [get_keepers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.rx_dig_reset_seq|release_aib_first_synchronizers|resync_chains[0].synchronizer_nocut|din_s1]
    
  # TX reset synchronizers
  if {[dict get $native_phy_ip_params tx_enable_profile0]} {

    # TX analog resets
    if {[get_collection_size $tx_analog_reset_resync_reg] > 0} {
      foreach_in_collection resync_reg $tx_analog_reset_resync_reg {
        set_false_path -to $resync_reg
      }
    }

    # TX digital resets
    if {[get_collection_size $tx_digital_reset_resync_reg] > 0} {
      foreach_in_collection resync_reg $tx_digital_reset_resync_reg {
        set_false_path -to $resync_reg
      }
    }

    if {[get_collection_size $tx_digital_transfer_ready_resync_reg] > 0} {
      foreach_in_collection resync_reg $tx_digital_transfer_ready_resync_reg {
        set_false_path -to $resync_reg
      }
    }

    if {[get_collection_size $tx_digital_release_aib_first_resync_reg] > 0} {
      foreach_in_collection resync_reg $tx_digital_release_aib_first_resync_reg {
        set_false_path -to $resync_reg
      }
    }
  }

  # RX reset synchronizers
  if {[dict get $native_phy_ip_params rx_enable_profile0]} {

    # RX analog resets
     if {[get_collection_size $rx_analog_reset_resync_reg] > 0} {
      foreach_in_collection resync_reg $rx_analog_reset_resync_reg {
        set_false_path -to $resync_reg
      }
    }

    # RX digital resets
    if {[get_collection_size $rx_digital_reset_resync_reg] > 0} {
      foreach_in_collection resync_reg $rx_digital_reset_resync_reg {
        set_false_path -to $resync_reg
      }
    }

    if {[get_collection_size $rx_digital_transfer_ready_resync_reg] > 0} {
      foreach_in_collection resync_reg $rx_digital_transfer_ready_resync_reg {
        set_false_path -to $resync_reg
      }
    }

    if {[get_collection_size $rx_digital_release_aib_first_resync_reg] > 0} {
      foreach_in_collection resync_reg $rx_digital_release_aib_first_resync_reg {
        set_false_path -to $resync_reg
      }
    }
  }


  # Early speed change reset synchronizers
  set early_spd_chng_reset_resync_reg [get_keepers -nowarn g_early_spd_chng_enable.pipe_early_spd_chng_inst|reset_n_synchronizers|resync_chains[0].synchronizer_nocut|din_s1]
  set early_spd_chng_reset_resync_reg [add_to_collection $early_spd_chng_reset_resync_reg [get_keepers -nowarn  g_early_spd_chng_enable.pipe_early_spd_chng_inst|reset_n_synchronizers|resync_chains[0].synchronizer_nocut|dreg*]]

  if {[get_collection_size $early_spd_chng_reset_resync_reg] > 0} {
    foreach_in_collection resync_reg $early_spd_chng_reset_resync_reg {
      set_false_path -to $resync_reg
    }
  }


  #  RX MAIB FIFO workaround in clk_comp mode for 10GBASER, reset synchronizers
  set rx_maib_wa_reset_resync_reg [get_keepers -nowarn xcvr_rx_maib_wa|g_chk_swap.rst_sync[*].reset_synchronizers|resync_chains[*].synchronizer_nocut|din_s1]
  if {[get_collection_size $rx_maib_wa_reset_resync_reg] > 0} {
      set_false_path -to $rx_maib_wa_reset_resync_reg
  }

  set rx_maib_wa_reset_resync_dreg [get_keepers -nowarn  xcvr_rx_maib_wa|g_chk_swap.rst_sync[*].reset_synchronizers|resync_chains[*].synchronizer_nocut|dreg*]
  set rx_maib_wa_reset_resync_clr_pins [get_pins -nowarn  xcvr_rx_maib_wa|g_chk_swap.rst_sync[*].reset_synchronizers|resync_chains[*].synchronizer_nocut|dreg*|clrn]
  if {[get_collection_size $rx_maib_wa_reset_resync_dreg] > 0} {
     set_false_path -through $rx_maib_wa_reset_resync_clr_pins -to $rx_maib_wa_reset_resync_dreg
  }


  #--------------------------------------------- #
  #---                                       --- #
  #--- MIN & MAX DELAYS FOR RESETS           --- #
  #---                                       --- #
  #--------------------------------------------- #

  if {[dict get $native_phy_ip_params tx_enable_profile0]} {

    # TX PMA resets
    set tx_analog_reset_reg  [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.tx_anlg_reset_seq|reset_out_stage*]
    set tx_pld_pma_reset_pin [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_pma_txpma_rstb]
    
    if {[get_collection_size $tx_analog_reset_reg] == 0} {
      if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find registers for TX analog resets"
      }

    } elseif {[get_collection_size $tx_pld_pma_reset_pin] == 0} {
      if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find TX PMA reset atom"
      }

    } else {
      set_max_delay -from $tx_analog_reset_reg -through $tx_pld_pma_reset_pin  200
      set_min_delay -from $tx_analog_reset_reg -through $tx_pld_pma_reset_pin -200
    }

    # TX PCS resets
    set tx_digital_pcs_reset_reg [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.tx_dig_reset_seq|pcs_reset_out_stage*]
    set tx_pld_pcs_reset_pin     [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_pcs_tx_pld_rst_n]

    if {[get_collection_size $tx_digital_pcs_reset_reg] == 0} {
       if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find TX digital PCS resets"
      }

    } elseif {[get_collection_size $tx_pld_pcs_reset_pin] == 0} {
       if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find TX PCS reset atom"
      }

    } else {
      set_max_delay -from $tx_digital_pcs_reset_reg -through $tx_pld_pcs_reset_pin  200
      set_min_delay -from $tx_digital_pcs_reset_reg -through $tx_pld_pcs_reset_pin -200
    }

    # TX AIB/adapter resets
    set tx_digital_aib_reset_reg [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.tx_dig_reset_seq|aib_reset_out_stage*]
    set tx_pld_adapter_reset_pin [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_adapter_tx_pld_rst_n]

    if {[get_collection_size $tx_digital_aib_reset_reg] == 0} {
       if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find TX digital AIB/adapter resets"
      }

    } elseif {[get_collection_size $tx_pld_adapter_reset_pin] == 0} {
      if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find TX AIB/adapter reset atom"
      }

    } else {
      set_max_delay -from $tx_digital_aib_reset_reg -through $tx_pld_adapter_reset_pin  200
      set_min_delay -from $tx_digital_aib_reset_reg -through $tx_pld_adapter_reset_pin -200
    }
  }

  if {[dict get $native_phy_ip_params rx_enable_profile0]} {

    # RX PMA resets
    set rx_analog_reset_reg  [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.rx_anlg_reset_seq|reset_out_stage*]
    set rx_pld_pma_reset_pin [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|pld_pma_rxpma_rstb]
    
    if {[get_collection_size $rx_analog_reset_reg] == 0} {
      if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find registers for RX analog resets"
      }

    } elseif {[get_collection_size $rx_pld_pma_reset_pin] == 0} {
      if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find RX PMA reset atom"
      }

    } else {
      set_max_delay -from $rx_analog_reset_reg -through $rx_pld_pma_reset_pin  200
      set_min_delay -from $rx_analog_reset_reg -through $rx_pld_pma_reset_pin -200
    }

    # RX PCS resets
    set rx_digital_pcs_reset_reg [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.rx_dig_reset_seq|pcs_reset_out_stage*]
    set rx_pld_pcs_reset_pin     [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|pld_pcs_rx_pld_rst_n]
    
    if {[get_collection_size $rx_digital_pcs_reset_reg] == 0} {
       if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find RX digital PCS resets"
      }

    } elseif {[get_collection_size $rx_pld_pcs_reset_pin] == 0} {
       if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find RX PCS reset atom"
      }

    } else {
      set_max_delay -from $rx_digital_pcs_reset_reg -through $rx_pld_pcs_reset_pin  200
      set_min_delay -from $rx_digital_pcs_reset_reg -through $rx_pld_pcs_reset_pin -200
    }

    # RX AIB/adapter resets
    set rx_digital_aib_reset_reg [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.rx_dig_reset_seq|aib_reset_out_stage*]
    set rx_pld_adapter_reset_pin [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|pld_adapter_rx_pld_rst_n]

    if {[get_collection_size $rx_digital_aib_reset_reg] == 0} {
       if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find RX digital AIB/adapter resets"
      }

    } elseif {[get_collection_size $rx_pld_adapter_reset_pin] == 0} {
      if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find RX AIB/adapter reset atom"
      }

    } else {
      set_max_delay -from $rx_digital_aib_reset_reg -through $rx_pld_adapter_reset_pin  200
      set_min_delay -from $rx_digital_aib_reset_reg -through $rx_pld_adapter_reset_pin -200
    }
  }

  #--------------------------------------------- #
  #---                                       --- #
  #--- PRBS constraints                      --- #
  #---                                       --- #
  #--------------------------------------------- # 
  # Check that reconfiguration is enabled and soft logic for doing prbs bit and error accumulation when using the hard prbs generator and checker is enabled
  if {[dict get $native_phy_ip_params rcfg_enable_profile0] && [dict get $native_phy_ip_params set_prbs_soft_logic_enable_profile0]} {

    set prbs_path  "g_recal_*_rcfg_opt_logic.alt_xcvr_native_optional_rcfg_logic|g_optional_chnl_reconfig_logic[*].g_prbs_accumulators_enable.prbs_soft_accumulators"

    set prbs_soft_accumulators_rx_prbs_err_snapshot_col [get_registers -nowarn $prbs_path|rx_prbs_err_snapshot*]

    if { [get_collection_size $prbs_soft_accumulators_rx_prbs_err_snapshot_col] > 0 } {
      
      # When using the PRBS Error Accumulation logic, set multicycle constraints to reduce routing effor and congestion.
      set prbs_soft_accumulators_avmm_prbs_err_count_col [get_registers -nowarn $prbs_path|avmm_prbs_err_count*]
      set_max_delay -from $prbs_soft_accumulators_rx_prbs_err_snapshot_col -to $prbs_soft_accumulators_avmm_prbs_err_count_col 200
      set_min_delay -from $prbs_soft_accumulators_rx_prbs_err_snapshot_col -to $prbs_soft_accumulators_avmm_prbs_err_count_col -200
  
      # Set false paths for the asynchronous resets no-cut synchronizers
      set_false_path -through [get_pins -nowarn -compat  $prbs_path|rx_clk_reset_sync|resync_chains[0].synchronizer_nocut|din_s1|clrn] -to [get_registers -nowarn $prbs_path|rx_clk_reset_sync|resync_chains[0].synchronizer_nocut|din_s1]
      set_false_path -through [get_pins -nowarn -compat  $prbs_path|rx_clk_reset_sync|resync_chains[0].synchronizer_nocut|dreg*|clrn]  -to [get_registers -nowarn $prbs_path|rx_clk_reset_sync|resync_chains[0].synchronizer_nocut|dreg[?]]
                                                                          
      set embedded_debug_soft_csr_col [get_registers -nowarn g_recal_*_rcfg_opt_logic.alt_xcvr_native_optional_rcfg_logic|g_optional_chnl_reconfig_logic[*].g_avmm_csr_enabled.embedded_debug_soft_csr|g_prbs_reg_en*]
      set_false_path -from $embedded_debug_soft_csr_col -to [get_registers -nowarn $prbs_path|rx_clk_prbs_reset_sync|resync_chains[0].synchronizer_nocut|din_s1]
      set_false_path -from $embedded_debug_soft_csr_col -to [get_registers -nowarn $prbs_path|rx_clk_prbs_reset_sync|resync_chains[0].synchronizer_nocut|dreg[?]]

      set_false_path -through [get_pins -nowarn -compat $prbs_path|rx_clk_prbs_err_sync|resync_chains[0].synchronizer_nocut|din_s1|clrn] -to [get_registers -nowarn $prbs_path|rx_clk_prbs_err_sync|resync_chains[0].synchronizer_nocut|din_s1]
      set_false_path -through [get_pins -nowarn -compat $prbs_path|rx_clk_prbs_err_sync|resync_chains[0].synchronizer_nocut|dreg*|clrn] -to  [get_registers -nowarn $prbs_path|rx_clk_prbs_err_sync|resync_chains[0].synchronizer_nocut|dreg[?]]
      
      set_false_path -through [get_pins -nowarn -compat $prbs_path|rx_clk_prbs_done_sync|resync_chains[0].synchronizer_nocut|din_s1|clrn] -to [get_registers -nowarn $prbs_path|rx_clk_prbs_done_sync|resync_chains[0].synchronizer_nocut|din_s1]
      set_false_path -through [get_pins -nowarn -compat $prbs_path|rx_clk_prbs_done_sync|resync_chains[0].synchronizer_nocut|dreg*|clrn]  -to [get_registers -nowarn $prbs_path|rx_clk_prbs_done_sync|resync_chains[0].synchronizer_nocut|dreg[?]]
            
      # Set false paths for data no-cut synchronizers
      set_false_path -to [get_registers -nowarn $prbs_path|avmm_clk_prbs_done_sync|resync_chains[0].synchronizer_nocut|din_s1]
      set_false_path -to [get_registers -nowarn $prbs_path|avmm_clk_bit_count_edge|resync_chains[0].synchronizer_nocut|din_s1]

    } else {
      if {$native_debug == 1} {
        post_message -type warning "IP SDC: Reconfiguration and PRBS soft accumulators are enabled, but IP SDC is unable to find any matching registers for PRBS soft accumulators"
      }
    }
  }

  #--------------------------------------------- #
  #---                                       --- #
  #--- RX EIOS Protection  Constraints       --- #
  #---                                       --- #
  #--------------------------------------------- # 
  set eios_path  "g_recal_disable_rcfg_opt_logic.alt_xcvr_native_optional_rcfg_logic|g_eios_rp_enable.pcie_rx_eios_prot_inst"
  set eios_sync_din_col [get_registers -nowarn $eios_path|*_sync|din_s1]
  # Check if there are resync registers for EIOS
  if { [get_collection_size $eios_sync_din_col] > 0 } {
       # Set false paths for data no-cut synchronizers
       set_false_path -to $eios_sync_din_col    
  
    set eios_sync_nreset_col [get_registers -nowarn $eios_path|u_sync_nreset|din_s1]
    if { [get_collection_size $eios_sync_nreset_col] > 0 } {
      # Set false paths for the asynchronous resets no-cut synchronizers
      set_false_path -through [get_pins -nowarn -compat $eios_path|u_sync_nreset|din_s1|clrn] -to $eios_sync_nreset_col
      set_false_path -through [get_pins -nowarn -compat $eios_path|u_sync_nreset|dreg[?]|clrn] -to [get_registers -nowarn $eios_path|u_sync_nreset|dreg[?]]
    }                                                                        
  }


  #-------------------------------------------------- #
  #---                                            --- #
  #--- AVMM wrapper constraints                   --- #
  #---                                            --- #
  #-------------------------------------------------- #
  # Check that reconfiguration is enabled
  if {[dict get $native_phy_ip_params rcfg_enable_profile0]} {

    set ct2_xcvr_avmm_reset_clrn_col [get_pins -nowarn -compat g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct1_xcvr_avmm1|avmm_if_soft_logic[*].ct1_xcvr_avmm_soft_logic_inst|sync_r[?]|clrn]

    if { [get_collection_size $ct2_xcvr_avmm_reset_clrn_col] > 0 } {
      # Set false path to avmm_reset synchronizer
      set ct2_xcvr_avmm_reset_sync_reg_col [get_registers -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct1_xcvr_avmm1|avmm_if_soft_logic[*].ct1_xcvr_avmm_soft_logic_inst|sync_r[?]]
      set_false_path -through $ct2_xcvr_avmm_reset_clrn_col -to $ct2_xcvr_avmm_reset_sync_reg_col
    } else {
      if {$native_debug == 1} {
        post_message -type warning "IP SDC: Reconfiguration is enabled, but IP SDC is unable to find any matching nodes for AVMM soft logic"
      }

    }
  }

  #-------------------------------------------------- #
  #---                                            --- #
  #--- SET_FALSE_PATH for MAIB ASYNC signals      --- #
  #---                                            --- #
  #-------------------------------------------------- #
  # Create a set of all asynchronous signals to be looped over for setting false paths
  # These signals are async input signals to Nadder Adapter
  set altera_xcvr_native_s10_async_signals {
    pld_pma_fpll_up_dn_lc_lf_rstn
    pld_pma_txdetectrx
    pld_ltr
    pld_pma_ltd_b
    pld_txelecidle
    pld_10g_krfec_rx_clr_errblk_cnt
    pld_10g_rx_clr_ber_count
    pld_10g_tx_bitslip
    pld_10g_tx_diag_status
    pld_8g_a1a2_size
    pld_8g_bitloc_rev_en
    pld_8g_byte_rev_en
    pld_8g_encdt
    pld_8g_tx_boundary_sel
    pld_bitslip
    pld_pma_adapt_start
    pld_pma_early_eios
    pld_pma_eye_monitor
    pld_pma_pcie_switch
    pld_pma_rs_lpbk_b
    pld_pmaif_rxclkslip
    pld_pma_tx_qpi_pulldn
    pld_pma_tx_qpi_pullup
    pld_pma_rx_qpi_pullup
    pld_polinv_rx
    pld_polinv_tx
    pld_syncsm_en
    pld_rx_prbs_err_clr
    pld_10g_tx_wordslip
    pld_pma_tx_bitslip
    pld_8g_eidleinfersel
    pld_tx_fifo_latency_adj_en
    pld_rx_fifo_latency_adj_en
  }

  if { [ info exists altera_xcvr_native_s10_async_xcvr_pins ] } {
    unset altera_xcvr_native_s10_async_xcvr_pins
  }

  # Set false paths for each item in the set
  foreach altera_xcvr_native_s10_async_signal_name $altera_xcvr_native_s10_async_signals {
    set altera_xcvr_native_s10_async_xcvr_pins [get_pins -nowarn -compatibility_mode g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_?x.inst_ct1_hssi_pldadapt_?x|${altera_xcvr_native_s10_async_signal_name}*]
    if { [get_collection_size $altera_xcvr_native_s10_async_xcvr_pins] > 0 } {
      set_false_path -to $altera_xcvr_native_s10_async_xcvr_pins
    }
  }


  #-------------------------------------------------- #
  #---                                            --- #
  #--- TX BURST ENABLE MIN/MAX CONSTRAINTS        --- #
  #---                                            --- #
  #-------------------------------------------------- #
  # For TX burst enable, even though its an asynchronous signal, set a bound, since we need the fitter to place it some-what close to the periphery for interlaken
  set altera_xcvr_native_s10_async_tx_burst_en_pins [get_pins -nowarn -compatibility_mode g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_10g_tx_burst_en*]
  if { [get_collection_size $altera_xcvr_native_s10_async_tx_burst_en_pins] > 0 } {
    set_max_delay -to $altera_xcvr_native_s10_async_tx_burst_en_pins 200ns
    set_min_delay -to $altera_xcvr_native_s10_async_tx_burst_en_pins -200ns
  }
  
    # alt_xcvr_resync_reset
  set aib_reset_out_stage_to_clrn [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.rx_dig_reset_seq|aib_reset_out_stage[*]]
  
  set dreg_clrn_to_alt_xcvr_sync_aibreset [get_pins -nowarn -compat g_lf_conditions[*].g_enforce_local_fault.transfer_ready_synchronizers|resync_chains[*].synchronizer_nocut|dreg[*]|clrn]
  set alt_xcvr_sync_aibreset_to_rx_parallel_data [get_registers -nowarn g_lf_conditions[*].g_enforce_local_fault.transfer_ready_synchronizers|resync_chains[*].synchronizer_nocut|dreg[*]]
  if {[get_collection_size $aib_reset_out_stage_to_clrn] > 0 && [get_collection_size $dreg_clrn_to_alt_xcvr_sync_aibreset] > 0 && [get_collection_size $alt_xcvr_sync_aibreset_to_rx_parallel_data] > 0} {
    set_false_path -from $aib_reset_out_stage_to_clrn -through $dreg_clrn_to_alt_xcvr_sync_aibreset -to $alt_xcvr_sync_aibreset_to_rx_parallel_data
  }
  
  set s1_clrn_to_alt_xcvr_sync_aibreset [get_pins -nowarn -compat g_lf_conditions[*].g_enforce_local_fault.transfer_ready_synchronizers|resync_chains[0].synchronizer_nocut|din_s1|clrn]
  set alt_xcvr_sync_din_to_rx_parallel_data [get_registers -nowarn g_lf_conditions[*].g_enforce_local_fault.transfer_ready_synchronizers|resync_chains[*].synchronizer_nocut|din_s1]
  if {[get_collection_size $aib_reset_out_stage_to_clrn] > 0 && [get_collection_size $s1_clrn_to_alt_xcvr_sync_aibreset] > 0 && [get_collection_size $alt_xcvr_sync_din_to_rx_parallel_data] > 0} {
    set_false_path -from $aib_reset_out_stage_to_clrn -through $s1_clrn_to_alt_xcvr_sync_aibreset -to $alt_xcvr_sync_din_to_rx_parallel_data
  }


}; #foreach inst

#-------------------------------------------------- #
#---                                            --- #
#--- DISABLE MIN_PULSE_WIDTH CHECK on fPLL      --- #
#---                                            --- #
#-------------------------------------------------- #

# Disable min_width_pulse for fPLL counter nodes
set all_ports_list [get_ports *]
foreach_in_collection port $all_ports_list {

  set fpll_counter_nodes_list [get_nodes -nowarn [get_node_info -name $port]~inputFITTER_INSERTED_FITTER_INSERTED~fpll_c?_div]

  if {[get_collection_size $fpll_counter_nodes_list] > 0} {
    foreach_in_collection fpll_counter_node $fpll_counter_nodes_list {
      disable_min_pulse_width [get_node_info -name $fpll_counter_node]
    }
  }
}

msg_vdebug "IP SDC: End of Native PHY IP SDC file!"


 13 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 2 ip 14 qsfp_xcvr_test 38 qsfp_xcvr_test_xcvr_native_s10_htile_1 33 altera_xcvr_native_s10_htile_1930 5 synth 64 qsfp_xcvr_test_xcvr_native_s10_htile_1_ip_parameters_ugm7okq.tcl 4066 if {0} {
   unset native_phy_ip_params
}

set native_phy_ip_params [dict create]

dict set native_phy_ip_params profile_cnt "2"
set ::GLOBAL_corename qsfp_xcvr_test_xcvr_native_s10_htile_1_altera_xcvr_native_s10_htile_1930_ugm7okq
# ------------------------------- #
# --- Profile0 settings       --- #
# ------------------------------- #
dict set native_phy_ip_params channels_profile0 "1"
dict set native_phy_ip_params set_data_rate_profile0 "10312.5"
dict set native_phy_ip_params bonded_mode_profile0 "not_bonded"
dict set native_phy_ip_params rcfg_enable_profile0 "1"
dict set native_phy_ip_params set_prbs_soft_logic_enable_profile0 "1"
dict set native_phy_ip_params std_pcs_pma_width_profile0 "10"
dict set native_phy_ip_params enh_pcs_pma_width_profile0 "64"
dict set native_phy_ip_params pcs_direct_width_profile0 "8"
dict set native_phy_ip_params protocol_mode_profile0 "basic_enh"
dict set native_phy_ip_params tx_fifo_mode_profile0 "Phase compensation"
dict set native_phy_ip_params rx_fifo_mode_profile0 "Phase compensation"
dict set native_phy_ip_params std_tx_byte_ser_mode_profile0 "Disabled"
dict set native_phy_ip_params std_rx_byte_deser_mode_profile0 "Disabled"
dict set native_phy_ip_params duplex_mode_profile0 "duplex"
dict set native_phy_ip_params enable_hip_profile0 "0"
dict set native_phy_ip_params tx_clkout_sel_profile0 "pcs_clkout"
dict set native_phy_ip_params rx_clkout_sel_profile0 "pcs_clkout"
dict set native_phy_ip_params enable_port_tx_clkout2_profile0 "1"
dict set native_phy_ip_params enable_port_rx_clkout2_profile0 "1"
dict set native_phy_ip_params tx_clkout2_sel_profile0 "pma_div_clkout"
dict set native_phy_ip_params rx_clkout2_sel_profile0 "pma_div_clkout"
dict set native_phy_ip_params tx_pma_div_clkout_divider_profile0 "2"
dict set native_phy_ip_params rx_pma_div_clkout_divider_profile0 "2"
dict set native_phy_ip_params l_tx_fifo_transfer_mode_profile0 "x2"
dict set native_phy_ip_params l_rx_fifo_transfer_mode_profile0 "x2"
dict set native_phy_ip_params datapath_select_profile0 "Enhanced"
dict set native_phy_ip_params tx_enable_profile0 "1"
dict set native_phy_ip_params rx_enable_profile0 "1"
# ------------------------------- #
# --- Profile1 settings       --- #
# ------------------------------- #
dict set native_phy_ip_params channels_profile1 "1"
dict set native_phy_ip_params set_data_rate_profile1 "25781.25"
dict set native_phy_ip_params bonded_mode_profile1 "not_bonded"
dict set native_phy_ip_params rcfg_enable_profile1 "1"
dict set native_phy_ip_params set_prbs_soft_logic_enable_profile1 "1"
dict set native_phy_ip_params std_pcs_pma_width_profile1 "10"
dict set native_phy_ip_params enh_pcs_pma_width_profile1 "64"
dict set native_phy_ip_params pcs_direct_width_profile1 "8"
dict set native_phy_ip_params protocol_mode_profile1 "basic_enh"
dict set native_phy_ip_params tx_fifo_mode_profile1 "Phase compensation"
dict set native_phy_ip_params rx_fifo_mode_profile1 "Phase compensation"
dict set native_phy_ip_params std_tx_byte_ser_mode_profile1 "Disabled"
dict set native_phy_ip_params std_rx_byte_deser_mode_profile1 "Disabled"
dict set native_phy_ip_params duplex_mode_profile1 "duplex"
dict set native_phy_ip_params enable_hip_profile1 "0"
dict set native_phy_ip_params tx_clkout_sel_profile1 "pcs_clkout"
dict set native_phy_ip_params rx_clkout_sel_profile1 "pcs_clkout"
dict set native_phy_ip_params enable_port_tx_clkout2_profile1 "1"
dict set native_phy_ip_params enable_port_rx_clkout2_profile1 "1"
dict set native_phy_ip_params tx_clkout2_sel_profile1 "pma_div_clkout"
dict set native_phy_ip_params rx_clkout2_sel_profile1 "pma_div_clkout"
dict set native_phy_ip_params tx_pma_div_clkout_divider_profile1 "2"
dict set native_phy_ip_params rx_pma_div_clkout_divider_profile1 "2"
dict set native_phy_ip_params l_tx_fifo_transfer_mode_profile1 "x2"
dict set native_phy_ip_params l_rx_fifo_transfer_mode_profile1 "x2"
dict set native_phy_ip_params datapath_select_profile1 "Enhanced"
dict set native_phy_ip_params tx_enable_profile1 "1"
dict set native_phy_ip_params rx_enable_profile1 "1"
 13 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 2 ip 14 qsfp_xcvr_test 39 qsfp_xcvr_test_xcvr_reset_control_s10_0 34 altera_xcvr_reset_control_s10_1911 5 synth 22 alt_xcvr_reset_s10.sdc 3137 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# ---------------------------------------------------------------- #
# -                                                              - #
# --- THIS IS AN AUTO-GENERATED FILE!                          --- #
# --- Do not change the contents of this file.                 --- # 
# --- Your changes will be lost once the IP is regenerated!    --- #
# ---                                                          --- #
# -                                                              - # 
# ---------------------------------------------------------------- #

#set current_inst [get_current_instance]

#-----------------------------------#
#-- Async user reset synchronizer --#
#-----------------------------------#
set resync_reset_din_s1 [get_registers -nowarn alt_xcvr_resync_reset|resync_chains[0].synchronizer_nocut|din_s1]
set resync_reset_dreg [get_registers -nowarn alt_xcvr_resync_reset|resync_chains[0].synchronizer_nocut|dreg[0]]
set resync_din_s1_clrn_pin [get_pins -compat -nowarn alt_xcvr_resync_reset|resync_chains[0].synchronizer_nocut|din_s1|clrn]
set resync_dreg_clrn_pin [get_pins -compat -nowarn alt_xcvr_resync_reset|resync_chains[0].synchronizer_nocut|dreg[0]|clrn]

if {[get_collection_size $resync_reset_din_s1] > 0 } {
  foreach_in_collection reg $resync_reset_din_s1 {
    foreach_in_collection pin $resync_din_s1_clrn_pin {
      set_false_path -to $reg -through $pin
    }
  }
}

if {[get_collection_size $resync_reset_dreg] > 0 } {
  foreach_in_collection reg $resync_reset_dreg {
    foreach_in_collection pin $resync_dreg_clrn_pin {
      set_false_path -to $reg -through $pin
    }
  }
}

#-----------------------------------#
#-- TX async signals synchronizer --#
#-----------------------------------#
set resync_tx_signals [get_keepers -nowarn g_tx.g_tx[*].g_tx.resync_tx_cal_busy|resync_chains[?].synchronizer_nocut|din_s1]
if {[get_collection_size $resync_tx_signals] > 0 } {
  foreach_in_collection kpr $resync_tx_signals {
    set_false_path -to $kpr
  }
}

#-----------------------------------#
#-- RX async signals synchronizer --#
#-----------------------------------#
set resync_rx_signals [get_keepers -nowarn g_rx.g_rx[*].g_rx.resync_rx_cal_busy|resync_chains[?].synchronizer_nocut|din_s1]
if {[get_collection_size $resync_rx_signals] > 0 } {
  foreach_in_collection kpr $resync_rx_signals {
    set_false_path -to $kpr
  }
}
 13 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 2 ip 13 sdi_xcvr_test 37 sdi_xcvr_test_xcvr_native_s10_htile_0 33 altera_xcvr_native_s10_htile_1930 5 synth 46 alt_xcvr_native_global_constraints_5rlvnya.sdc 9068 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# ---------------------------------------------------------------- #
# -                                                              - #
# --- THIS IS AN AUTO-GENERATED FILE!                          --- #
# --- Do not change the contents of this file.                 --- # 
# --- Your changes will be lost once the IP is regenerated!    --- #
# ---                                                          --- #
# --- This file contains the global timing constraints for     --- #
# --- Native PHY IP                                            --- #
# ---    * Clock creation and other constraints are contained  --- #
# ---      ${ip_name}_alt_xcvr_native_5rlvnya.sdc              --- #
# -                                                              - # 
# ---------------------------------------------------------------- #

set script_dir [file dirname [info script]] 
set split_qsys_output_name [split sdi_xcvr_test_xcvr_native_s10_htile_0_altera_xcvr_native_s10_htile_1930_5rlvnya "_"]
set xcvr_nphy_index [lsearch $split_qsys_output_name "altera"]
if {$xcvr_nphy_index < 0} {
  set list_top_inst_name $split_qsys_output_name
} else {
  set list_top_inst_name [lreplace $split_qsys_output_name $xcvr_nphy_index end]
}
set top_inst_name [join $list_top_inst_name "_"]
source "${script_dir}/${top_inst_name}_ip_parameters_5rlvnya.tcl"

# Find the current Native PHY instance name in the design
set instance_name [get_current_instance]


#-------------------------------------------------- #
#---                                            --- #
#--- SET_FALSE_PATH for TX BONDING              --- #
#---                                            --- #
#-------------------------------------------------- #

set pld_tx_clk_dcm_pin_col [get_pins -compat -nowarn $instance_name|g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_tx_clk*_dcm]

# Remove all paths for TX bonding signals
if {[dict get $native_phy_ip_params bonded_mode_profile0] == "pma_pcs" && [get_collection_size $pld_tx_clk_dcm_pin_col] > 0 } {

  # Cutting fake paths between continguously placed, but separately bonded Native PHY IP instances
  set pld_clk_dcm_reg_col    [get_registers -nowarn *|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_tx_clk*_dcm.reg]

  if {[get_collection_size $pld_clk_dcm_reg_col] > 0} {
    set_false_path -through $pld_tx_clk_dcm_pin_col -to $pld_clk_dcm_reg_col
  }
}

#-------------------------------------------------- #
#---                                            --- #
#--- Internal loopback path                     --- #
#---                                            --- #
#-------------------------------------------------- #

set duplex_mode     [dict get $native_phy_ip_params duplex_mode_profile0]

# Cut internal loopback paths from TX instance when simplex is enabled and merging TX and RX simplex into same channel
if { $duplex_mode == "tx" } {
  set tx_fabric_data_out_col            [get_pins -compat -nowarn $instance_name|g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|aib_fabric_tx_data_out*]
  set tx_aibnd_idata_col                [get_pins -compat -nowarn $instance_name|g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_aibnd_tx.inst_ct1_hssi_aibnd_tx|idat*]
  set rx_transfer_clk_reg_col           [get_registers -nowarn    *g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx~aib_fabric_rx_transfer_clk.reg]
  set aib_tx_internal_div_reg_col       [get_registers -nowarn    $instance_name|g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~aib_tx_internal_div.reg]
  set aib_fabric_pma_aib_tx_clk_col     [get_registers -nowarn    $instance_name|g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~aib_fabric_pma_aib_tx_clk.reg]
  set aib_fabric_pma_aib_tx_clk_pin_col [get_pins -compat -nowarn $instance_name|g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|aib_fabric_pma_aib_tx_clk]

  if {[get_collection_size $pld_tx_clk_dcm_pin_col] > 0  &&  [get_collection_size $rx_transfer_clk_reg_col] > 0} {
    set_false_path -through $pld_tx_clk_dcm_pin_col -to $rx_transfer_clk_reg_col
    if {[get_collection_size $tx_fabric_data_out_col] > 0 && [get_collection_size $tx_aibnd_idata_col] > 0} {
      set_false_path -from $pld_tx_clk_dcm_pin_col -through $tx_fabric_data_out_col -through $tx_aibnd_idata_col -to $rx_transfer_clk_reg_col
    }
  }

  if {[get_collection_size $aib_fabric_pma_aib_tx_clk_pin_col] > 0 && [get_collection_size $tx_fabric_data_out_col] > 0 && [get_collection_size $tx_aibnd_idata_col] > 0 && [get_collection_size $rx_transfer_clk_reg_col] > 0} {
    set_false_path -from $aib_fabric_pma_aib_tx_clk_pin_col -through $tx_fabric_data_out_col -through $tx_aibnd_idata_col -to $rx_transfer_clk_reg_col
  }

  if {[get_collection_size $aib_fabric_pma_aib_tx_clk_col] > 0 && [get_collection_size $tx_fabric_data_out_col] > 0 && [get_collection_size $tx_aibnd_idata_col] > 0 && [get_collection_size $rx_transfer_clk_reg_col] > 0} {
    set_false_path -from $aib_fabric_pma_aib_tx_clk_col -through $tx_fabric_data_out_col -through $tx_aibnd_idata_col -to $rx_transfer_clk_reg_col
  }

  if {[get_collection_size $aib_tx_internal_div_reg_col] > 0 && [get_collection_size $aib_fabric_pma_aib_tx_clk_pin_col] > 0 && [get_collection_size $rx_transfer_clk_reg_col] > 0} {
    set_false_path -from $aib_tx_internal_div_reg_col -through $aib_fabric_pma_aib_tx_clk_pin_col -to $rx_transfer_clk_reg_col
  }
}

  # -------------------------------------------------------------------------------------------------- #
  # --- set false path for physical adjacent channel transfer clock connections to other phy IPs   --- #
  # -------------------------------------------------------------------------------------------------- #
  set aib_tx_internal_div_reg_col [get_registers -nowarn $instance_name|g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~aib_tx_internal_div.reg]
  set my_aib_fabric_transfer_clk_col [get_registers -nowarn $instance_name|g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~*aib_fabric_tx_transfer_clk.reg]
  set oth_aib_fabric_transfer_clk_col [get_registers -nowarn *|g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~*aib_fabric_tx_transfer_clk.reg]
  if { [get_collection_size $my_aib_fabric_transfer_clk_col] > 0 } {
    set oth_aib_fabric_transfer_clk_col [remove_from_collection $oth_aib_fabric_transfer_clk_col $my_aib_fabric_transfer_clk_col]
  }
  if { [get_collection_size $aib_tx_internal_div_reg_col] > 0 && [get_collection_size $oth_aib_fabric_transfer_clk_col] > 0 } {
    set_false_path -from $aib_tx_internal_div_reg_col -to $oth_aib_fabric_transfer_clk_col 
  }
 
#-------------------------------------------------- #
#---                                            --- #
#--- DISABLE MIN_PULSE_WIDTH CHECK on fPLL      --- #
#---                                            --- #
#-------------------------------------------------- #

# Disable min_width_pulse for fPLL counter nodes
set all_ports_list [get_ports *]
foreach_in_collection port $all_ports_list {

  set fpll_counter_nodes_list [get_nodes -nowarn [get_node_info -name $port]~inputFITTER_INSERTED_FITTER_INSERTED~fpll_c?_div]

  if {[get_collection_size $fpll_counter_nodes_list] > 0} {
    foreach_in_collection fpll_counter_node $fpll_counter_nodes_list {
      disable_min_pulse_width [get_node_info -name $fpll_counter_node]
    }
  }
}


 13 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 2 ip 13 sdi_xcvr_test 37 sdi_xcvr_test_xcvr_native_s10_htile_0 33 altera_xcvr_native_s10_htile_1930 5 synth 44 alt_xcvr_native_helper_functions_5rlvnya.tcl 58185 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# -------------------------------------------------------------------------- #
# - 
# --- This file contains helper functions for Native PHY SDC file
# -
# -------------------------------------------------------------------------- #
set script_dir [file dirname [info script]]

load_package sdc_ext
load_package design

if {![info exists native_debug]} {
  global ::native_debug
}

set native_debug 0

# Create dictionary to map clocks to their respective target node
if {[info exists alt_xcvr_native_s10_target_clock_list_dict]} {
   unset alt_xcvr_native_s10_target_clock_list_dict
}
global ::alt_xcvr_native_s10_target_clock_list_dict
set alt_xcvr_native_s10_target_clock_list_dict [dict create]

# -------------------------------------------------------------------------- #
# ---                                                                    --- #
# --- Procedure to initialize the database of all required pins and      --- #
# --- registers to create clocks                                         --- #
# ---                                                                    --- #
# -------------------------------------------------------------------------- #
proc native_initialize_db_5rlvnya { native_db } {

  # upvar links one variable to another variable at specified level of execution
  upvar $native_db local_native_db

  # Set the GLOBAL_corename in ip_parameters.tcl 
  global ::GLOBAL_corename
  global ::native_debug

  # Delete the database if it exists
  if [info exists local_native_db] {
    msg_vdebug "IP SDC: Database existed before, deleting it now"
    unset local_native_db
  } 

  set local_native_db [dict create]

  msg_vdebug "IP SDC: Initializing S10 Native PHY database for CORE $::GLOBAL_corename"

  # Find the current Native PHY instance name in the design
  set instance_name [get_current_instance]

  # Create dictionary of pins
  msg_vdebug "IP SDC: Finding port-to-pin mapping for CORE: $::GLOBAL_corename INSTANCE: $instance_name"
  set all_pins [dict create]
  native_get_pins_5rlvnya $all_pins
  
  # Set the associative array
  dict set local_native_db $instance_name $all_pins

}


# -------------------------------------------------------------------------- #
# ---                                                                    --- #
# --- Procedure to find all the pins and registers for nodes of interest --- #
# ---                                                                    --- #
# -------------------------------------------------------------------------- #
proc native_get_pins_5rlvnya { all_pins } {

  global ::native_debug

  # We need to make a local copy of the allpins associative array
  upvar all_pins native_pins

  # ------------------------------------------------------------------------- #
  # Define the pins here 
  # Include regex to grab pins for multiple channels

  # Dummy refclk source node
  set aib_tx_clk_source_node g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~aib_tx_clk_source
  set aib_rx_clk_source_node g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx~aib_rx_clk_source

  # Dummy flipflop to add large Tco to ensure timing failure in transfers between channels
  set aib_tx_internal_div_reg_node g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~aib_tx_internal_div.reg
  set aib_rx_internal_div_reg_node g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx~aib_rx_internal_div.reg

  # Output clocks from main adapter to core
  set tx_clkout_pin  g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_pcs_tx_clk_out1_dcm
  set tx_clkout2_pin g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_pcs_tx_clk_out2_dcm
  set rx_clkout_pin  g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|pld_pcs_rx_clk_out1_dcm
  set rx_clkout2_pin g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|pld_pcs_rx_clk_out2_dcm

  # Input clocks to main adapter from aib
  set aib_fabric_rx_transfer_clk_pin g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|aib_fabric_rx_transfer_clk

  # hclk
  set hclk_pin                       g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|pld_pma_hclk_hioint
  set aib_hclk_internal_div_reg_node g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx~aib_hclk_internal_div.reg

  # ------------------------------------------------------------------------- #
  # Create a dictionary for each clock pin 
  set native_pins [dict create]

  # ------------------------------------------------------------------------- #
  set aib_tx_clk_source_id [get_nodes -nowarn $aib_tx_clk_source_node]

  if {[get_collection_size $aib_tx_clk_source_id] > 0} {
    foreach_in_collection clk $aib_tx_clk_source_id {
      dict lappend native_pins tx_pma_parallel_clk [get_node_info -name $clk] 
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: After getting AIB TX CLK SOURCE node info: [dict get $native_pins tx_pma_parallel_clk]"
    }

    dict set native_pins tx_pma_parallel_clk [join [lsort -dictionary [dict get $native_pins tx_pma_parallel_clk]]]

  } else {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: Could not find pins for AIB TX CLK SOURCE"
    }
  }

  # ------------------------------------------------------------------------- #
  set aib_rx_clk_source_id [get_nodes -nowarn $aib_rx_clk_source_node]

  if {[get_collection_size $aib_rx_clk_source_id] > 0} {
    foreach_in_collection clk $aib_rx_clk_source_id {
      dict lappend native_pins rx_pma_parallel_clk [get_node_info -name $clk] 
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: After getting AIB TX CLK SOURCE node info: [dict get $native_pins rx_pma_parallel_clk]"
    }

    dict set native_pins rx_pma_parallel_clk [join [lsort -dictionary [dict get $native_pins rx_pma_parallel_clk]]]

  } else {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: Could not find nodes for AIB RX CLK SOURCE"
    }
  }

  # ------------------------------------------------------------------------- #
  set aib_tx_internal_div_reg_id [get_registers -nowarn $aib_tx_internal_div_reg_node]

  if {[get_collection_size $aib_tx_internal_div_reg_id] > 0} {
    foreach_in_collection clk $aib_tx_internal_div_reg_id {
      dict lappend native_pins tx_pcs_x2_clk [get_node_info -name $clk] 
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: After getting AIB TX INTERNAL DIV REG node info: [dict get $native_pins tx_pcs_x2_clk]"
    }

    dict set native_pins tx_pcs_x2_clk [join [lsort -dictionary [dict get $native_pins tx_pcs_x2_clk]]]

  } else {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: Could not find registers for AIB TX INTERNAL DIV REG"
    }
  }

  # ------------------------------------------------------------------------- #
  set aib_rx_internal_div_reg_id [get_registers -nowarn $aib_rx_internal_div_reg_node]

  if {[get_collection_size $aib_rx_internal_div_reg_id] > 0} {
    foreach_in_collection clk $aib_rx_internal_div_reg_id {
      dict lappend native_pins rx_pcs_x2_clk [get_node_info -name $clk] 
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: After getting AIB RX INTERNAL DIV REG node info: [dict get $native_pins rx_pcs_x2_clk]"
    }

    dict set native_pins rx_pcs_x2_clk [join [lsort -dictionary [dict get $native_pins rx_pcs_x2_clk]]]

  } else {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: Could not find registers for AIB RX INTERNAL DIV REG"
    }
  }

  # ------------------------------------------------------------------------- #
  set tx_clkout_id [get_pins -compatibility_mode -nowarn $tx_clkout_pin]

  if {[get_collection_size $tx_clkout_id] == 0} {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: pld_pcs_tx_clk_out1_dcm does not exist."
    }
  }

  if {[get_collection_size $tx_clkout_id] > 0} {
    foreach_in_collection clk $tx_clkout_id {
      dict lappend native_pins tx_clkout [get_pin_info -name $clk] 
      # Pipe clocks
      dict lappend native_pins tx_clkout_pipe_g1 [get_pin_info -name $clk]
      dict lappend native_pins tx_clkout_pipe_g2 [get_pin_info -name $clk]
      dict lappend native_pins tx_clkout_pipe_g3 [get_pin_info -name $clk] 
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: After getting TX CLKOUT node info: [dict get $native_pins tx_clkout]"
    }

    dict set native_pins tx_clkout [join [lsort -dictionary [dict get $native_pins tx_clkout]]]
    dict set native_pins tx_clkout_pipe_g1 [join [lsort -dictionary [dict get $native_pins tx_clkout_pipe_g1]]]
    dict set native_pins tx_clkout_pipe_g2 [join [lsort -dictionary [dict get $native_pins tx_clkout_pipe_g2]]]
    dict set native_pins tx_clkout_pipe_g3 [join [lsort -dictionary [dict get $native_pins tx_clkout_pipe_g3]]]

  } else {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: Could not find pins for TX CLKOUT"
    }
  }

  # ------------------------------------------------------------------------- #
  set tx_clkout2_id [get_pins -compatibility_mode -nowarn $tx_clkout2_pin]

  if {[get_collection_size $tx_clkout2_id] == 0} {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: pld_pcs_tx_clk_out2_dcm does not exist."
    }
  }

  if {[get_collection_size $tx_clkout2_id] > 0} {
    foreach_in_collection clk $tx_clkout2_id {
      dict lappend native_pins tx_clkout2 [get_pin_info -name $clk] 
      # Pipe clocks
      dict lappend native_pins tx_clkout2_pipe_g1 [get_pin_info -name $clk]
      dict lappend native_pins tx_clkout2_pipe_g2 [get_pin_info -name $clk]
      dict lappend native_pins tx_clkout2_pipe_g3 [get_pin_info -name $clk]
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: After getting TX CLKOUT2 node info: [dict get $native_pins tx_clkout2]"
    }

    dict set native_pins tx_clkout2 [join [lsort -dictionary [dict get $native_pins tx_clkout2]]]
    dict set native_pins tx_clkout2_pipe_g1 [join [lsort -dictionary [dict get $native_pins tx_clkout2_pipe_g1]]]
    dict set native_pins tx_clkout2_pipe_g2 [join [lsort -dictionary [dict get $native_pins tx_clkout2_pipe_g2]]]
    dict set native_pins tx_clkout2_pipe_g3 [join [lsort -dictionary [dict get $native_pins tx_clkout2_pipe_g3]]]

  } else {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: Could not find pins for TX CLKOUT2"
    }
  }

  # ------------------------------------------------------------------------- #
  set rx_clkout_id [get_pins -compatibility_mode -nowarn $rx_clkout_pin]

  if {[get_collection_size $rx_clkout_id] == 0} {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: pld_pcs_rx_clk_out1_dcm does not exist."
    }
  }

  if {[get_collection_size $rx_clkout_id] > 0} {
    foreach_in_collection clk $rx_clkout_id {
      dict lappend native_pins rx_clkout [get_pin_info -name $clk]
      # Pipe clocks
      dict lappend native_pins rx_clkout_pipe_g1 [get_pin_info -name $clk]
      dict lappend native_pins rx_clkout_pipe_g2 [get_pin_info -name $clk]
      dict lappend native_pins rx_clkout_pipe_g3 [get_pin_info -name $clk]
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: After getting RX CLKOUT node info: [dict get $native_pins rx_clkout]"
    }

    dict set native_pins rx_clkout [join [lsort -dictionary [dict get $native_pins rx_clkout]]]
    dict set native_pins rx_clkout_pipe_g1 [join [lsort -dictionary [dict get $native_pins rx_clkout_pipe_g1]]]
    dict set native_pins rx_clkout_pipe_g2 [join [lsort -dictionary [dict get $native_pins rx_clkout_pipe_g2]]]
    dict set native_pins rx_clkout_pipe_g3 [join [lsort -dictionary [dict get $native_pins rx_clkout_pipe_g3]]]

  } else {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: Could not find pins for RX CLKOUT"
    }
  }

  # ------------------------------------------------------------------------- #
  set rx_clkout2_id [get_pins -compatibility_mode -nowarn $rx_clkout2_pin]

  if {[get_collection_size $rx_clkout2_id] == 0} {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: pld_pcs_rx_clk_out2_dcm does not exist."
    }
  }

  if {[get_collection_size $rx_clkout2_id] > 0} {
    foreach_in_collection clk $rx_clkout2_id {
      dict lappend native_pins rx_clkout2 [get_pin_info -name $clk]
      # Pipe clocks
      dict lappend native_pins rx_clkout2_pipe_g1 [get_pin_info -name $clk]
      dict lappend native_pins rx_clkout2_pipe_g2 [get_pin_info -name $clk]
      dict lappend native_pins rx_clkout2_pipe_g3 [get_pin_info -name $clk]
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: After getting RX CLKOUT2 node info: [dict get $native_pins rx_clkout2]"
    }

    dict set native_pins rx_clkout2 [join [lsort -dictionary [dict get $native_pins rx_clkout2]]]
    dict set native_pins rx_clkout2_pipe_g1 [join [lsort -dictionary [dict get $native_pins rx_clkout2_pipe_g1]]]
    dict set native_pins rx_clkout2_pipe_g2 [join [lsort -dictionary [dict get $native_pins rx_clkout2_pipe_g2]]]
    dict set native_pins rx_clkout2_pipe_g3 [join [lsort -dictionary [dict get $native_pins rx_clkout2_pipe_g3]]]

  } else {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: Could not find pins for RX CLKOUT2"
    }
  }

  # ------------------------------------------------------------------------- #
  set rx_transfer_clk_id [get_pins -compatibility_mode -nowarn $aib_fabric_rx_transfer_clk_pin]

  if {[get_collection_size $rx_transfer_clk_id] > 0} {
    foreach_in_collection clk $rx_transfer_clk_id {
      dict lappend native_pins rx_transfer_clk [get_pin_info -name $clk]
      dict lappend native_pins rx_transfer_clk2 [get_pin_info -name $clk] 
      dict lappend native_pins rx_transfer_clk_pipe_g1  [get_pin_info -name $clk]
      dict lappend native_pins rx_transfer_clk2_pipe_g1 [get_pin_info -name $clk] 
      dict lappend native_pins rx_transfer_clk_pipe_g2  [get_pin_info -name $clk]
      dict lappend native_pins rx_transfer_clk2_pipe_g2 [get_pin_info -name $clk] 
      dict lappend native_pins rx_transfer_clk_pipe_g3  [get_pin_info -name $clk]
      dict lappend native_pins rx_transfer_clk2_pipe_g3 [get_pin_info -name $clk] 
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: After getting RX TRANSFER CLK node info: [dict get $native_pins rx_transfer_clk]"
    }

    dict set native_pins rx_transfer_clk [join [lsort -dictionary [dict get $native_pins rx_transfer_clk]]]
    dict set native_pins rx_transfer_clk2 [join [lsort -dictionary [dict get $native_pins rx_transfer_clk2]]]
    dict set native_pins rx_transfer_clk_pipe_g1  [join [lsort -dictionary [dict get $native_pins rx_transfer_clk_pipe_g1]]]
    dict set native_pins rx_transfer_clk2_pipe_g1 [join [lsort -dictionary [dict get $native_pins rx_transfer_clk2_pipe_g1]]]
    dict set native_pins rx_transfer_clk_pipe_g2  [join [lsort -dictionary [dict get $native_pins rx_transfer_clk_pipe_g2]]]
    dict set native_pins rx_transfer_clk2_pipe_g2 [join [lsort -dictionary [dict get $native_pins rx_transfer_clk2_pipe_g2]]]
    dict set native_pins rx_transfer_clk_pipe_g3  [join [lsort -dictionary [dict get $native_pins rx_transfer_clk_pipe_g3]]]
    dict set native_pins rx_transfer_clk2_pipe_g3 [join [lsort -dictionary [dict get $native_pins rx_transfer_clk2_pipe_g3]]]

  } else {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: Could not find pins for RX TRANSFER CLK"
    }
  }

  # ------------------------------------------------------------------------- #
  set hclk_pin_id [get_pins -compatibility_mode -nowarn $hclk_pin]

  if {[get_collection_size $hclk_pin_id] > 0} {
    foreach_in_collection clk $hclk_pin_id {
      dict lappend native_pins hclk [get_pin_info -name $clk] 
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: After getting HCLK node info: [dict get $native_pins hclk]"
    }

    dict set native_pins hclk [join [lsort -dictionary [dict get $native_pins hclk]]]

  } else {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: Could not find pins for HCLK"
    }
  }

  # ------------------------------------------------------------------------- #
  set aib_hclk_internal_div_reg_id [get_registers -nowarn $aib_hclk_internal_div_reg_node]

  if {[get_collection_size $aib_hclk_internal_div_reg_id] > 0} {
    foreach_in_collection clk $aib_hclk_internal_div_reg_id {
      dict lappend native_pins hclk_internal_div_reg [get_node_info -name $clk] 
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: After getting AIB HCLK INTERNAL DIV REG node info: [dict get $native_pins hclk_internal_div_reg]"
    }

    dict set native_pins hclk_internal_div_reg [join [lsort -dictionary [dict get $native_pins hclk_internal_div_reg]]]

  } else {
    if {$native_debug == 1} {
      post_message -type info "IP SDC: Could not find registers for AIB HCLK INTERNAL DIV REG"
    }
  }

}

# -------------------------------------------------------------------------------- #
# ---                                                                          --- #
# --- Procedure to call procedure to create clocks all channels in an instance --- #
# ---                                                                          --- #
# -------------------------------------------------------------------------------- #
proc native_prepare_to_create_clocks_all_ch_5rlvnya { instance num_channels mode mode_clks profile_cnt profile alt_xcvr_native_s10_pins clk_freq_dict multiply_factor_dict divide_factor_dict all_profile_clocks_names } {
  global ::native_debug

  set list_of_clk_names [list]

  foreach clk_group $mode_clks { # Each mode can have multiple clocks; iterate over them
    if { $native_debug } {
      post_message -type info "IP SDC: Clock group in $mode_clks is: $clk_group"
    }

    if { [dict exists $alt_xcvr_native_s10_pins $instance $clk_group] } {

      set clk_pins [dict get $alt_xcvr_native_s10_pins $instance $clk_group]

      if { $native_debug } {
        post_message -type info "IP SDC: Pins for $clk_group: $clk_pins"
      }

      if { [llength $clk_pins] > 0 } { # Check to see if the corresponding pins exists 

        #Remap any backward slashes '' in the pins
        set clk_pins [string map {\\ \\\\} $clk_pins] 

        if { $mode == "tx_source_clks" || $mode == "rx_source_clks"} {
          set clk_freq [dict get $clk_freq_dict $clk_group]

          # Create clks for all channels for a clk group in mode clk
          lappend list_of_clk_names [native_create_clocks_all_ch_5rlvnya $instance $clk_group $num_channels $clk_freq $clk_pins $profile_cnt $profile]

        } else {
          set clk_freq ""
          set multiply_factor [dict get $multiply_factor_dict $clk_group]
          set divide_factor   [dict get $divide_factor_dict   $clk_group]

          if { $clk_group == "tx_pcs_x2_clk" } {
            set source_nodes  [dict get $alt_xcvr_native_s10_pins $instance tx_pma_parallel_clk]
            set master_clocks [dict get $all_profile_clocks_names $profile  tx_source_clks]

          } elseif { $clk_group == "rx_pcs_x2_clk" } {
            set source_nodes  [dict get $alt_xcvr_native_s10_pins $instance rx_pma_parallel_clk]
            set master_clocks [dict get $all_profile_clocks_names $profile  rx_source_clks]

          } elseif { $clk_group == "hclk_internal_div_reg" } {
            set source_nodes  [dict get $alt_xcvr_native_s10_pins $instance rx_pma_parallel_clk]
            set master_clocks [dict get $all_profile_clocks_names $profile  rx_source_clks]

          } elseif { $mode == "tx_mode_clks" } {
            set source_nodes  [dict get $alt_xcvr_native_s10_pins $instance tx_pcs_x2_clk]
            set master_clocks [dict get $all_profile_clocks_names $profile  tx_internal_div_reg_clks]

          } elseif { $mode == "rx_mode_clks" } {
            
            # For rx_clkout2, check if RX is in register mode and rx_transfer_clk was created
            set full_instance_split [ split $instance | ]  
            set full_instance_split [lreplace $full_instance_split end end]
            set short_inst_name [join $full_instance_split "|"]
            set rx_transfer_clk_col [get_clocks -nowarn ${short_inst_name}*rx_transfer_clk|ch*]

            if {[get_collection_size $rx_transfer_clk_col] > 0} {
              set rx_transfer_clk_name_list [list]
              foreach_in_collection clk $rx_transfer_clk_col {
                lappend rx_transfer_clk_name_list [get_clock_info -name $clk]
              }
              set rx_transfer_clk_name_list [join [lsort -dictionary $rx_transfer_clk_name_list]]

              set source_nodes  [dict get $alt_xcvr_native_s10_pins $instance rx_transfer_clk]
              set master_clocks $rx_transfer_clk_name_list
            } else {
              set source_nodes  [dict get $alt_xcvr_native_s10_pins $instance rx_pcs_x2_clk]
              set master_clocks [dict get $all_profile_clocks_names $profile  rx_internal_div_reg_clks]
            }

          } elseif { $mode == "hclk_mode" } {
            set source_nodes  [dict get $alt_xcvr_native_s10_pins $instance hclk_internal_div_reg]
            set master_clocks [dict get $all_profile_clocks_names $profile  hclk_internal_div_reg_clks]

          } else {
            post_message -type warning "IP SDC Warning: Cannot find source node for $clk_group key in group $mode"
          }

          #Remap any backward slashes '' in the source clock nodes
          set source_nodes [string map {\\ \\\\} $source_nodes] 

          # Create clks for all channels for a clk group in mode clk
          lappend list_of_clk_names [native_create_clocks_all_ch_5rlvnya $instance $clk_group $num_channels $clk_freq $clk_pins $profile_cnt $profile $source_nodes $master_clocks $multiply_factor $divide_factor]
        }
      }

     } else {
       if {$native_debug == 1} {
         post_message -type warning "IP SDC Warning: $clk_group key does not exist in pins dictionary"
       }
     }
  } ; # foreach clk_group in mode_clks

  return $list_of_clk_names

}

# ----------------------------------------------------------------------------- #
# ---                                                                       --- #
# --- Procedure to create HSSI clocks for all channels in an instance       --- #
# ---                                                                       --- #
# ----------------------------------------------------------------------------- #
proc native_create_clocks_all_ch_5rlvnya { instance clk_group num_channels freq clk_list profile_cnt profile args } {
  global ::native_debug

  set clock_name_list [list]

  # Remove the 'xcvr_native_s10_0' from each full instance name
  set full_instance_split [ split $instance | ]  
  set full_instance_split [lreplace $full_instance_split end end]
  set short_inst_name [join $full_instance_split "|"]

  # Replace any '[' and ']' characters with with '?' since Tcl string matching doesn't work with explicit '[' and ']' characters
  set regex_instance [regsub -all {\[} $instance {?}]
  set regex_instance [regsub -all {\]} $regex_instance {?}]

  # Iterate through all channels
  for { set channel 0 } { $channel < $num_channels } { incr channel } {

    # Match channel node with nodes in the clock group
    set channel_node_regexp $regex_instance|g_xcvr_native_insts?$channel?.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_?x.inst_ct1_hssi_pldadapt_?x*
    set channel_node_regexp [string map {\\ \\\\} $channel_node_regexp]
    set matching_clk_nodes  [lsearch -inline $clk_list $channel_node_regexp]
    set matching_clk_nodes  [string map {\\ \\\\} $matching_clk_nodes]

    if { $native_debug == 1 } {
      post_message -type info "IP SDC: Matching Channel $channel nodes: $matching_clk_nodes"
    }

    # Iterate through all nodes in the clock group
    foreach clk_node $matching_clk_nodes {

      # Remove the instance name from the clock node due to auto promotion in SDC_ENTITY
      set no_inst_clk_node [string replace $clk_node 0 [string length $instance]]
  
      # Shorten the clock name if multiple profiles are not used
      if { $profile_cnt > 1 } { 
        set clock_name ${short_inst_name}|profile$profile|$clk_group|ch$channel
      } else {
        set clock_name ${short_inst_name}|$clk_group|ch$channel
      }
      # Add the clock name to the list 
      lappend clock_name_list $clock_name
      
      # Check if clock with same name already exists, if so skip clock creation
      set matching_clocks_list [get_clocks -nowarn $clock_name]

      if { [get_collection_size $matching_clocks_list] > 0 } {
        foreach_in_collection matching_clk $matching_clocks_list {

          # Check if clock is declared AND defined (i.e. create_clock or create_generated_clock was used)
          if { [is_clock_defined $clock_name] == 1 } {
            if { $native_debug == 1 } {
              post_message -type warning "Clock already exists with name $clock_name with period [get_clock_info $matching_clk -period]ns on node [get_object_info -name [get_clock_info $matching_clk -targets]]"
            }

          # Clock was declared, but not defined, so we need to create the clock still (i.e. "declare_clock" command was used)
          } else {

            if { $args != "" } {
              set source_nodes  [lindex $args 0]
              set master_clocks [lindex $args 1]
  
              set clk_source_node  [lindex $source_nodes  $channel]
              set clk_master_clock [lindex $master_clocks $channel]

              # Remove the instance name from the clock source node due to auto promotion in SDC_ENTITY
              set no_inst_clk_source_node [string replace $clk_source_node 0 [string length $instance]]

              set multiply_factor [lindex $args 2] 
              set divide_factor   [lindex $args end]

              # Call procedure to create generated clock for given clock node 
              native_create_clock_5rlvnya $clk_group $clock_name $freq $no_inst_clk_node $channel $no_inst_clk_source_node $clk_master_clock $multiply_factor $divide_factor

            } else {

              # Call procedure to create source clock for given clock node 
              native_create_clock_5rlvnya $clk_group $clock_name $freq $no_inst_clk_node $channel
            }
          }
        }; #foreach_in_collection matching_clk matching_clocks_list

      # Create clock if no clock exists already with same name
      } else { 


        if { $args != "" } {
          set source_nodes  [lindex $args 0]
          set master_clocks [lindex $args 1]
  
          set clk_source_node  [lindex $source_nodes  $channel]
          set clk_master_clock [lindex $master_clocks $channel]

          # Remove the instance name from the clock source node due to auto promotion in SDC_ENTITY
          set no_inst_clk_source_node [string replace $clk_source_node 0 [string length $instance]]

          set multiply_factor [lindex $args 2] 
          set divide_factor   [lindex $args end]

          # Call procedure to create generated clock for given clock node 
          native_create_clock_5rlvnya $clk_group $clock_name $freq $no_inst_clk_node $channel $no_inst_clk_source_node $clk_master_clock $multiply_factor $divide_factor

        } else {

          # Call procedure to create source clock for given clock node 
          native_create_clock_5rlvnya $clk_group $clock_name $freq $no_inst_clk_node $channel
        }
      }

    }; # foreach clk in clk_list
  }; # foreach channel

  # Return the list of clock names  
  return $clock_name_list

}

# ----------------------------------------------------------------------------- #
# ---                                                                       --- #
# --- Procedure to create single HSSI clock for given node and clock name   --- #
# ---                                                                       --- #
# ----------------------------------------------------------------------------- #
proc native_create_clock_5rlvnya { clk_group clock_name freq clk_node channel args } {
  global ::native_debug
  global ::alt_xcvr_native_s10_target_clock_list_dict

  if { $native_debug == 1 } {
    post_message -type info "IP SDC: Clock name = $clock_name"
  }
  
  # Use "create_clock" for source nodes
  if { $clk_group == "tx_pma_parallel_clk" || $clk_group == "rx_pma_parallel_clk" } {
  
    create_clock \
        -name    $clock_name \
        -period "$freq MHz" \
                 $clk_node -add
  
    # Add clock to target node key in the target clock list dictionary
    dict lappend alt_xcvr_native_s10_target_clock_list_dict $clk_node $clock_name

    if { $native_debug == 1 } {
      post_message -type info "IP SDC: Clocks on target node $clk_node"
      post_message -type info "                => [dict get $alt_xcvr_native_s10_target_clock_list_dict $clk_node]"
    }

  # Use "create_generated_clock" for the downstream nodes (*~aib_tx/rx_internal_div.reg and MAIB output pins)
  } elseif { $args != "" } {
  
    set clk_source_node  [lindex $args 0]
    set clk_master_clock [lindex $args 1]
    set multiply_factor  [lindex $args 2] 
    set divide_factor    [lindex $args end]
  
    if { $native_debug == 1 } {
            post_message -type info "IP SDC: Source node is $clk_source_node"
            post_message -type info "        Master clock is $clk_master_clock"
    }
  
    create_generated_clock \
        -name         $clock_name \
        -source       $clk_source_node \
        -master_clock $clk_master_clock \
        -multiply_by  $multiply_factor \
        -divide_by    $divide_factor \
                      $clk_node -add

    # Add clock to target node key in the target clock list dictionary
    dict lappend alt_xcvr_native_s10_target_clock_list_dict $clk_node $clock_name

    if { $native_debug == 1 } {
      post_message -type info "IP SDC: Clocks on target node $clk_node"
      post_message -type info "                => [dict get $alt_xcvr_native_s10_target_clock_list_dict $clk_node]"
    }

  }

}


# ----------------------------------------------------------------------------- #
# ---                                                                       --- #
# --- Procedure to adjust min pulse requirement for coreclkin2 to be        --- #
# --- frequency-dependency                                                  --- #
# ---                                                                       --- #
# ----------------------------------------------------------------------------- #
proc native_check_special_min_pulse_5rlvnya { clock_name } {
  global ::native_debug
  set pass 1  

  # Find old active clocks, and then set all clocks active
  set old_active_clocks [get_active_clocks]
  set_active_clocks [all_clocks]
  
  set clock_spec_collection [get_clocks $clock_name]
  foreach_in_collection clock_spec $clock_spec_collection { }

  # Get clock period
  set period [get_clock_info -period $clock_spec]
  set frequency [expr 1 / $period * 1000]
  
  # Determine min pulse adjustment
  set frequency_list [list 0.0         501.0              600.0                 700.0                 800.0                 900.0                1000.0]
  set min_pulse_list [list 0.0 [expr 400.0-400.0] [expr 400.0 - 366.7]  [expr 400.0 - 342.9] [expr 400.0 - 325.0]  [expr 400.0 - 311.1] [expr 400.0 - 300.0] ]
  
  # Determine min pulse spec adjustment
  set i 0
  set min_pulse_adjustment 0.0 
  foreach xfreq $frequency_list {
     if { $frequency <= $xfreq } {
        set min_pulse_adjustment [lindex $min_pulse_list [expr $i - 1]]
        break
     }
     incr i
  }
  
  # Get min pulse information
  set min_pulse_info [get_min_pulse_width $clock_name]
  set min_pulse_slack [lindex [lindex $min_pulse_info 0] 0]

  # If after the adjusment we are still negative, then output the min pulse report, and indicate the failure
  if {[expr $min_pulse_slack + $min_pulse_adjustment] < 0 } {
     report_min_pulse_width -nworst 100 -detail full_path -panel_name "Minimum Pulse Width: $clock_name" [get_clocks $clock_name]
     post_message -type critical_warning "Min Pulse Requirements on Tile Transfer not met; see DDR report for more details"
     set pass 0
  }

  # Also make sure, nothing else is connected on this clock domain
  set setup_from_paths_col    [get_timing_paths -from $clock_spec -setup]
  set setup_to_paths_col      [get_timing_paths -to   $clock_spec -setup]
  set hold_from_paths_col     [get_timing_paths -from $clock_spec -hold]
  set hold_to_paths_col       [get_timing_paths -to   $clock_spec -hold]
  set recovery_from_paths_col [get_timing_paths -from $clock_spec -recovery]
  set recovery_to_paths_col   [get_timing_paths -to   $clock_spec -recovery]
  set removal_from_paths_col  [get_timing_paths -from $clock_spec -removal]
  set removal_to_paths_col    [get_timing_paths -to   $clock_spec -removal]

  set num_setup_from_paths    [get_collection_size $setup_from_paths_col]
  set num_setup_to_paths      [get_collection_size $setup_to_paths_col]
  set num_hold_from_paths     [get_collection_size $hold_from_paths_col]
  set num_hold_to_paths       [get_collection_size $hold_to_paths_col]
  set num_recovery_from_paths [get_collection_size $recovery_from_paths_col]
  set num_recovery_to_paths   [get_collection_size $recovery_to_paths_col]
  set num_removal_from_paths  [get_collection_size $removal_from_paths_col]
  set num_removal_to_paths    [get_collection_size $removal_to_paths_col]

  if { $native_debug == 1 } {
    post_message -type info "IP SDC: "
    post_message -type info "       num_setup_from    = $num_setup_from_paths"
    post_message -type info "       num_setup_to      = $num_setup_to_paths"
    post_message -type info "       num_hold_from     = $num_hold_from_paths"
    post_message -type info "       num_hold_to       = $num_hold_to_paths"
    post_message -type info "       num_recovery_from = $num_recovery_from_paths"
    post_message -type info "       num_recovery_to   = $num_recovery_to_paths"
    post_message -type info "       num_removal_from  = $num_removal_from_paths"
    post_message -type info "       num_removal_to    = $num_removal_to_paths"
  }

  if {($num_setup_from_paths > 0) || ($num_setup_to_paths > 0) || ($num_hold_from_paths > 0) || ($num_hold_to_paths > 0) || ($num_recovery_from_paths > 0) || ($num_recovery_to_paths > 0) || ($num_removal_from_paths > 0) || ($num_removal_to_paths > 0)} {
     set pass 1

     # ----------------------------------------------------
     # Print out path information for SETUP FROM paths
     # ----------------------------------------------------
     if { $num_setup_from_paths > 0 } {

       # Initialize the number of found bond fifo paths to zero
       set num_bond_fifo_setup_paths 0

       foreach_in_collection path $setup_from_paths_col {

         # Check the arrival path points to see if one of them is the one of the bond_fifo pins (we should ignore this transfer)
         set arrival_pts_col [get_path_info -arrival_points $path]
         set found_bond_fifo_setup_path 0

         foreach_in_collection point $arrival_pts_col {

           # Only check the node points
           set pt_node_id [get_point_info -node $point]

           if { $pt_node_id != "" } {
             set pt_node_name [get_node_info -name $pt_node_id]
             set ds_out_rden_pin_regex "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_rden"
             set us_out_rden_pin_regex "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_rden"
             set ds_out_dv_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_dv"
             set us_out_dv_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_dv"


             if { [string match $ds_out_rden_pin_regex $pt_node_name] || [string match $us_out_rden_pin_regex $pt_node_name] || [string match $ds_out_dv_pin_regex $pt_node_name] || [string match $us_out_dv_pin_regex $pt_node_name] } {
               # Increment the number of found bond_fifo setup paths
               incr found_bond_fifo_setup_path
               incr num_bond_fifo_setup_paths
               break
             }

           }
         }; #foreach point in arrival_pts_col

         # Check to ensure the slack is positive
         set path_slack [get_path_info -slack $path]
         if { $path_slack < 0 } {
           set found_bond_fifo_setup_path 0 
         }

         # Print out the path info if no bond_fifo path was found
         if { $found_bond_fifo_setup_path == 0 } {
           set source_node [get_node_info  -name [get_path_info -from $path]]
           set dest_node   [get_node_info  -name [get_path_info -to $path]]
           set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
           set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
           post_message -type critical_warning "Unexpected timed setup path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
         }
       }; #foreach path in setup_from_paths_col

       # If the number of bond_fifo paths found matches the number of setup paths, then we can ignore the transfers
       if { $num_bond_fifo_setup_paths != $num_setup_from_paths } {
         set pass 0
       }
     }

     # ----------------------------------------------------
     # Print out path information for SETUP TO paths
     # ----------------------------------------------------
     if { $num_setup_to_paths > 0 } {

       # Initialize the number of found bond fifo paths to zero
       set num_bond_fifo_setup_paths 0

       foreach_in_collection path $setup_to_paths_col {

         # Check the arrival path points to see if one of them is the one of the bond_fifo pins (we should ignore this transfer)
         set arrival_pts_col [get_path_info -arrival_points $path]
         set found_bond_fifo_setup_path 0

         foreach_in_collection point $arrival_pts_col {

           # Only check the node points
           set pt_node_id [get_point_info -node $point]

           if { $pt_node_id != "" } {
             set pt_node_name [get_node_info -name $pt_node_id]
             set ds_out_rden_pin_regex "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_rden"
             set us_out_rden_pin_regex "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_rden"
             set ds_out_dv_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_dv"
             set us_out_dv_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_dv"


             if { [string match $ds_out_rden_pin_regex $pt_node_name] || [string match $us_out_rden_pin_regex $pt_node_name] || [string match $ds_out_dv_pin_regex $pt_node_name] || [string match $us_out_dv_pin_regex $pt_node_name] } {
               # Increment the number of found bond_fifo setup paths
               incr found_bond_fifo_setup_path
               incr num_bond_fifo_setup_paths
               break
             }

           }
         }; #foreach point in arrival_pts_col

         # Check to ensure the slack is positive
         set path_slack [get_path_info -slack $path]
         if { $path_slack < 0 } {
           set found_bond_fifo_setup_path 0 
         }

         # Print out the path info if no bond_fifo path was found
         if { $found_bond_fifo_setup_path == 0 } {
           set source_node [get_node_info  -name [get_path_info -from $path]]
           set dest_node   [get_node_info  -name [get_path_info -to $path]]
           set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
           set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
           post_message -type critical_warning "Unexpected timed setup path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
         }
       }; #foreach path in setup_to_paths_col

       # If the number of bond_fifo paths found matches the number of setup paths, then we can ignore the transfers
       if { $num_bond_fifo_setup_paths != $num_setup_to_paths } {
         set pass 0
       }
     }

     # ----------------------------------------------------
     # Print out path information for HOLD FROM paths
     # ----------------------------------------------------
     if { $num_hold_from_paths > 0 } {

       # Initialize the number of found bond fifo paths to zero
       set num_bond_fifo_hold_paths 0

       foreach_in_collection path $hold_from_paths_col {

         # Check the arrival path points to see if one of them is the one of the bond_fifo pins (we should ignore this transfer)
         set arrival_pts_col [get_path_info -arrival_points $path]
         set found_bond_fifo_hold_path 0

         foreach_in_collection point $arrival_pts_col {

           # Only check the node points
           set pt_node_id [get_point_info -node $point]

           if { $pt_node_id != "" } {
             set pt_node_name [get_node_info -name $pt_node_id]
             set ds_out_rden_pin_regex "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_rden"
             set us_out_rden_pin_regex "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_rden"
             set ds_out_dv_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_dv"
             set us_out_dv_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_dv"


             if { [string match $ds_out_rden_pin_regex $pt_node_name] || [string match $us_out_rden_pin_regex $pt_node_name] || [string match $ds_out_dv_pin_regex $pt_node_name] || [string match $us_out_dv_pin_regex $pt_node_name] } {
               # Increment the number of found bond_fifo hold paths
               incr found_bond_fifo_hold_path
               incr num_bond_fifo_hold_paths
               break
             }

           }
         }; #foreach point in arrival_pts_col

         # Check to ensure the slack is positive
         set path_slack [get_path_info -slack $path]
         if { $path_slack < 0 } {
           set found_bond_fifo_hold_path 0 
         }

         # Print out the path info if no bond_fifo path was found
         if { $found_bond_fifo_hold_path == 0 } {
           set source_node [get_node_info  -name [get_path_info -from $path]]
           set dest_node   [get_node_info  -name [get_path_info -to $path]]
           set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
           set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
           post_message -type critical_warning "Unexpected timed hold path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
         }
       }; #foreach path in hold_from_paths_col

       # If the number of bond_fifo paths found matches the number of hold paths, then we can ignore the transfers
       if { $num_bond_fifo_hold_paths != $num_hold_from_paths } {
         set pass 0
       }
     }

     # ----------------------------------------------------
     # Print out path information for HOLD TO paths
     # ----------------------------------------------------
     if { $num_hold_to_paths > 0 } {

       # Initialize the number of found bond fifo paths to zero
       set num_bond_fifo_hold_paths 0

       foreach_in_collection path $hold_to_paths_col {

         # Check the arrival path points to see if one of them is the one of the bond_fifo pins (we should ignore this transfer)
         set arrival_pts_col [get_path_info -arrival_points $path]
         set found_bond_fifo_hold_path 0

         foreach_in_collection point $arrival_pts_col {

           # Only check the node points
           set pt_node_id [get_point_info -node $point]

           if { $pt_node_id != "" } {
             set pt_node_name [get_node_info -name $pt_node_id]
             set ds_out_rden_pin_regex "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_rden"
             set us_out_rden_pin_regex "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_rden"
             set ds_out_dv_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_dv"
             set us_out_dv_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_dv"


             if { [string match $ds_out_rden_pin_regex $pt_node_name] || [string match $us_out_rden_pin_regex $pt_node_name] || [string match $ds_out_dv_pin_regex $pt_node_name] || [string match $us_out_dv_pin_regex $pt_node_name] } {
               # Increment the number of found bond_fifo hold paths
               incr found_bond_fifo_hold_path
               incr num_bond_fifo_hold_paths
               break
             }

           }
         }; #foreach point in arrival_pts_col

         # Check to ensure the slack is positive
         set path_slack [get_path_info -slack $path]
         if { $path_slack < 0 } {
           set found_bond_fifo_hold_path 0 
         }

         # Print out the path info if no bond_fifo path was found
         if { $found_bond_fifo_hold_path == 0 } {
           set source_node [get_node_info  -name [get_path_info -from $path]]
           set dest_node   [get_node_info  -name [get_path_info -to $path]]
           set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
           set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
           post_message -type critical_warning "Unexpected timed hold path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
         }
       }; #foreach path in hold_to_paths_col

       # If the number of bond_fifo paths found matches the number of hold paths, then we can ignore the transfers
       if { $num_bond_fifo_hold_paths != $num_hold_to_paths } {
         set pass 0
       }
     }

     # ----------------------------------------------------
     # Print out path information for RECOVERY FROM paths
     # ----------------------------------------------------
     if { $num_recovery_from_paths > 0 } {
       foreach_in_collection path $recovery_from_paths_col {
         set source_node [get_node_info  -name [get_path_info -from $path]]
         set dest_node   [get_node_info  -name [get_path_info -to $path]]
         set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
         set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
         post_message -type critical_warning "Unexpected timed recovery path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
       }

       # Set pass to zero
			 set pass 0

     }

     # ----------------------------------------------------
     # Print out path information for REMOVAL FROM paths
     # ----------------------------------------------------
     if { $num_removal_from_paths > 0 } {
       foreach_in_collection path $removal_from_paths_col {
         set source_node [get_node_info -name [get_path_info -from $path]]
         set dest_node   [get_node_info -name [get_path_info -to $path]]
         set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
         set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
         post_message -type critical_warning "Unexpected timed removal path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
       }

       # Set pass to zero
			 set pass 0

     }

     # ----------------------------------------------------
     # Print out path information for RECOVERY TO paths
     # ----------------------------------------------------
     if { $num_recovery_to_paths > 0 } {

       # Initialize the number of found reset paths to zero
       set num_reset_recovery_paths 0

       foreach_in_collection path $recovery_to_paths_col {

         # Check the arrival path points to see if one of them is the reset pin (we should ignore this transfer)
         set arrival_pts_col [get_path_info -arrival_points $path]
         set found_reset_recovery_path 0

         foreach_in_collection point $arrival_pts_col {

           # Only check the node points
           set pt_node_id [get_point_info -node $point]

           if { $pt_node_id != "" } {
             set pt_node_name [get_node_info -name $pt_node_id]
             set reset_adapt_pin_regex "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_adapter_tx_pld_rst_n"
             set reset_pcs_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_pcs_tx_pld_rst_n"
             set reset_pma_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_pma_txpma_rstb"

             if {[string match $reset_adapt_pin_regex $pt_node_name] || [string match $reset_pcs_pin_regex $pt_node_name] || [string match $reset_pma_pin_regex $pt_node_name]} {
               # Increment the number of found reset recovery paths
               incr found_reset_recovery_path
               incr num_reset_recovery_paths
               break
             }

           }
         }; #foreach point in arrival_pts_col

         # Check to ensure the slack is positive
         set path_slack [get_path_info -slack $path]
         if { $path_slack < 0 } {
           set found_reset_recovery_path 0 
         }

         # Print out the path info if no reset path was found
         if { $found_reset_recovery_path == 0 } {
           set source_node [get_node_info  -name [get_path_info -from $path]]
           set dest_node   [get_node_info  -name [get_path_info -to $path]]
           set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
           set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
           post_message -type critical_warning "Unexpected timed recovery path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
         }
       }; #foreach path in recovery_to_paths_col

       # If the number of reset paths found matches the number of recovery paths, then we can ignore the transfers
       if { $num_reset_recovery_paths != $num_recovery_to_paths } {
         # Set pass to zero
			   set pass 0

         if { $native_debug == 1 } {
           post_message -type warning "IP SDC: num_reset_recovery_paths = $num_reset_recovery_paths"
         }
       }
     }

     # ----------------------------------------------------
     # Print out path information for REMOVAL TO paths
     # ----------------------------------------------------
     if { $num_removal_to_paths > 0 } {

       # Initialize the number of found reset paths to zero
       set num_reset_removal_paths 0

       foreach_in_collection path $removal_to_paths_col {

         # Check the arrival path points to see if one of them is the reset pin (we should ignore this transfer)
         set arrival_pts_col [get_path_info -arrival_points $path]
         set found_reset_removal_path 0

         foreach_in_collection point $arrival_pts_col {

           # Only check the node points
           set pt_node_id [get_point_info -node $point]

           if { $pt_node_id != "" } {
             set pt_node_name [get_node_info -name $pt_node_id]
             set reset_adapt_pin_regex "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_adapter_tx_pld_rst_n"
             set reset_pcs_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_pcs_tx_pld_rst_n"
             set reset_pma_pin_regex   "*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_pma_txpma_rstb"

             if {[string match $reset_adapt_pin_regex $pt_node_name] || [string match $reset_pcs_pin_regex $pt_node_name] || [string match $reset_pma_pin_regex $pt_node_name]} {
               # Increment the number of found reset recovery paths
               incr found_reset_removal_path
               incr num_reset_removal_paths
               break
             }

           }
         }; #foreach point in arrival_pts_col

         # Check to ensure the slack is positive
         set path_slack [get_path_info -slack $path]
         if { $path_slack < 0 } {
           set found_reset_removal_path 0 
         }

         # Print out the path info if no reset path was found
         if { $found_reset_removal_path == 0 } {
           set source_node [get_node_info  -name [get_path_info -from $path]]
           set dest_node   [get_node_info  -name [get_path_info -to $path]]
           set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
           set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
           post_message -type critical_warning "Unexpected timed removal path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
         }
       }; #foreach path in removal_to_paths_col

       # If the number of reset paths found matches the number of removal paths, then we can ignore the transfers
       if { $num_reset_removal_paths != $num_removal_to_paths } {
         # Set pass to zero
			   set pass 0

         if { $native_debug == 1 } {
           post_message -type warning "IP SDC: num_reset_removal_paths = $num_reset_removal_paths"
         }
       }
    }

  }; #if { num_setup_from_paths > 0 || ... || ... }
  
  # Check if min pulse width passed
  if { $pass == 0 } {
     post_message -type critical_warning "Timing requirements not met"
  }
  
  # Before returning set the active clocks to the ones that were active before entering this function 
  set_active_clocks $old_active_clocks 
}


 13 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 2 ip 13 sdi_xcvr_test 37 sdi_xcvr_test_xcvr_native_s10_htile_0 33 altera_xcvr_native_s10_htile_1930 5 synth 39 alt_xcvr_native_re_cal_chnl_5rlvnya.sdc 6475 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# ---------------------------------------------------------------- #
# -                                                              - #
# --- THIS IS AN AUTO-GENERATED FILE!                          --- #
# --- Do not change the contents of this file.                 --- # 
# --- Your changes will be lost once the IP is regenerated!    --- #
# ---                                                          --- #
# --- This file contains the clock creation constraints for    --- #
# --- recalibration soft IP                                    --- #
# -                                                              - # 
# ---------------------------------------------------------------- #

# Source the IP parameters Tcl file
set script_dir [file dirname [info script]] 
set split_qsys_output_name [split sdi_xcvr_test_xcvr_native_s10_htile_0_altera_xcvr_native_s10_htile_1930_5rlvnya "_"]
set xcvr_nphy_index [lsearch $split_qsys_output_name "altera"]
if {$xcvr_nphy_index < 0} {
  set list_top_inst_name $split_qsys_output_name
} else {
  set list_top_inst_name [lreplace $split_qsys_output_name $xcvr_nphy_index end]
}
set top_inst_name [join $list_top_inst_name "_"]
source "${script_dir}/${top_inst_name}_ip_parameters_5rlvnya.tcl"

# Get the number of channels in the Native PHY IP
set num_channels [dict get $native_phy_ip_params channels_profile0]

# Find the current Native PHY instance name in the design
set instance_name [get_current_instance]

# Grab the entity name for the XCVR reset sequencer (needed because the recal clocks are derived 
# from the internal oscillator clock which feeds the XCVR reset sequencer)
set alt_xcvr_reset_seq_entity_inst [get_entity_instances {altera_xcvr_reset_sequencer_s10}]
set alt_xcvr_reset_seq_entity_inst_list [split $alt_xcvr_reset_seq_entity_inst |]
set alt_xcvr_reset_seq_entity_inst_list  [lreplace $alt_xcvr_reset_seq_entity_inst_list end end]
set alt_xcvr_reset_seq_entity_inst_final_name [join $alt_xcvr_reset_seq_entity_inst_list |]

#-------------------------------------------------- #
#---                                            --- #
#--- CLOCK CREATION                             --- #
#---                                            --- #
#-------------------------------------------------- #

# For each channel
for {set i 0} {$i < $num_channels} {incr i} {

  # Get the clk_div8 registers
  set recal_clk_div8_col [get_registers -nowarn $instance_name|g_recal[$i].alt_xcvr_recal|clk_div8]
  if { [get_collection_size $recal_clk_div8_col] > 0 } {
  
    # Get the internal oscillator fanin to the clk_div2 register
    set clk_div8_fanin_col [get_fanins -stop_at_clocks $recal_clk_div8_col]
  
    set int_osc_clk_name ""
    foreach_in_collection fanin $clk_div8_fanin_col {
      set temp_fanin_name [get_node_info -name $fanin]
      if {[string match *$alt_xcvr_reset_seq_entity_inst_final_name*_divided_osc_clk|q $temp_fanin_name]} {
        set int_osc_clk_name $temp_fanin_name
        break
      }
    }
  
    # -------------------------------------------------- #
    # --- CLK_DIV2 CREATION                          --- #
    # -------------------------------------------------- #
    foreach_in_collection clk_div8 $recal_clk_div8_col {
  
      set clk_div8_node_name [get_node_info -name $clk_div8]
  
      if {$int_osc_clk_name != ""} {
  
        create_generated_clock \
          -name $instance_name|recal_clk_div8|ch$i \
          -divide_by 8 \
          -source $int_osc_clk_name \
          $clk_div8_node_name
      }; # if statement
     }; #foreach in recal_clk_div8_col
  }; #if clk_div8
}; #for i < num_channels


#-------------------------------------------------- #
#---                                            --- #
#--- SET FALSE PATHS TO SYNCHRONIZERS           --- #
#---                                            --- #
#-------------------------------------------------- #

# start_synchronizer
set start_synchronizer_col [get_registers -nowarn $instance_name|g_recal[*].alt_xcvr_recal|start_synchronizer|resync_chains[*].synchronizer_nocut|din_s1]
if {[get_collection_size $start_synchronizer_col] > 0} {
  foreach_in_collection resync_reg $start_synchronizer_col {
    set_false_path -to $resync_reg
  }
}

# alt_xcvr_resync_avmm1_busy
set alt_xcvr_resync_avmm1_busy_col [get_registers -nowarn $instance_name|g_recal[*].alt_xcvr_recal|alt_xcvr_resync_avmm1_busy|resync_chains[*].synchronizer_nocut|din_s1]
if {[get_collection_size $alt_xcvr_resync_avmm1_busy_col] > 0} {
  foreach_in_collection resync_reg $alt_xcvr_resync_avmm1_busy_col {
    set_false_path -to $resync_reg
  }
}

# alt_xcvr_resync_bg_en
set alt_xcvr_resync_bg_en_col [get_registers -nowarn $instance_name|g_recal[*].alt_xcvr_recal|alt_xcvr_resync_bg_en|resync_chains[*].synchronizer_nocut|din_s1]
if {[get_collection_size $alt_xcvr_resync_bg_en_col] > 0} {
  foreach_in_collection resync_reg $alt_xcvr_resync_bg_en_col {
    set_false_path -to $resync_reg
  }
}

# alt_xcvr_resync_recal_waitrequest
set alt_xcvr_resync_recal_waitrequest_col [get_registers -nowarn $instance_name|g_recal[*].alt_xcvr_recal|recal_wreq_synchronizer|resync_chains[*].synchronizer_nocut|din_s1]
if {[get_collection_size $alt_xcvr_resync_recal_waitrequest_col] > 0} {
  foreach_in_collection resync_reg $alt_xcvr_resync_recal_waitrequest_col {
    set_false_path -to $resync_reg
  }
}
# alt_xcvr_resync_reset
set alt_xcvr_resync_reset_col [get_pins -nowarn $instance_name|g_recal[*].alt_xcvr_recal|alt_xcvr_resync_reset*|resync_chains[*].synchronizer_nocut|d*|clrn]
if {[get_collection_size $alt_xcvr_resync_reset_col] > 0} {
  foreach_in_collection resync_reg $alt_xcvr_resync_reset_col {
    set_false_path -through $resync_reg
  }
}



 13 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 2 ip 13 sdi_xcvr_test 37 sdi_xcvr_test_xcvr_native_s10_htile_0 33 altera_xcvr_native_s10_htile_1930 5 synth 83 sdi_xcvr_test_xcvr_native_s10_htile_0_altera_xcvr_native_s10_htile_1930_5rlvnya.sdc 97864 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# ---------------------------------------------------------------- #
# -                                                              - #
# --- THIS IS AN AUTO-GENERATED FILE!                          --- #
# --- Do not change the contents of this file.                 --- # 
# --- Your changes will be lost once the IP is regenerated!    --- #
# ---                                                          --- #
# --- This file contains the timing constraints for Native PHY --- #
# ---    * The helper functions are defined in                 --- #
# ---      alt_xcvr_native_helper_functions_5rlvnya.tcl        --- #
# -                                                              - # 
# ---------------------------------------------------------------- #

set script_dir [file dirname [info script]] 
set split_qsys_output_name [split sdi_xcvr_test_xcvr_native_s10_htile_0_altera_xcvr_native_s10_htile_1930_5rlvnya "_"]
set xcvr_nphy_index [lsearch $split_qsys_output_name "altera"]
if {$xcvr_nphy_index < 0} {
  set list_top_inst_name $split_qsys_output_name
} else {
  set list_top_inst_name [lreplace $split_qsys_output_name $xcvr_nphy_index end]
}
set top_inst_name [join $list_top_inst_name "_"]
source "${script_dir}/${top_inst_name}_ip_parameters_5rlvnya.tcl"
source "${script_dir}/alt_xcvr_native_helper_functions_5rlvnya.tcl"

# Debug switch. Change to 1 in alt_xcvr_native_helper_functions_5rlvnya.tcl to get more run-time debug information
if {![info exists native_debug]} {
  global ::native_debug
}

# ---------------------------------------------------------------- #
# -                                                              - #
# --- Build cache for all pins and registers required to apply --- #
# --- timing constraints                                       --- #
# -                                                              - #
# ---------------------------------------------------------------- #
native_initialize_db_5rlvnya nativedb_5rlvnya

# ---------------------------------------------------------------- #
# --- Set all the instances of this core                       --- #
# ---------------------------------------------------------------- #
set alt_xcvr_native_s10_instances [ dict keys $nativedb_5rlvnya ]

if {[info exists alt_xcvr_native_s10_pins]} {
   unset alt_xcvr_native_s10_pins
}
set alt_xcvr_native_s10_pins [dict create]

# ---------------------------------------------------------------- #
# -                                                              - #
# --- Iterate through each instance and apply the necessary    --- #
# --- timing constraints                                       --- #
# -                                                              - #
# ---------------------------------------------------------------- #
foreach inst $alt_xcvr_native_s10_instances {

  if { [ dict exists $alt_xcvr_native_s10_pins $inst ] } {
    dict unset alt_xcvr_native_s10_pins $inst
    
    if { $native_debug == 1} {
      post_message -type info "IP SDC: Array pins for instance $inst existed before, unsetting them"
    }

  } 
  dict set alt_xcvr_native_s10_pins $inst [dict get $nativedb_5rlvnya $inst]

  # Delete the clock names array if it exists 
  if [info exists all_profile_clocks_names] {
    unset all_profile_clocks_names
  }
  set all_profile_clocks_names [dict create]

  # -------------------------------------------------------------- #
  # --- Iterate over the profiles                              --- #
  # -------------------------------------------------------------- #
  set profile_cnt [dict get $native_phy_ip_params profile_cnt]
  set tx_enabled_on_any_profile    0
  set max_num_channels             0
  for {set i 0} {$i < $profile_cnt} {incr i} {

    if {$native_debug == 1} {
      post_message -type info "========================================================================================"
      post_message -type info "IP SDC: PROFILE $i"
    }

    set num_channels [dict get $native_phy_ip_params channels_profile$i]
    set max_num_channels  [expr { $num_channels > $max_num_channels? $num_channels : $max_num_channels} ]

    # ------------------------------------------------------------------------------- # 
    # --- Determine the FIFO operation mode (phase-compensation or register mode) --- #
    # ------------------------------------------------------------------------------- #
    if {[dict get $native_phy_ip_params tx_fifo_mode_profile$i] == "Register"} {
      set tx_fifo_mode "register"
    } else {
      set tx_fifo_mode "pc_fifo"
    }

    if {[dict get $native_phy_ip_params rx_fifo_mode_profile$i] == "Register" || [dict get $native_phy_ip_params rx_fifo_mode_profile$i] == "Phase compensation-Register" } {
      set rx_fifo_mode "register"
    } else {
      set rx_fifo_mode "pc_fifo"
    }

    if {$native_debug == 1} {
      post_message -type info "========================================================================================"
      post_message -type info "IP SDC: TX mode inferred in SDC is $tx_fifo_mode"
      post_message -type info "IP SDC: RX mode inferred in SDC is $rx_fifo_mode"
      post_message -type info "IP SDC: The procotol mode is [dict get $native_phy_ip_params protocol_mode_profile$i]"
      post_message -type info "IP SDC: The standard PCS-PMA interface width is [dict get $native_phy_ip_params std_pcs_pma_width_profile$i]"
      post_message -type info "IP SDC: The enhanced PCS-PMA interface width is [dict get $native_phy_ip_params enh_pcs_pma_width_profile$i]"
      post_message -type info "IP SDC: The data rate is [dict get $native_phy_ip_params set_data_rate_profile$i] Mbps."
    }

    set tx_fifo_transfer_mode [dict get $native_phy_ip_params l_tx_fifo_transfer_mode_profile$i]
    set rx_fifo_transfer_mode [dict get $native_phy_ip_params l_rx_fifo_transfer_mode_profile$i]

    # ----------------------------------------------------------------------------- #
    # --- Set the selected clock from mux for tx/rx_clkout and tx/rx_clkout2    --- #
    # ----------------------------------------------------------------------------- #
    set tx_clkout_sel [dict get $native_phy_ip_params tx_clkout_sel_profile$i]
    set tx_clkout2_sel [dict get $native_phy_ip_params tx_clkout2_sel_profile$i]

    set rx_clkout_sel [dict get $native_phy_ip_params rx_clkout_sel_profile$i]
    set rx_clkout2_sel [dict get $native_phy_ip_params rx_clkout2_sel_profile$i]

    if {$native_debug == 1} {
      post_message -type info "IP SDC: Clock output of tx_clkout is $tx_clkout_sel"
      post_message -type info "IP SDC: Clock output of tx_clkout2 is $tx_clkout2_sel"
      post_message -type info "IP SDC: Clock output of rx_clkout is $rx_clkout_sel"
      post_message -type info "IP SDC: Clock output of rx_clkout2 is $rx_clkout2_sel"
    }

    # ------------------------------------------------------------------------------ #
    # --- Determine the datapath based on the selected protocol mode             --- #
    # ------------------------------------------------------------------------------ #
    set datapath_select [dict get $native_phy_ip_params datapath_select_profile$i]
    set protocol_mode   [dict get $native_phy_ip_params protocol_mode_profile$i]
    set duplex_mode     [dict get $native_phy_ip_params duplex_mode_profile$i]

    # ----------------------------------------------------------------------------- #
    # --- Determine the PCS-PMA width based on which datapath was selected      --- #
    # ----------------------------------------------------------------------------- #
    if {$datapath_select == "Enhanced"} {
      set pcs_pma_width [dict get $native_phy_ip_params enh_pcs_pma_width_profile$i]
    } elseif {$datapath_select == "Standard"} {
      set pcs_pma_width [dict get $native_phy_ip_params std_pcs_pma_width_profile$i]
    } elseif {$datapath_select == "PCS Direct"} {
      set pcs_pma_width [dict get $native_phy_ip_params pcs_direct_width_profile$i]
    } else {
      post_message -type error "IP SDC: Datapath did not match any of the valid options (Standard, Enhanced, PCS Direct)."
    }
    
    # ----------------------------------------------------------------------------- #
    # --- Determine the pma_div_clkout factor                                   --- #
    # ----------------------------------------------------------------------------- #
    set tx_pma_div_clkout_divider [dict get $native_phy_ip_params tx_pma_div_clkout_divider_profile$i]
    set rx_pma_div_clkout_divider [dict get $native_phy_ip_params rx_pma_div_clkout_divider_profile$i]

    if {$tx_pma_div_clkout_divider == 0} {
      set tx_pma_div_clkout_divider 1
    }
    if {$rx_pma_div_clkout_divider == 0} {
      set rx_pma_div_clkout_divider 1
    }

    # ----------------------------------------------------------------------------- #
    # --- Byte serializer and byte deserializer                                 --- #
    # ----------------------------------------------------------------------------- #
    set std_tx_byte_ser_mode [dict get $native_phy_ip_params std_tx_byte_ser_mode_profile$i]
    if {$std_tx_byte_ser_mode == "Serialize x2" && $datapath_select == "Standard"} {
      set byte_ser 2
    } elseif {$std_tx_byte_ser_mode == "Serialize x4" && $datapath_select == "Standard"} {
      set byte_ser 4
    } else {
      set byte_ser 1
    }

    set std_rx_byte_deser_mode [dict get $native_phy_ip_params std_rx_byte_deser_mode_profile$i]
    if {$std_rx_byte_deser_mode == "Deserialize x2" && $datapath_select == "Standard"} {
      set byte_deser 2
    } elseif {$std_rx_byte_deser_mode == "Deserialize x4" && $datapath_select == "Standard"} {
      set byte_deser 4
    } else {
      set byte_deser 1
    }

    if {$native_debug == 1} {
      post_message -type info "IP SDC: Byte serializer is $byte_ser"
      post_message -type info "IP SDC: Byte deserializer is $byte_deser"
    }

    # ----------------------------------------------------------------------------- #
    # --- Calculate the parallel PMA clock frequency                            --- #
    # ----------------------------------------------------------------------------- #
    set data_rate [expr double([dict get $native_phy_ip_params set_data_rate_profile$i])]
    set pma_parallel_clock [ expr $data_rate / $pcs_pma_width ]

    set tx_transfer_clk_freq [expr double($data_rate / ($pcs_pma_width * $byte_ser)) ]
    set rx_transfer_clk_freq [expr double($data_rate / ($pcs_pma_width * $byte_deser)) ]

    if { $tx_fifo_transfer_mode != "x1" } {
        set tx_transfer_clk_freq [expr $tx_transfer_clk_freq * 2 ]
    }

    if { $rx_fifo_transfer_mode != "x1" } {
        set rx_transfer_clk_freq [expr $rx_transfer_clk_freq * 2 ]
    }

    if { $native_debug ==1 } {
      post_message -type info "IP SDC: PMA parallel CLK is $pma_parallel_clock MHz"
      post_message -type info "IP SDC: Clock output of TX transfer clock is $tx_transfer_clk_freq MHz"
      post_message -type info "IP SDC: Clock output of RX transfer clock is $rx_transfer_clk_freq MHz"
    }

    # ----------------------------------------------------------------------------- #
    # --- Unset the profile_clocks dictionary if it exists                      --- #
    # ----------------------------------------------------------------------------- #
    if [info exists profile_clocks] {
      unset profile_clocks
    }
    set profile_clocks [dict create]

    if {[info exists freq] } {
      unset freq
    }
    set freq [dict create]

    if {[info exists multiply_factor_dict] } {
      unset multiply_factor_dict
    }
    set multiply_factor_dict [dict create]

    if {[info exists divide_factor_dict] } {
      unset divide_factor_dict
    }
    set divide_factor_dict [dict create]

    # ----------------------------------------------------------------------------- #
    # --- Create TX mode clocks and clock frequencies                           --- #
    # ----------------------------------------------------------------------------- #
    # For each TX clock output (tx_clkout and tx_clkout2), the selected clock from
    # main adapter clock mux is checked.
    #
    # 1. PCS_CLKOUT     : frequency is PCS parallel clock (with serialization factor)
    #
    # 2. PCS_x2_CLKOUT  :
    #     - If transfer mode is x2 (full-rate) or x1x2 (double-rate): x2 parallel clock
    #           > Unless Standard PCS, PCS-PMA width == 20, and byte serializer is
    #             disabled: parallel clock
    #     - If transfer mode is x1 (half-rate): parallel clock
    #     - **NOTE** Native PHY parameter tx_transfer_clk_freq already accounts for 
    #                byte serializer and provides correct frequency based on transfer
    #                mode (except in case of Standard PCS, PMA-PLD = 20)
    #
    # 3. PMA_DIV_CLKOUT :
    #     - If tx_pma_div_clkout == 33, 40, 66: data rate / (pma_div * 2)
    #     - If tx_pma_div_clkout == 1, 2: parallel clock / pma_div
    #
    # **NOTE** Both FIFO (Phase-Compensation) and Register mode have the same nodes
    #          because TX Register mode is fed from the core (core_clkin)
    #
    if {[dict get $native_phy_ip_params tx_enable_profile$i]} {

      set tx_enabled_on_any_profile   1

      # -------------------------------------------------------------------------------
      # AIB TX CLK SOURCE - PMA parallel clock
      # -------------------------------------------------------------------------------
      dict set profile_clocks tx_source_clks tx_pma_parallel_clk
      dict set freq tx_pma_parallel_clk $pma_parallel_clock

      # -------------------------------------------------------------------------------
      # AIB TX INTERNAL DIV REG - transfer clock
      # -------------------------------------------------------------------------------
      dict set profile_clocks tx_internal_div_reg_clks tx_pcs_x2_clk
    
      if {$tx_fifo_transfer_mode != "x1"} {
         dict set multiply_factor_dict tx_pcs_x2_clk 2
         dict set divide_factor_dict   tx_pcs_x2_clk [expr 1*($byte_ser)]
      } else {
         dict set multiply_factor_dict tx_pcs_x2_clk 1
         dict set divide_factor_dict   tx_pcs_x2_clk [expr 1*($byte_ser)]
      }
      # -------------------------------------------------------------------------------
      # TX_CLKOUT - output clocks
      # -------------------------------------------------------------------------------
      if {$tx_clkout_sel == "pcs_clkout" } {
        dict set profile_clocks tx_mode_clks tx_clkout
        
        # If TX transfer mode is x1 then tx_transfer_clk is correct (parallel clock)
        # Otherwise for x2 or x1x2, tx_transfer_clk is twice parallel_clock
        if {$tx_fifo_transfer_mode == "x1"} {
          dict set multiply_factor_dict tx_clkout 1
          dict set divide_factor_dict   tx_clkout 1
        } else {
          dict set multiply_factor_dict tx_clkout 1
          dict set divide_factor_dict   tx_clkout 2
        }

      } elseif {$tx_clkout_sel == "pcs_x2_clkout" } {
        dict set profile_clocks tx_mode_clks tx_clkout

        # If TX transfer mode is x2/x1x2, Standard PCS, PCS-PMA width == 20, and byte serializer is disabled => parallel clock
        if {($tx_fifo_transfer_mode == "x2" || $tx_fifo_transfer_mode == "x1x2") &&
              (($datapath_select == "Standard" && $pcs_pma_width == 20 && $std_tx_byte_ser_mode == "Disabled") ||
             ($datapath_select == "PCS Direct" && $pcs_pma_width == 20))} {
          dict set multiply_factor_dict tx_clkout 1
          dict set divide_factor_dict   tx_clkout 2
        } else {
          dict set multiply_factor_dict tx_clkout 1
          dict set divide_factor_dict   tx_clkout 1
        }

      } elseif {$tx_clkout_sel == "pma_div_clkout" } {
        dict set profile_clocks tx_mode_clks tx_clkout

        if {$tx_pma_div_clkout_divider == 33 || $tx_pma_div_clkout_divider == 40 || $tx_pma_div_clkout_divider == 66 } {

          if {$tx_fifo_transfer_mode == "x1"} {
            dict set multiply_factor_dict tx_clkout [expr $byte_ser * $pcs_pma_width]
            dict set divide_factor_dict   tx_clkout [expr round($tx_pma_div_clkout_divider * 2)]
          } else {
            dict set multiply_factor_dict tx_clkout [expr $byte_ser * $pcs_pma_width]
            dict set divide_factor_dict   tx_clkout [expr round($tx_pma_div_clkout_divider * 2 * 2)]
          }

        } else {

          if {$tx_fifo_transfer_mode == "x1"} {
            dict set multiply_factor_dict tx_clkout 1
            dict set divide_factor_dict   tx_clkout $tx_pma_div_clkout_divider
          } else {
            dict set multiply_factor_dict tx_clkout 1
            dict set divide_factor_dict   tx_clkout [expr $tx_pma_div_clkout_divider * 2]
          }

        }
      } else {
        post_message -type error "IP SDC: TX CLKOUT did not match any of the valid clock options. Check the TX Clock Options."
      }

      # -------------------------------------------------------------------------------
      # TX_CLKOUT2 - output clocks
      # -------------------------------------------------------------------------------
      if {[dict get $native_phy_ip_params enable_port_tx_clkout2_profile$i] == 1} {
        if {$tx_clkout2_sel == "pcs_clkout" } {
          dict lappend profile_clocks tx_mode_clks tx_clkout2

          # If TX transfer mode is x1 then tx_transfer_clk is correct (parallel clock)
          # Otherwise for x2 or x1x2, tx_transfer_clk is twice parallel_clock
          if {$tx_fifo_transfer_mode == "x1"} {
            dict set multiply_factor_dict tx_clkout2 1
            dict set divide_factor_dict   tx_clkout2 1
          } else {
            dict set multiply_factor_dict tx_clkout2 1
            dict set divide_factor_dict   tx_clkout2 2
          }

        } elseif {$tx_clkout2_sel == "pcs_x2_clkout" } {
          dict lappend profile_clocks tx_mode_clks tx_clkout2

          # If TX transfer mode is x2/x1x2, Standard PCS, PCS-PMA width == 20, and byte serializer is disabled => parallel clock
          if {(($tx_fifo_transfer_mode == "x2" || $tx_fifo_transfer_mode == "x1x2") &&
                $datapath_select == "Standard" && $pcs_pma_width == 20 && $std_tx_byte_ser_mode == "Disabled") ||
               ($datapath_select == "PCS Direct" && $pcs_pma_width == 20)} {
            dict set multiply_factor_dict tx_clkout2 1
            dict set divide_factor_dict   tx_clkout2 2
          } else {
            dict set multiply_factor_dict tx_clkout2 1
            dict set divide_factor_dict   tx_clkout2 1
          }
           
        } elseif {$tx_clkout2_sel == "pma_div_clkout" } {
         dict lappend profile_clocks tx_mode_clks tx_clkout2

          if {$tx_pma_div_clkout_divider == 33 || $tx_pma_div_clkout_divider == 40 || $tx_pma_div_clkout_divider == 66 } {

            if {$tx_fifo_transfer_mode == "x1"} {
              dict set multiply_factor_dict tx_clkout2 [expr $byte_ser * $pcs_pma_width]
              dict set divide_factor_dict   tx_clkout2 [expr round($tx_pma_div_clkout_divider * 2)]
            } else {
              dict set multiply_factor_dict tx_clkout2 [expr $byte_ser * $pcs_pma_width]
              dict set divide_factor_dict   tx_clkout2 [expr round($tx_pma_div_clkout_divider * 2 * 2)]
            }

          } else {

            if {$tx_fifo_transfer_mode == "x1"} {
              dict set multiply_factor_dict tx_clkout2 1
              dict set divide_factor_dict   tx_clkout2 $tx_pma_div_clkout_divider
            } else {
              dict set multiply_factor_dict tx_clkout2 1
              dict set divide_factor_dict   tx_clkout2 [expr $tx_pma_div_clkout_divider * 2]
            }
          }

        } else {
          post_message -type error "IP SDC: TX CLKOUT2 did not match any of the valid clock options. Check the TX Clock Options."
        }
      } else {
        if {$native_debug == 1} {
          post_message -type info "IP SDC: TX CLKOUT2 port is not enabled"
        }
      }

    } ; # if tx_enable_profile

    # ----------------------------------------------------------------------------- #
    # --- Create RX mode clocks and clock frequencies                           --- #
    # ----------------------------------------------------------------------------- #
    # For each RX clock output (rx_clkout and rx_clkout2), the selected clock from
    # main adapter clock mux is checked.
    #
    # 1. PCS_CLKOUT     : frequency is PCS parallel clock (with deserialization factor)
    #
    # 2. PCS_x2_CLKOUT  :
    #     - If transfer mode is x2 (full-rate) or x1x2 (double-rate): x2 parallel clock
    #     - If transfer mode is x1 (half-rate): parallel clock
    #     - **NOTE** Native PHY parameter rx_transfer_clk_freq already accounts for 
    #                byte deserializer and provides correct frequency based on transfer
    #                mode.
    #
    # 3. PMA_DIV_CLKOUT :
    #     - If rx_pma_div_clkout == 33, 40, 66: data rate / (pma_div * 2)
    #     - If rx_pma_div_clkout == 1, 2: parallel clock / pma_div
    #
    # **NOTE** FIFO (Phase-Compensation) and Register mode have the different nodes
    #          when selected clock is pcs_x2_clock because RX transfer clock is fed to
    #          main adapter FIFO read and write before the clock mux in register mode
    #          (only ONE rx_transfer_clk is created).
    #
    if {[dict get $native_phy_ip_params rx_enable_profile$i]} {

      # -------------------------------------------------------------------------------
      # AIB RX CLK SOURCE - PMA parallel clock
      # -------------------------------------------------------------------------------
      dict set profile_clocks rx_source_clks rx_pma_parallel_clk
      dict set freq rx_pma_parallel_clk $pma_parallel_clock

      # -------------------------------------------------------------------------------
      # AIB RX INTERNAL DIV REG - transfer clock
      # -------------------------------------------------------------------------------
      dict set profile_clocks rx_internal_div_reg_clks rx_pcs_x2_clk
     
      if {$rx_fifo_transfer_mode != "x1"} {
         dict set multiply_factor_dict rx_pcs_x2_clk 2
         dict set divide_factor_dict   rx_pcs_x2_clk [expr 1*($byte_deser)]
      } else {
         dict set multiply_factor_dict rx_pcs_x2_clk 1
         dict set divide_factor_dict   rx_pcs_x2_clk [expr 1*($byte_deser)]
      }

      # -------------------------------------------------------------------------------
      # RX_CLKOUT - output clocks
      # -------------------------------------------------------------------------------
      if {$rx_fifo_mode == "pc_fifo"} {
        if {$rx_clkout_sel == "pcs_clkout" } {
          dict set profile_clocks rx_mode_clks rx_clkout

          if {$rx_fifo_transfer_mode == "x1"} {
            dict set multiply_factor_dict rx_clkout 1
            dict set divide_factor_dict   rx_clkout 1
          } else {
            dict set multiply_factor_dict rx_clkout 1
            dict set divide_factor_dict   rx_clkout 2
          }

        } elseif {$rx_clkout_sel == "pcs_x2_clkout" } {
          dict set profile_clocks rx_mode_clks rx_clkout
          dict set multiply_factor_dict rx_clkout 1
          dict set divide_factor_dict   rx_clkout 1
 
        } elseif {$rx_clkout_sel == "pma_div_clkout" } {
          dict set profile_clocks rx_mode_clks rx_clkout

          if {$rx_pma_div_clkout_divider == 33 || $rx_pma_div_clkout_divider == 40 || $rx_pma_div_clkout_divider == 66 } {

            if {$rx_fifo_transfer_mode == "x1"} {
              dict set multiply_factor_dict rx_clkout [expr $byte_deser * $pcs_pma_width]
              dict set divide_factor_dict   rx_clkout [expr round($rx_pma_div_clkout_divider * 2)]
            } else {
              dict set multiply_factor_dict rx_clkout [expr $byte_deser * $pcs_pma_width]
              dict set divide_factor_dict   rx_clkout [expr round($rx_pma_div_clkout_divider * 2 * 2)]
            }

          } else {

            if {$rx_fifo_transfer_mode == "x1"} {
              dict set multiply_factor_dict rx_clkout 1
              dict set divide_factor_dict   rx_clkout $rx_pma_div_clkout_divider
            } else {
              dict set multiply_factor_dict rx_clkout 1
              dict set divide_factor_dict   rx_clkout [expr $rx_pma_div_clkout_divider * 2]
            }
          }

        } else {
          post_message -type error "IP SDC: RX CLKOUT did not match any of the valid clock options. Check the RX Clock Options."
        }
      } else { # RX FIFO is in register mode
        if {$rx_clkout_sel == "pcs_x2_clkout" } {
          dict set profile_clocks rx_mode_clks rx_transfer_clk
          dict set multiply_factor_dict rx_transfer_clk 1
          dict set divide_factor_dict   rx_transfer_clk 1

        } else {
          post_message -type error "IP SDC: RX CLKOUT did not match any of the valid clock options. Check the RX Clock Options."
        }
      }

      # -------------------------------------------------------------------------------
      # RX_CLKOUT2 - output clocks
      # -------------------------------------------------------------------------------
      if {[dict get $native_phy_ip_params enable_port_rx_clkout2_profile$i] == 1} {
        if {$rx_clkout2_sel == "pcs_clkout" } {
          dict lappend profile_clocks rx_mode_clks rx_clkout2

          if {$rx_fifo_transfer_mode == "x1"} {
            dict set multiply_factor_dict rx_clkout2 1
            dict set divide_factor_dict   rx_clkout2 1
          } else {
            dict set multiply_factor_dict rx_clkout2 1
            dict set divide_factor_dict   rx_clkout2 2
          }

        } elseif {$rx_clkout2_sel == "pcs_x2_clkout" } {

          if {$rx_fifo_mode == "pc_fifo"} {
            dict lappend profile_clocks rx_mode_clks rx_clkout2
            dict set multiply_factor_dict rx_clkout2 1
            dict set divide_factor_dict   rx_clkout2 1
          } elseif {$rx_fifo_mode == "register" && $rx_clkout_sel != "pcs_x2_clkout"} {
            dict lappend profile_clocks rx_mode_clks rx_transfer_clk2      
            dict set multiply_factor_dict rx_transfer_clk2 1
            dict set divide_factor_dict   rx_transfer_clk2 1
          }

        } elseif {$rx_clkout2_sel == "pma_div_clkout" } {
          dict lappend profile_clocks rx_mode_clks rx_clkout2

          if {$rx_pma_div_clkout_divider == 33 || $rx_pma_div_clkout_divider == 40 || $rx_pma_div_clkout_divider == 66 } {

            if {$rx_fifo_transfer_mode == "x1"} {
              dict set multiply_factor_dict rx_clkout2 [expr $byte_deser * $pcs_pma_width]
              dict set divide_factor_dict   rx_clkout2 [expr round($rx_pma_div_clkout_divider * 2)]
            } else {
              dict set multiply_factor_dict rx_clkout2 [expr $byte_deser * $pcs_pma_width]
              dict set divide_factor_dict   rx_clkout2 [expr round($rx_pma_div_clkout_divider * 2 * 2)]
            }

          } elseif {$rx_pma_div_clkout_divider == 2 && $pcs_pma_width == 10} {
            if {$rx_fifo_transfer_mode == "x1"} {
              dict set multiply_factor_dict rx_clkout2 1
              dict set divide_factor_dict   rx_clkout2 [expr round($rx_pma_div_clkout_divider / 2)]
            } else {
              dict set multiply_factor_dict rx_clkout2 1
              dict set divide_factor_dict   rx_clkout2 [expr $rx_pma_div_clkout_divider * 2]
            }          

          } else {

            if {$rx_fifo_transfer_mode == "x1"} {
              dict set multiply_factor_dict rx_clkout2 1
              dict set divide_factor_dict   rx_clkout2 $rx_pma_div_clkout_divider
            } else {
              dict set multiply_factor_dict rx_clkout2 1
              dict set divide_factor_dict   rx_clkout2 [expr $rx_pma_div_clkout_divider * 2]
            }
          }

        } else {
          post_message -type error "IP SDC: RX CLKOUT2 did not match any of the valid clock options. Check the RX Clock Options"
        }

      } else {
        if {$native_debug == 1} {
          post_message -type info "IP SDC: RX CLKOUT2 port is not enabled"
        }
      }
    } ; # if rx_enable_profile

    # ----------------------------------------------------------------------------- #
    # --- Create PIPE clocks and clock frequencies                              --- #
    # ----------------------------------------------------------------------------- #

    # -------------------------------------------------------------------------------
    # HCLK
    # If we are in Gen 3 and we have hip... we have a 1Gig clock (might need to change for hip... as it comes out to the core...)
    #--------------------------------------------------------------------------------
    set hclk_freq ""
    if {[dict get $native_phy_ip_params enable_hip_profile$i] == 1} {
      set hclk_freq 1000
    } else {
      set hclk_freq 500
    }

    if {$protocol_mode == "pipe_g1" || $protocol_mode == "pipe_g2" || $protocol_mode == "pipe_g3"} {

      # Find the maximum precision of RX transfer clock frequency
      set rx_pma_parallel_clk_split [split $pma_parallel_clock "."]
      set rx_max_precision          [expr [string length [lindex $rx_pma_parallel_clk_split end]]]

      # Ensure that multiply and divide factors are less than 999999999
      if {[llength $rx_pma_parallel_clk_split] > 1 && [string length $pma_parallel_clock ] > 10} {
        set rx_max_precision [expr $rx_max_precision - [string length [lindex $rx_pma_parallel_clk_split 0]]]
      }

      dict set profile_clocks       hclk_internal_div_reg_clks hclk_internal_div_reg
      dict set multiply_factor_dict hclk_internal_div_reg [expr round($hclk_freq * (10 ** $rx_max_precision))]
      dict set divide_factor_dict   hclk_internal_div_reg [expr round($pma_parallel_clock * (10 ** $rx_max_precision))]

      dict set profile_clocks       hclk_mode hclk
      dict set multiply_factor_dict hclk 1
      dict set divide_factor_dict   hclk 1
    }

    # -------------------------------------------------------------------------------
    # PIPE Gen2
    # Create Gen2 and Gen1 clocks for PIPE Gen2 and PIPE Gen3
    # -------------------------------------------------------------------------------
    if {$protocol_mode == "pipe_g2" || $protocol_mode == "pipe_g3"} {

      # TX PIPE Gen2
      dict lappend profile_clocks tx_mode_clks tx_clkout_pipe_g2
      dict set multiply_factor_dict tx_clkout_pipe_g2 [dict get $multiply_factor_dict tx_clkout]
      dict set divide_factor_dict   tx_clkout_pipe_g2 [dict get $divide_factor_dict   tx_clkout]

      # TX PIPE Gen1
      dict lappend profile_clocks tx_mode_clks tx_clkout_pipe_g1
      dict set multiply_factor_dict tx_clkout_pipe_g1 [dict get $multiply_factor_dict tx_clkout_pipe_g2]
      dict set divide_factor_dict   tx_clkout_pipe_g1 [expr round([dict get $divide_factor_dict tx_clkout_pipe_g2] * 2)]

      # Remove original tx_clkout from profile_clocks and freq dictionaries
      set list_of_tx_clkouts [dict get $profile_clocks tx_mode_clks]
      set tx_clkout_index [lsearch $list_of_tx_clkouts tx_clkout]
      if {$tx_clkout_index < 0} {
        if {$native_debug == 1} {
          post_message -type warning "IP SDC: Cannot find key tx_clkout while creating PIPE clocks in list $list_of_tx_clkouts"
        }
      } else {
        dict set profile_clocks tx_mode_clks [lreplace $list_of_tx_clkouts $tx_clkout_index $tx_clkout_index]
      }

      set multiply_factor_dict [dict remove $multiply_factor_dict tx_clkout]
      set divide_factor_dict   [dict remove $divide_factor_dict   tx_clkout]

      # TX_CLKOUT2
      if {[dict get $native_phy_ip_params enable_port_tx_clkout2_profile$i] == 1} {

        # TX PIPE Gen2
        dict lappend profile_clocks tx_mode_clks tx_clkout2_pipe_g2
        dict set multiply_factor_dict tx_clkout2_pipe_g2 [dict get $multiply_factor_dict tx_clkout2]
        dict set divide_factor_dict   tx_clkout2_pipe_g2 [dict get $divide_factor_dict   tx_clkout2]

        # TX PIPE Gen1
        dict lappend profile_clocks tx_mode_clks tx_clkout2_pipe_g1
        dict set multiply_factor_dict tx_clkout2_pipe_g1 [dict get $multiply_factor_dict tx_clkout2_pipe_g2]
        dict set divide_factor_dict   tx_clkout2_pipe_g1 [expr round([dict get $divide_factor_dict tx_clkout2_pipe_g2] * 2)]

        # Remove original tx_clkout2 from profile_clocks and freq dictionaries
        set list_of_tx_clkouts [dict get $profile_clocks tx_mode_clks]
        set tx_clkout2_index [lsearch $list_of_tx_clkouts tx_clkout2]
        if {$tx_clkout2_index < 0} {
          if {$native_debug == 1} {
            post_message -type warning "IP SDC: Cannot find key tx_clkout2 while creating PIPE clocks in list $list_of_tx_clkouts"
          }
        } else {
          dict set profile_clocks tx_mode_clks [lreplace $list_of_tx_clkouts $tx_clkout2_index $tx_clkout2_index]
        }

        set multiply_factor_dict [dict remove $multiply_factor_dict tx_clkout2]
        set divide_factor_dict   [dict remove $divide_factor_dict   tx_clkout2]
 
      }

      if {$native_debug == 1} {
        post_message -type info "IP SDC: TX mode clocks - [dict get $profile_clocks tx_mode_clks]"
      }

      # RX PIPE
      if {[dict exists $profile_clocks rx_transfer_clk]} {

        # RX PIPE Gen2
        dict lappend profile_clocks rx_mode_clks rx_transfer_clk_pipe_g2
        dict set multiply_factor_dict rx_transfer_clk_pipe_g2 [dict get $multiply_factor_dict rx_transfer_clk]
        dict set divide_factor_dict   rx_transfer_clk_pipe_g2 [dict get $divide_factor_dict   rx_transfer_clk]

        # RX PIPE Gen1
        dict lappend profile_clocks rx_mode_clks rx_transfer_clk_pipe_g1
        dict set multiply_factor_dict rx_transfer_clk_pipe_g1 [dict get $multiply_factor_dict rx_transfer_clk_pipe_g2]
        dict set divide_factor_dict   rx_transfer_clk_pipe_g1 [expr round([dict get $divide_factor_dict rx_transfer_clk_pipe_g2] * 2)]

        # Remove original rx_transfer_clk from profile_clocks and freq dictionaries
        set list_of_rx_clkouts [dict get $profile_clocks rx_mode_clks]
        set rx_clkout_index [lsearch $list_of_rx_clkouts rx_transfer_clk]
        if {$rx_clkout_index < 0} {
          if {$native_debug == 1} {
            post_message -type warning "IP SDC: Cannot find key rx_transfer_clk while creating PIPE clocks in list $list_of_rx_clkouts"
          }
        } else {
          dict set profile_clocks rx_mode_clks [lreplace $list_of_rx_clkouts $rx_clkout_index $rx_clkout_index]
        }

        set multiply_factor_dict [dict remove $multiply_factor_dict rx_transfer_clk]
        set divide_factor_dict   [dict remove $divide_factor_dict   rx_transfer_clk]

      } else {
        # RX PIPE Gen2
        dict lappend profile_clocks rx_mode_clks rx_clkout_pipe_g2
        dict set multiply_factor_dict rx_clkout_pipe_g2 [dict get $multiply_factor_dict rx_clkout]
        dict set divide_factor_dict   rx_clkout_pipe_g2 [dict get $divide_factor_dict   rx_clkout]

        # RX PIPE Gen1
        dict lappend profile_clocks rx_mode_clks rx_clkout_pipe_g1
        dict set multiply_factor_dict rx_clkout_pipe_g1 [dict get $multiply_factor_dict rx_clkout_pipe_g2]
        dict set divide_factor_dict   rx_clkout_pipe_g1 [expr round([dict get $divide_factor_dict rx_clkout_pipe_g2] * 2)]

        # Remove original rx_clkout from profile_clocks and freq dictionaries
        set list_of_rx_clkouts [dict get $profile_clocks rx_mode_clks]
        set rx_clkout_index [lsearch $list_of_rx_clkouts rx_clkout]
        if {$rx_clkout_index < 0} {
          if {$native_debug == 1} {
            post_message -type warning "IP SDC: Cannot find key rx_clkout while creating PIPE clocks in list $list_of_rx_clkouts"
          }
        } else {
          dict set profile_clocks rx_mode_clks [lreplace $list_of_rx_clkouts $rx_clkout_index $rx_clkout_index]
        }
        #set freq [dict remove $freq rx_clkout]
        set multiply_factor_dict [dict remove $multiply_factor_dict rx_clkout]
        set divide_factor_dict   [dict remove $divide_factor_dict   rx_clkout]

      }

      # RX_CLKOUT2
      if {[dict get $native_phy_ip_params enable_port_rx_clkout2_profile$i] == 1} {
        if {[dict exists $profile_clocks rx_transfer_clk2]} {
          # RX PIPE Gen2
          dict lappend profile_clocks rx_mode_clks rx_transfer_clk2_pipe_g2
          dict set multiply_factor_dict rx_transfer_clk2_pipe_g2 [dict get $multiply_factor_dict rx_transfer_clk2]
          dict set divide_factor_dict   rx_transfer_clk2_pipe_g2 [dict get $divide_factor_dict   rx_transfer_clk2]

          # RX PIPE Gen1
          dict lappend profile_clocks rx_mode_clks rx_transfer_clk2_pipe_g1
          dict set multiply_factor_dict rx_transfer_clk2_pipe_g1 [dict get $multiply_factor_dict rx_transfer_clk2_pipe_g2]
          dict set divide_factor_dict   rx_transfer_clk2_pipe_g1 [expr round([dict get $divide_factor_dict rx_transfer_clk2_pipe_g2] * 2)]

          # Remove original rx_transfer_clk2 from profile_clocks and freq dictionaries
          set list_of_rx_clkouts [dict get $profile_clocks rx_mode_clks]
          set rx_clkout2_index [lsearch $list_of_rx_clkouts rx_transfer_clk2]
          if {$rx_clkout2_index < 0} {
            if {$native_debug == 1} {
              post_message -type warning "IP SDC: Cannot find key rx_transfer_clk2 while creating PIPE clocks in list $list_of_rx_clkouts"
            }
          } else {
            dict set profile_clocks rx_mode_clks [lreplace $list_of_rx_clkouts $rx_clkout_index $rx_clkout_index]
          }
          set multiply_factor_dict [dict remove $multiply_factor_dict rx_transfer_clk2]
          set divide_factor_dict   [dict remove $divide_factor_dict   rx_transfer_clk2]

        } else {
          # RX PIPE Gen2
          dict lappend profile_clocks rx_mode_clks rx_clkout2_pipe_g2
          dict set multiply_factor_dict rx_clkout2_pipe_g2 [dict get $multiply_factor_dict rx_clkout2]
          dict set divide_factor_dict   rx_clkout2_pipe_g2 [dict get $divide_factor_dict   rx_clkout2]

          # RX PIPE Gen1
          dict lappend profile_clocks rx_mode_clks rx_clkout2_pipe_g1
          dict set multiply_factor_dict rx_clkout2_pipe_g1 [dict get $multiply_factor_dict rx_clkout2_pipe_g2]
          dict set divide_factor_dict   rx_clkout2_pipe_g1 [expr round([dict get $divide_factor_dict rx_clkout2_pipe_g2] * 2)]

          # Remove original rx_clkout from profile_clocks and freq dictionaries
          set list_of_rx_clkouts [dict get $profile_clocks rx_mode_clks]
          set rx_clkout2_index [lsearch $list_of_rx_clkouts rx_clkout2]
          if {$rx_clkout2_index < 0} {
            if {$native_debug == 1} {
              post_message -type warning "IP SDC: Cannot find key rx_clkout2 while creating PIPE clocks in list $list_of_rx_clkouts"
            }
          } else {
            dict set profile_clocks rx_mode_clks [lreplace $list_of_rx_clkouts $rx_clkout2_index $rx_clkout2_index]
          }
          #set freq [dict remove $freq rx_clkout2]
          set multiply_factor_dict [dict remove $multiply_factor_dict rx_clkout2]
          set divide_factor_dict   [dict remove $divide_factor_dict   rx_clkout2]

        }
      }

      if {$native_debug == 1} {
        post_message -type info "IP SDC: RX mode clocks - [dict get $profile_clocks rx_mode_clks]"
      }

    } ; # if pipe_gen2 || pipe_gen3

    # -------------------------------------------------------------------------------
    # PIPE Gen3 clock
    # -------------------------------------------------------------------------------
    if {$protocol_mode == "pipe_g3"} {

      dict lappend profile_clocks tx_mode_clks tx_clkout_pipe_g3
      dict set multiply_factor_dict tx_clkout_pipe_g3 [expr round([dict get $multiply_factor_dict tx_clkout_pipe_g2] * 2)]
      dict set divide_factor_dict   tx_clkout_pipe_g3 [dict get $divide_factor_dict tx_clkout_pipe_g2]

      if {[dict get $native_phy_ip_params enable_port_tx_clkout2_profile$i] == 1} {
        dict lappend profile_clocks tx_mode_clks tx_clkout2_pipe_g3
        dict set multiply_factor_dict tx_clkout2_pipe_g3 [expr round([dict get $multiply_factor_dict tx_clkout2_pipe_g2] * 2)]
        dict set divide_factor_dict   tx_clkout2_pipe_g3 [dict get $divide_factor_dict tx_clkout2_pipe_g2]
      }

      if {[dict exists $profile_clocks rx_transfer_clk]} {
        dict lappend profile_clocks rx_mode_clks rx_transfer_clk_pipe_g3

      } else {
        dict lappend profile_clocks rx_mode_clks rx_clkout_pipe_g3
        dict set multiply_factor_dict rx_clkout_pipe_g3 [expr round([dict get $multiply_factor_dict rx_clkout_pipe_g2] * 2)]
        dict set divide_factor_dict   rx_clkout_pipe_g3 [dict get $divide_factor_dict rx_clkout_pipe_g2]
      }

      if {[dict get $native_phy_ip_params enable_port_rx_clkout2_profile$i] == 1} {
        if {[dict exists $profile_clocks rx_transfer_clk2]} {
          dict lappend profile_clocks rx_mode_clks rx_transfer_clk2_pipe_g3  
          dict set multiply_factor_dict rx_transfer_clk2_pipe_g3 [expr round([dict get $multiply_factor_dict rx_transfer_clk2_pipe_g2] * 2)]
          dict set divide_factor_dict   rx_transfer_clk2_pipe_g3 [dict get $divide_factor_dict rx_transfer_clk2_pipe_g2]

        } else {
          dict lappend profile_clocks rx_mode_clks rx_clkout2_pipe_g3
          dict set multiply_factor_dict rx_clkout2_pipe_g3 [expr round([dict get $multiply_factor_dict rx_clkout2_pipe_g2] * 2)]
          dict set divide_factor_dict   rx_clkout2_pipe_g3 [dict get $divide_factor_dict rx_clkout2_pipe_g2]

        }
      }
    }

    if { $native_debug == 1 } {
      dict for {key clocks} $profile_clocks {
        post_message -type info "IP SDC: Profile Clocks are $key: $clocks"
      }
    }

    # ----------------------------------------------------------------------------- #
    # --- Round the clock frequencies to 6 decimal places or less               --- #
    # ----------------------------------------------------------------------------- #
    dict for {clk freq_clk} $freq {
      dict set freq $clk [expr (round($freq_clk*1000000)/1000000.0)]
    }

    # ----------------------------------------------------------------------------- #
    # --- Create clocks for each mode                                           --- #
    # ----------------------------------------------------------------------------- #
    if {$native_debug == 1} {
      post_message -type info "========================================================================================"
      post_message -type info "IP SDC: Creating HSSI clocks for each channel"
    }

    dict for {mode mode_clks} $profile_clocks {
      set list_of_clk_names [list]

      if {$native_debug == 1} {
        post_message -type info "----------------------------------------------------------------------------------------"
        post_message -type info "IP SDC: Creating HSSI clocks for each channel in $mode group"
      }

      set list_of_clk_names [native_prepare_to_create_clocks_all_ch_5rlvnya $inst $num_channels $mode $mode_clks $profile_cnt $i $alt_xcvr_native_s10_pins $freq $multiply_factor_dict $divide_factor_dict $all_profile_clocks_names]
      dict set all_profile_clocks_names $i $mode [join [lsort -dictionary $list_of_clk_names]]

      if {$native_debug == 1} {
        post_message -type info "IP SDC: All Profile $i clocks for $mode: [dict get $all_profile_clocks_names $i $mode]"
      }
    } ; # dict for {mode mode_clks}


    # ----------------------------------------------------------------------------- #
    # --- Set async clock group for PIPE clocks                                 --- #
    # ----------------------------------------------------------------------------- #
    if {$protocol_mode == "pipe_g2" || $protocol_mode == "pipe_g3"} {
      if { $native_debug } {
        post_message -type info "========================================================================================"
        post_message -type info "IP SDC: Setting async clock groups for PIPE clocks"
      }

      set arg ""
      set curr_profile_clock_names [dict get $all_profile_clocks_names $i] 

      # Construct the arguments for set_clock_groups 
      # Template: set_clock_groups -asynchronous -group {<profile0 clks>} -group {<profile1 clks>} ... 
      for {set j 1} {$j < 3} {incr j} {
        set list_pipe_clk_names ""

        dict for {mode clk_mode_names} $curr_profile_clock_names {
          if {$mode == "tx_mode_clks" || $mode == "rx_mode_clks"} {

            set pipe_regexp "*_pipe_g$j*"
            set pipe_clk_names [lsearch -all -inline $clk_mode_names $pipe_regexp]

            if {$pipe_clk_names != ""} {
              set list_pipe_clk_names [concat $list_pipe_clk_names $pipe_clk_names]
            } else {
              if { $native_debug } {
                post_message -type warning "IP SDC: Cannot match regexp $pipe_regexp with clock names in list $clk_mode_names"
              }
            }
          }
        }
        set group "-group "
        set arg [concat $arg $group] 
        set arg [concat $arg "{$list_pipe_clk_names}"]
      }

      if {$protocol_mode == "pipe_g3"} {
        set list_pipe_clk_names ""

        dict for {mode clk_mode_names} $curr_profile_clock_names {
          if {$mode == "tx_mode_clks" || $mode == "rx_mode_clks"} {

            set pipe_regexp "*_pipe_g3*"
            set pipe_clk_names [lsearch -all -inline $clk_mode_names $pipe_regexp]

            if {$pipe_clk_names != ""} {
              set list_pipe_clk_names [concat $list_pipe_clk_names $pipe_clk_names]
            } else {
              if { $native_debug } {
                post_message -type warning "IP SDC: Cannot match regexp $pipe_regexp with clock names in list $clk_mode_names"
              }
            }
          }
        }
        set group "-group "
        set arg [concat $arg $group] 
        set arg [concat $arg "{$list_pipe_clk_names}"]
      }

      set cmd ""
      set cmd [concat $cmd "set_clock_groups -physically_exclusive "]
      set cmd [concat $cmd $arg]
      eval $cmd

      if { $native_debug } {
        post_message -type info "IP SDC: Setting async clock groups for PIPE clocks with command $cmd"
      }
    }

    #--------------------------------------------- #
    #---                                       --- #
    #--- MAX_SKEW_CONSTRAINT FOR BONDED MODE   --- #
    #---                                       --- #
    #--------------------------------------------- #
    if {[dict get $native_phy_ip_params bonded_mode_profile$i] == "pma_pcs"} {
      if { $native_debug } {
        post_message -type info "========================================================================================"
        post_message -type info "IP SDC: Setting max skew constraints for TX digital resets in PMA-PCS bonded mode"
      }

      # PMA and PCS resets need half the transfer clock period
      # Adapter resets need half the PMA parallel clock period
      set pma_parallel_clk_max_skew_value [expr ((1/($pma_parallel_clock / $byte_ser)) * 1000) / 2]
      set tx_transfer_clk_max_skew_value  [expr ((1/($tx_transfer_clk_freq / $byte_ser)) * 1000) / 2]
      set rx_transfer_clk_max_skew_value  [expr ((1/($rx_transfer_clk_freq / $byte_ser)) * 1000) / 2]

      # Round the clock frequencies to 6 decimal places or less
      set pma_parallel_clk_max_skew_value [expr (round($pma_parallel_clk_max_skew_value*1000)/1000.0)]
      set tx_transfer_clk_max_skew_value  [expr (round($tx_transfer_clk_max_skew_value*1000)/1000.0)]
      set rx_transfer_clk_max_skew_value  [expr (round($rx_transfer_clk_max_skew_value*1000)/1000.0)]

      # -------------------------------------------------------------------------------
      # TX set_max_skew
      # -------------------------------------------------------------------------------
      # Set max skew constraint for TX analog and digital resets when bonded
      set tx_analog_reset_reg_col         [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.tx_anlg_reset_seq|reset_out_stage*]
      set tx_aib_reset_out_stage_reg_col  [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.tx_dig_reset_seq|aib_reset_out_stage*]
      set tx_pcs_reset_out_stage_reg_col  [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.tx_dig_reset_seq|pcs_reset_out_stage*]
      set tx_transfer_clk_reg_col         [get_registers -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~*aibadpt__aib_fabric_tx_transfer_clk.reg]
      set tx_pld_adapter_tx_pld_rst_n_col [get_pins -nowarn -compat g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_adapter_tx_pld_rst_n]

      # TX PMA
      if {[get_collection_size $tx_analog_reset_reg_col] > 0 && [dict exist $all_profile_clocks_names $i tx_internal_div_reg_clks] && [get_collection_size $tx_transfer_clk_reg_col] > 0} {
        set_max_skew -exclude to_clock -from $tx_analog_reset_reg_col -to $tx_transfer_clk_reg_col $tx_transfer_clk_max_skew_value -nowarn
      }

      # TX Adapter
      if {[get_collection_size $tx_aib_reset_out_stage_reg_col] > 0 && [get_collection_size $tx_pld_adapter_tx_pld_rst_n_col] > 0} {
        set_max_skew -exclude to_clock -from $tx_aib_reset_out_stage_reg_col -to $tx_pld_adapter_tx_pld_rst_n_col $pma_parallel_clk_max_skew_value -nowarn
      }

      # TX PCS
      if {[get_collection_size $tx_pcs_reset_out_stage_reg_col] > 0 && [dict exist $all_profile_clocks_names $i tx_internal_div_reg_clks] && [get_collection_size $tx_transfer_clk_reg_col] > 0} {
        set_max_skew -exclude to_clock -from $tx_pcs_reset_out_stage_reg_col -to $tx_transfer_clk_reg_col $tx_transfer_clk_max_skew_value -nowarn
      }

      # -------------------------------------------------------------------------------
      # RX set_max_skew
      # -------------------------------------------------------------------------------
      # Set max skew constraint for RX analog and digital resets when bonded
      set rx_analog_reset_reg_col         [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.rx_anlg_reset_seq|reset_out_stage*]
      set rx_aib_reset_out_stage_reg_col  [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.rx_dig_reset_seq|aib_reset_out_stage*]
      set rx_pcs_reset_out_stage_reg_col  [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.rx_dig_reset_seq|pcs_reset_out_stage*]
      set rx_transfer_clk_reg_col         [get_registers -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx~*aibadpt__aib_fabric_rx_transfer_clk.reg]
      set rx_pld_adapter_rx_pld_rst_n_col [get_pins -nowarn -compat g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|pld_adapter_rx_pld_rst_n]

      # RX PMA
      if {[get_collection_size $rx_analog_reset_reg_col] > 0 && [dict exist $all_profile_clocks_names $i rx_internal_div_reg_clks] && [get_collection_size $rx_transfer_clk_reg_col] > 0} {
        set_max_skew -exclude to_clock -from $rx_analog_reset_reg_col -to $rx_transfer_clk_reg_col $rx_transfer_clk_max_skew_value -nowarn
      }

      # RX Adapter
      if {[get_collection_size $rx_aib_reset_out_stage_reg_col] > 0 && [get_collection_size $rx_pld_adapter_rx_pld_rst_n_col] > 0} {
        set_max_skew -exclude to_clock -from $rx_aib_reset_out_stage_reg_col -to $rx_pld_adapter_rx_pld_rst_n_col $pma_parallel_clk_max_skew_value -nowarn
      }

      # RX PCS
      if {[get_collection_size $rx_pcs_reset_out_stage_reg_col] > 0 && [dict exist $all_profile_clocks_names $i rx_internal_div_reg_clks] && [get_collection_size $rx_transfer_clk_reg_col] > 0} {
        set_max_skew -exclude to_clock -from $rx_pcs_reset_out_stage_reg_col -to $rx_transfer_clk_reg_col $rx_transfer_clk_max_skew_value -nowarn
      }

    }


    #-------------------------------------------------- #
    #---                                            --- #
    #--- DISABLE MIN_PULSE_WIDTH CHECK              --- #
    #---                                            --- #
    #-------------------------------------------------- #
    # Disable min_width_pulse for TX source clocks
    if {[dict exists $all_profile_clocks_names $i tx_source_clks]} {
      set tx_source_clks_list [dict get $all_profile_clocks_names $i tx_source_clks]
      foreach tx_src_clk $tx_source_clks_list {
        disable_min_pulse_width $tx_src_clk
      }
    }

    # Disable min_width_pulse for RX source clocks
    if {[dict exists $all_profile_clocks_names $i rx_source_clks]} {
      set rx_source_clks_list [dict get $all_profile_clocks_names $i rx_source_clks]
      foreach rx_src_clk $rx_source_clks_list {
        disable_min_pulse_width $rx_src_clk
      }
    }


    #-------------------------------------------------- #
    #---                                            --- #
    #--- CLOCK DISTORTION ALONG CLOCK PATH          --- #
    #---                                            --- #
    #-------------------------------------------------- #
  
    # (Cr IO Buffer+EMIB)(3%)+ Nadder IO Buffer)(3%) + (Nadder Adapter)(3%)
    # (Nadder Adapter)(3%) already distortion is accounted for in HSSI timing models
  
    # -------------------------------------------------------------------------------
    # TX clock uncertainty on output parallel XCVR clocks
    # -------------------------------------------------------------------------------
    if { [dict exists $all_profile_clocks_names $i tx_mode_clks] } {
      
      set tx_mode_clks_list [dict get $all_profile_clocks_names $i tx_mode_clks]
  
      foreach tx_clk_name $tx_mode_clks_list {
  
        set tx_clkout_period [get_clock_info -period $tx_clk_name]
  
        # (Cr IO Buffer+EMIB)(3%)+ Nadder IO Buffer)(3%)
        set tx_clkout_uncertainty_percent 0.06

        # Limit to 3 digits after the decimal to avoid warnings
        set tx_clkout_uncertainty_final_value [expr double($tx_clkout_uncertainty_percent*$tx_clkout_period)]
        set tx_clkout_uncertainty_final_value [expr round($tx_clkout_uncertainty_final_value  * 1000)]
        set tx_clkout_uncertainty_final_value [expr double($tx_clkout_uncertainty_final_value / 1000.0)]
  
        # (Cr IO Buffer+EMIB)(3%)+ Nadder IO Buffer)(3%) 
        # No need for rise_from/rise_to to other clocks since the rise edge should still be ideal, and it's only the fall edge that has uncertainty.
        # Distortion does not affect same-edge transfers. Only high-frequency jitter effects cause issues to same-edge transfers as common-clock-pessimism-removal would fix any issues.
        set tx_mode_other_clks     [remove_from_collection [get_clocks  $tx_mode_clks_list] [get_clocks $tx_clk_name]]
        if { [get_collection_size $tx_mode_other_clks] > 0} {
             set_clock_uncertainty -add -fall_from $tx_clk_name -to    $tx_mode_other_clks   $tx_clkout_uncertainty_final_value
             set_clock_uncertainty -add -fall_to   $tx_clk_name -from  $tx_mode_other_clks   $tx_clkout_uncertainty_final_value
        }
 
      }
    }
  
    # -------------------------------------------------------------------------------
    # RX clock uncertainty on output parallel XCVR clocks
    # -------------------------------------------------------------------------------
    if { [dict exists $all_profile_clocks_names $i rx_mode_clks] } {
      
      set rx_mode_clks_list [dict get $all_profile_clocks_names $i rx_mode_clks]

     # workaround when RX FIFO MODE is register and reconfig profile > 1 due to object not matched
     if  {[dict get $native_phy_ip_params rx_fifo_mode_profile$i] == "Register" && $rx_clkout_sel == "pcs_x2_clkout" && $profile_cnt > 1} {
        } else {
      foreach rx_clk_name $rx_mode_clks_list {
  
        set rx_clkout_period [get_clock_info -period $rx_clk_name]
  
        # (Cr IO Buffer+EMIB)(3%)+ Nadder IO Buffer)(3%)
        set rx_clkout_uncertainty_percent 0.06

        # Limit to 3 digits after the decimal to avoid warnings
        set rx_clkout_uncertainty_final_value [expr double($rx_clkout_uncertainty_percent*$rx_clkout_period)]
        set rx_clkout_uncertainty_final_value [expr round($rx_clkout_uncertainty_final_value  * 1000)]
        set rx_clkout_uncertainty_final_value [expr double($rx_clkout_uncertainty_final_value / 1000.0)]

        # Distortion from DCC circuit is only valid on opposite-edge transfers (i.e. rise-fall and fall-rise)
        set_clock_uncertainty -add -rise_from $rx_clk_name -fall_to $rx_clk_name $rx_clkout_uncertainty_final_value
        set_clock_uncertainty -add -fall_from $rx_clk_name -rise_to $rx_clk_name $rx_clkout_uncertainty_final_value
  
        # (Cr IO Buffer+EMIB)(3%)+ Nadder IO Buffer)(3%)
        # No need for rise_from/rise_to to other clocks since the rise edge should still be ideal, and it's only the fall edge that has uncertainty.
        # Distortion does not affect same-edge transfers. Only high-frequency jitter effects cause issues to same-edge transfers as common-clock-pessimism-removal would fix any issues. 
        set rx_mode_other_clks     [remove_from_collection [get_clocks  $rx_mode_clks_list] [get_clocks $rx_clk_name]]
        if { [get_collection_size $rx_mode_other_clks] > 0} {
             set_clock_uncertainty -add -fall_from $rx_clk_name -to    $rx_mode_other_clks   $rx_clkout_uncertainty_final_value
             set_clock_uncertainty -add -fall_to   $rx_clk_name -from  $rx_mode_other_clks   $rx_clkout_uncertainty_final_value
        }
       }
      }
    }


    #-------------------------------------------------- #
    #---                                            --- #
    #--- SET_FALSE_PATH for TX and RX BONDING       --- #
    #---                                            --- #
    #-------------------------------------------------- #

    # Remove all paths for RX bonding signals if in PIPE mode (Native PCIe IP covers the case for PCIe)
    if {$protocol_mode == "pipe_g1" || $protocol_mode == "pipe_g2" || $protocol_mode == "pipe_g3"} {

      set aib_fabric_rx_transfer_clk_col [get_registers    -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx~aib_fabric_rx_transfer_clk.reg]
      set bond_rx_fifo_us_out_wren_col   [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_us_out_wren]
      set bond_rx_fifo_ds_in_wren_col    [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_ds_in_wren]
      set bond_rx_fifo_ds_out_wren_col   [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_ds_out_wren]
      set bond_rx_fifo_us_in_wren_col    [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_us_in_wren]

      set pld_rx_clk_dcm_reg_col       [get_registers    -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx~pld_rx_clk*_dcm.reg]
      set bond_rx_fifo_us_out_rden_col [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_us_out_rden]
      set bond_rx_fifo_ds_in_rden_col  [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_ds_in_rden]
      set bond_rx_fifo_ds_out_rden_col [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_ds_out_rden]
      set bond_rx_fifo_us_in_rden_col  [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_us_in_rden]

      if {[get_collection_size $aib_fabric_rx_transfer_clk_col] > 0 &&  [get_collection_size $bond_rx_fifo_us_out_wren_col] > 0 && [get_collection_size $bond_rx_fifo_ds_in_wren_col] > 0} {    
        set_false_path -from $aib_fabric_rx_transfer_clk_col -through $bond_rx_fifo_us_out_wren_col -through $bond_rx_fifo_ds_in_wren_col -to $aib_fabric_rx_transfer_clk_col
      }

      if {[get_collection_size $aib_fabric_rx_transfer_clk_col] > 0 &&  [get_collection_size $bond_rx_fifo_ds_out_wren_col] > 0 && [get_collection_size $bond_rx_fifo_us_in_wren_col] > 0} {    
        set_false_path -from $aib_fabric_rx_transfer_clk_col -through $bond_rx_fifo_ds_out_wren_col -through $bond_rx_fifo_us_in_wren_col -to $aib_fabric_rx_transfer_clk_col
      }

      if {[get_collection_size $pld_rx_clk_dcm_reg_col] > 0 &&  [get_collection_size $bond_rx_fifo_us_out_rden_col] > 0 && [get_collection_size $bond_rx_fifo_ds_in_rden_col] > 0} {    
        set_false_path -from $pld_rx_clk_dcm_reg_col  -through $bond_rx_fifo_us_out_rden_col -through $bond_rx_fifo_ds_in_rden_col -to $pld_rx_clk_dcm_reg_col
      }

      if {[get_collection_size $pld_rx_clk_dcm_reg_col] > 0 &&  [get_collection_size $bond_rx_fifo_ds_out_rden_col] > 0 && [get_collection_size $bond_rx_fifo_us_in_rden_col] > 0} {    
        set_false_path -from  $pld_rx_clk_dcm_reg_col -through $bond_rx_fifo_ds_out_rden_col -through $bond_rx_fifo_us_in_rden_col -to $pld_rx_clk_dcm_reg_col
      }

    }

  } ; # foreach profile


  #--------------------------------------------- #
  #---                                       --- #
  #--- Adjusting the min pulse width for     --- #
  #--- coreclkin2 requirement to be          --- #
  #--- frequency-dependent                   --- #
  #---                                       --- #
  #--------------------------------------------- #
  
  # Create dictionary of all the clocks and their nodes
  set min_pulse_all_clocks_list [all_clocks]
  set min_pulse_all_clocks_nodes_dict [dict create]
  
  foreach_in_collection clk $min_pulse_all_clocks_list {
    set clk_name [get_clock_info -name $clk]
    # Check if clock is declared, but NOT defined (i.e. create_clock or create_generated_clock has NOT been used yet)
    if { [is_clock_defined $clk_name] == 1 } {
      set clk_node_col [get_clock_info -targets $clk_name]
	
      foreach_in_collection clk_node $clk_node_col {
        set clk_node_name [get_node_info -name $clk_node]
        dict set min_pulse_all_clocks_nodes_dict $clk_node_name $clk_name
      }
    }
  }
   
  # -------------------------------------------------------------------------------
  # TX coreclkin2
  # -------------------------------------------------------------------------------
  set tx_coreclkin2_col [get_pins -nowarn -compat g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_tx_clk2_dcm]

  # Get fanins for tx_coreclkin2
  if {[get_collection_size $tx_coreclkin2_col] > 0} {
    set tx_coreclkin_fanin_col [get_fanins -clock -stop_at_clocks $tx_coreclkin2_col]
	
    # Find clock name on the fanin
    if {[get_collection_size $tx_coreclkin_fanin_col]} {
	
      foreach_in_collection fanin_node $tx_coreclkin_fanin_col {
        set fanin_node_name [get_node_info -name $fanin_node]

	      if {[dict exists $min_pulse_all_clocks_nodes_dict $fanin_node_name]} {
		      set fanin_clock_name [dict get $min_pulse_all_clocks_nodes_dict $fanin_node_name]
         set_active_clocks [remove_from_collection [get_active_clocks] [get_clocks $fanin_clock_name]]
          
          # Remap any backward slashes '' in the pins
          set fanin_clock_name [string map {\\ \\\\} $fanin_clock_name]

          # Adjust the min pulse width requirement based on frequency
          add_ddr_report_command "native_check_special_min_pulse_5rlvnya $fanin_clock_name"
        } elseif {[regexp {aib_tx_internal_div\.reg$} $fanin_node_name]} {
              post_message -type warning "can't find clock expected to feed transceiver. Please ensure the .ip of providing clock to transceiver is listed in the QSF or QIP before the .ip of the transceiver."   
        }
      }
    }
  }


  # -------------------------------------------------------------------------------
  # RX coreclkin2
  # -------------------------------------------------------------------------------
  set rx_coreclkin2_col [get_pins -nowarn -compat g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|pld_rx_clk2_dcm]

  # Get fanins for rx_coreclkin2
  if {[get_collection_size $rx_coreclkin2_col] > 0} {
    set rx_coreclkin_fanin_col [get_fanins -clock -stop_at_clocks $rx_coreclkin2_col]
	
    # Find clock name on the fanin
    if {[get_collection_size $rx_coreclkin_fanin_col]} {
	
      foreach_in_collection fanin_node $rx_coreclkin_fanin_col {
        set fanin_node_name [get_node_info -name $fanin_node]

	      if {[dict exists $min_pulse_all_clocks_nodes_dict $fanin_node_name]} {
		      set fanin_clock_name [dict get $min_pulse_all_clocks_nodes_dict $fanin_node_name]
          set_active_clocks [remove_from_collection [get_active_clocks] [get_clocks $fanin_clock_name]]
         
          # Remap any backward slashes '' in the pins
          set fanin_clock_name [string map {\\ \\\\} $fanin_clock_name]

          # Adjust the min pulse width requirement based on frequency
          add_ddr_report_command "native_check_special_min_pulse_5rlvnya $fanin_clock_name"
        } elseif {[regexp {aib_rx_internal_div\.reg$} $fanin_node_name]} {
              post_message -type warning "can't find clock expected to feed transceiver. Please ensure the .ip of providing clock to transceiver is listed in the QSF or QIP before the .ip of the transceiver."   
        }
      }
    }
  }


  #--------------------------------------------- #
  #---                                       --- #
  #--- ASYNC CLOCK GROUP FOR RECONFIGURATION --- #
  #---                                       --- #
  #--------------------------------------------- #
  if {$profile_cnt > 1 } {
    if { $native_debug == 1 } {
      post_message -type info "========================================================================================"
      post_message -type info "IP SDC: Setting async clock groups for multi-profile"
    }

    set arg ""

    for {set i 0} {$i < $profile_cnt} {incr i} {
      set profile_clk_names ""

      dict for {mode clk_name} $profile_clocks {
        # Construct the arguments for set_clock_groups 
        # Template: set_clock_groups -asynchronous -group {<profile0 clks>} -group {<profile1 clks>} ...
        if {[dict exists $all_profile_clocks_names $i $mode]} {
          set profile_clk_names [concat $profile_clk_names [dict get $all_profile_clocks_names $i $mode]]
        }
      }

      set profile_clk_names [join $profile_clk_names]
      set group "-group "
      set arg [concat $arg $group] 
      set arg [concat $arg "{$profile_clk_names}"]

      if { $native_debug } {
        post_message -type info "IP SDC: Profile $i clocks: $profile_clk_names"
      }
    }

    set cmd ""
    set cmd [concat $cmd "set_clock_groups -physically_exclusive "]
    set cmd [concat $cmd $arg]
    eval $cmd

    if { $native_debug } {
      post_message -type info "IP SDC: Setting async clock groups for reconfiguration: $cmd"
    }

  }


  #-------------------------------------------------- #
  #---                                            --- #
  #--- Internal loopback path                     --- #
  #---                                            --- #
  #-------------------------------------------------- #
  set aib_fabric_pma_aib_tx_clk_col  [get_registers -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~aib_fabric_pma_aib_tx_clk.reg]
  set aib_fabric_tx_data_lpbk_col    [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|aib_fabric_tx_data_lpbk*]
  set aib_fabric_rx_transfer_clk_col [get_registers -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx~aib_fabric_rx_transfer_clk.reg]
  set pld_tx_clk2_dcm_reg_col        [get_registers -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~pld_tx_clk2_dcm.reg]
  set pld_tx_clk1_dcm_reg_col        [get_registers -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~pld_tx_clk1_dcm.reg]

  # Cut the paths for the internal loopback paths
  if {[get_collection_size $aib_fabric_pma_aib_tx_clk_col] > 0 && [get_collection_size $aib_fabric_tx_data_lpbk_col] > 0 && [get_collection_size $aib_fabric_rx_transfer_clk_col] > 0} {
    set_false_path -from $aib_fabric_pma_aib_tx_clk_col -through $aib_fabric_tx_data_lpbk_col -to $aib_fabric_rx_transfer_clk_col
  }

  # Cut paths for internal loopback paths when bonding is enabled
  if {[get_collection_size $pld_tx_clk2_dcm_reg_col] > 0 && [get_collection_size $aib_fabric_tx_data_lpbk_col] > 0 && [get_collection_size $aib_fabric_rx_transfer_clk_col] > 0} {
    set_false_path -from $pld_tx_clk2_dcm_reg_col -through $aib_fabric_tx_data_lpbk_col -to $aib_fabric_rx_transfer_clk_col
  }
  if {[get_collection_size $pld_tx_clk1_dcm_reg_col] > 0 && [get_collection_size $aib_fabric_tx_data_lpbk_col] > 0 && [get_collection_size $aib_fabric_rx_transfer_clk_col] > 0} {
    set_false_path -from $pld_tx_clk1_dcm_reg_col -through $aib_fabric_tx_data_lpbk_col -to $aib_fabric_rx_transfer_clk_col
  }


    # -------------------------------------------------------------------------------------------------- #
    # --- set false path for adjacent channel connections introduced by clock skew control modeling  --- #
    # -------------------------------------------------------------------------------------------------- #
    if { $tx_enabled_on_any_profile && $max_num_channels > 1 } {
        set aib_pld_tx_clk_pin_col [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_tx_clk?_dcm] 
        set aib_pld_tx_clk_pin_col  [add_to_collection $aib_pld_tx_clk_pin_col [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_tx_clk?_rowclk] ]
        set aib_tx_internal_div_reg_col [get_registers -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~aib_tx_internal_div.reg]
        set aib_fabric_transfer_clk_col [get_registers -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~*aib_fabric_tx_transfer_clk.reg]
        if { [get_collection_size $aib_fabric_transfer_clk_col] > 0 } {
          if { [get_collection_size $aib_tx_internal_div_reg_col] > 0 } {
             set_false_path -from $aib_tx_internal_div_reg_col -to $aib_fabric_transfer_clk_col 
          }
          if { [get_collection_size $aib_pld_tx_clk_pin_col] > 0 } {
            set_false_path -through $aib_pld_tx_clk_pin_col -to $aib_fabric_transfer_clk_col
          }
        }
    } ; # tx_enabled_on_any_profile && max_num_channels > 1 
      


  #--------------------------------------------- #
  #---                                       --- #
  #--- SET_FALSE_PATH to reset synchronizers --- #
  #---                                       --- #
  #--------------------------------------------- #
  
  # TX and RX analog reset synchronizers
  set tx_analog_reset_resync_reg [get_keepers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.tx_anlg_reset_seq|g_anlg_trs_inst[*].reset_synchronizers|resync_chains[0].synchronizer_nocut|din_s1]                                                                                                      
  set tx_analog_reset_resync_reg [add_to_collection $tx_analog_reset_resync_reg [get_keepers -nowarn  g_ehip_reset.alt_xcvr_native_anlg_reset_seq_wrapper_inst|g_trs.tx_anlg_reset_seq|g_anlg_trs_inst[*].reset_synchronizers|resync_chains[0].synchronizer_nocut|din_s1] ]

  set rx_analog_reset_resync_reg [get_keepers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.rx_anlg_reset_seq|g_anlg_trs_inst[*].reset_synchronizers|resync_chains[0].synchronizer_nocut|din_s1]
  set rx_analog_reset_resync_reg [add_to_collection $rx_analog_reset_resync_reg [get_keepers -nowarn  g_ehip_reset.alt_xcvr_native_anlg_reset_seq_wrapper_inst|g_trs.rx_anlg_reset_seq|g_anlg_trs_inst[*].reset_synchronizers|resync_chains[0].synchronizer_nocut|din_s1] ]

  # TX and RX digital reset synchronizers
  set tx_digital_reset_resync_reg             [get_keepers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.tx_dig_reset_seq|reset_synchronizers|resync_chains[*].synchronizer_nocut|din_s1]
  set tx_digital_transfer_ready_resync_reg    [get_keepers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.tx_dig_reset_seq|transfer_ready_synchronizers|resync_chains[*].synchronizer_nocut|din_s1]
  set tx_digital_release_aib_first_resync_reg [get_keepers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.tx_dig_reset_seq|release_aib_first_synchronizers|resync_chains[0].synchronizer_nocut|din_s1]
  set rx_digital_reset_resync_reg             [get_keepers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.rx_dig_reset_seq|reset_synchronizers|resync_chains[*].synchronizer_nocut|din_s1]
  set rx_digital_transfer_ready_resync_reg    [get_keepers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.rx_dig_reset_seq|transfer_ready_synchronizers|resync_chains[*].synchronizer_nocut|din_s1]
  set rx_digital_release_aib_first_resync_reg [get_keepers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.rx_dig_reset_seq|release_aib_first_synchronizers|resync_chains[0].synchronizer_nocut|din_s1]
    
  # TX reset synchronizers
  if {[dict get $native_phy_ip_params tx_enable_profile0]} {

    # TX analog resets
    if {[get_collection_size $tx_analog_reset_resync_reg] > 0} {
      foreach_in_collection resync_reg $tx_analog_reset_resync_reg {
        set_false_path -to $resync_reg
      }
    }

    # TX digital resets
    if {[get_collection_size $tx_digital_reset_resync_reg] > 0} {
      foreach_in_collection resync_reg $tx_digital_reset_resync_reg {
        set_false_path -to $resync_reg
      }
    }

    if {[get_collection_size $tx_digital_transfer_ready_resync_reg] > 0} {
      foreach_in_collection resync_reg $tx_digital_transfer_ready_resync_reg {
        set_false_path -to $resync_reg
      }
    }

    if {[get_collection_size $tx_digital_release_aib_first_resync_reg] > 0} {
      foreach_in_collection resync_reg $tx_digital_release_aib_first_resync_reg {
        set_false_path -to $resync_reg
      }
    }
  }

  # RX reset synchronizers
  if {[dict get $native_phy_ip_params rx_enable_profile0]} {

    # RX analog resets
     if {[get_collection_size $rx_analog_reset_resync_reg] > 0} {
      foreach_in_collection resync_reg $rx_analog_reset_resync_reg {
        set_false_path -to $resync_reg
      }
    }

    # RX digital resets
    if {[get_collection_size $rx_digital_reset_resync_reg] > 0} {
      foreach_in_collection resync_reg $rx_digital_reset_resync_reg {
        set_false_path -to $resync_reg
      }
    }

    if {[get_collection_size $rx_digital_transfer_ready_resync_reg] > 0} {
      foreach_in_collection resync_reg $rx_digital_transfer_ready_resync_reg {
        set_false_path -to $resync_reg
      }
    }

    if {[get_collection_size $rx_digital_release_aib_first_resync_reg] > 0} {
      foreach_in_collection resync_reg $rx_digital_release_aib_first_resync_reg {
        set_false_path -to $resync_reg
      }
    }
  }


  # Early speed change reset synchronizers
  set early_spd_chng_reset_resync_reg [get_keepers -nowarn g_early_spd_chng_enable.pipe_early_spd_chng_inst|reset_n_synchronizers|resync_chains[0].synchronizer_nocut|din_s1]
  set early_spd_chng_reset_resync_reg [add_to_collection $early_spd_chng_reset_resync_reg [get_keepers -nowarn  g_early_spd_chng_enable.pipe_early_spd_chng_inst|reset_n_synchronizers|resync_chains[0].synchronizer_nocut|dreg*]]

  if {[get_collection_size $early_spd_chng_reset_resync_reg] > 0} {
    foreach_in_collection resync_reg $early_spd_chng_reset_resync_reg {
      set_false_path -to $resync_reg
    }
  }


  #  RX MAIB FIFO workaround in clk_comp mode for 10GBASER, reset synchronizers
  set rx_maib_wa_reset_resync_reg [get_keepers -nowarn xcvr_rx_maib_wa|g_chk_swap.rst_sync[*].reset_synchronizers|resync_chains[*].synchronizer_nocut|din_s1]
  if {[get_collection_size $rx_maib_wa_reset_resync_reg] > 0} {
      set_false_path -to $rx_maib_wa_reset_resync_reg
  }

  set rx_maib_wa_reset_resync_dreg [get_keepers -nowarn  xcvr_rx_maib_wa|g_chk_swap.rst_sync[*].reset_synchronizers|resync_chains[*].synchronizer_nocut|dreg*]
  set rx_maib_wa_reset_resync_clr_pins [get_pins -nowarn  xcvr_rx_maib_wa|g_chk_swap.rst_sync[*].reset_synchronizers|resync_chains[*].synchronizer_nocut|dreg*|clrn]
  if {[get_collection_size $rx_maib_wa_reset_resync_dreg] > 0} {
     set_false_path -through $rx_maib_wa_reset_resync_clr_pins -to $rx_maib_wa_reset_resync_dreg
  }


  #--------------------------------------------- #
  #---                                       --- #
  #--- MIN & MAX DELAYS FOR RESETS           --- #
  #---                                       --- #
  #--------------------------------------------- #

  if {[dict get $native_phy_ip_params tx_enable_profile0]} {

    # TX PMA resets
    set tx_analog_reset_reg  [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.tx_anlg_reset_seq|reset_out_stage*]
    set tx_pld_pma_reset_pin [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_pma_txpma_rstb]
    
    if {[get_collection_size $tx_analog_reset_reg] == 0} {
      if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find registers for TX analog resets"
      }

    } elseif {[get_collection_size $tx_pld_pma_reset_pin] == 0} {
      if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find TX PMA reset atom"
      }

    } else {
      set_max_delay -from $tx_analog_reset_reg -through $tx_pld_pma_reset_pin  200
      set_min_delay -from $tx_analog_reset_reg -through $tx_pld_pma_reset_pin -200
    }

    # TX PCS resets
    set tx_digital_pcs_reset_reg [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.tx_dig_reset_seq|pcs_reset_out_stage*]
    set tx_pld_pcs_reset_pin     [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_pcs_tx_pld_rst_n]

    if {[get_collection_size $tx_digital_pcs_reset_reg] == 0} {
       if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find TX digital PCS resets"
      }

    } elseif {[get_collection_size $tx_pld_pcs_reset_pin] == 0} {
       if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find TX PCS reset atom"
      }

    } else {
      set_max_delay -from $tx_digital_pcs_reset_reg -through $tx_pld_pcs_reset_pin  200
      set_min_delay -from $tx_digital_pcs_reset_reg -through $tx_pld_pcs_reset_pin -200
    }

    # TX AIB/adapter resets
    set tx_digital_aib_reset_reg [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.tx_dig_reset_seq|aib_reset_out_stage*]
    set tx_pld_adapter_reset_pin [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_adapter_tx_pld_rst_n]

    if {[get_collection_size $tx_digital_aib_reset_reg] == 0} {
       if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find TX digital AIB/adapter resets"
      }

    } elseif {[get_collection_size $tx_pld_adapter_reset_pin] == 0} {
      if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find TX AIB/adapter reset atom"
      }

    } else {
      set_max_delay -from $tx_digital_aib_reset_reg -through $tx_pld_adapter_reset_pin  200
      set_min_delay -from $tx_digital_aib_reset_reg -through $tx_pld_adapter_reset_pin -200
    }
  }

  if {[dict get $native_phy_ip_params rx_enable_profile0]} {

    # RX PMA resets
    set rx_analog_reset_reg  [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.rx_anlg_reset_seq|reset_out_stage*]
    set rx_pld_pma_reset_pin [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|pld_pma_rxpma_rstb]
    
    if {[get_collection_size $rx_analog_reset_reg] == 0} {
      if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find registers for RX analog resets"
      }

    } elseif {[get_collection_size $rx_pld_pma_reset_pin] == 0} {
      if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find RX PMA reset atom"
      }

    } else {
      set_max_delay -from $rx_analog_reset_reg -through $rx_pld_pma_reset_pin  200
      set_min_delay -from $rx_analog_reset_reg -through $rx_pld_pma_reset_pin -200
    }

    # RX PCS resets
    set rx_digital_pcs_reset_reg [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.rx_dig_reset_seq|pcs_reset_out_stage*]
    set rx_pld_pcs_reset_pin     [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|pld_pcs_rx_pld_rst_n]
    
    if {[get_collection_size $rx_digital_pcs_reset_reg] == 0} {
       if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find RX digital PCS resets"
      }

    } elseif {[get_collection_size $rx_pld_pcs_reset_pin] == 0} {
       if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find RX PCS reset atom"
      }

    } else {
      set_max_delay -from $rx_digital_pcs_reset_reg -through $rx_pld_pcs_reset_pin  200
      set_min_delay -from $rx_digital_pcs_reset_reg -through $rx_pld_pcs_reset_pin -200
    }

    # RX AIB/adapter resets
    set rx_digital_aib_reset_reg [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.rx_dig_reset_seq|aib_reset_out_stage*]
    set rx_pld_adapter_reset_pin [get_pins -compat -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|pld_adapter_rx_pld_rst_n]

    if {[get_collection_size $rx_digital_aib_reset_reg] == 0} {
       if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find RX digital AIB/adapter resets"
      }

    } elseif {[get_collection_size $rx_pld_adapter_reset_pin] == 0} {
      if {$native_debug == 1} {
        post_message -type warning "IP SDC: Could not find RX AIB/adapter reset atom"
      }

    } else {
      set_max_delay -from $rx_digital_aib_reset_reg -through $rx_pld_adapter_reset_pin  200
      set_min_delay -from $rx_digital_aib_reset_reg -through $rx_pld_adapter_reset_pin -200
    }
  }

  #--------------------------------------------- #
  #---                                       --- #
  #--- PRBS constraints                      --- #
  #---                                       --- #
  #--------------------------------------------- # 
  # Check that reconfiguration is enabled and soft logic for doing prbs bit and error accumulation when using the hard prbs generator and checker is enabled
  if {[dict get $native_phy_ip_params rcfg_enable_profile0] && [dict get $native_phy_ip_params set_prbs_soft_logic_enable_profile0]} {

    set prbs_path  "g_recal_*_rcfg_opt_logic.alt_xcvr_native_optional_rcfg_logic|g_optional_chnl_reconfig_logic[*].g_prbs_accumulators_enable.prbs_soft_accumulators"

    set prbs_soft_accumulators_rx_prbs_err_snapshot_col [get_registers -nowarn $prbs_path|rx_prbs_err_snapshot*]

    if { [get_collection_size $prbs_soft_accumulators_rx_prbs_err_snapshot_col] > 0 } {
      
      # When using the PRBS Error Accumulation logic, set multicycle constraints to reduce routing effor and congestion.
      set prbs_soft_accumulators_avmm_prbs_err_count_col [get_registers -nowarn $prbs_path|avmm_prbs_err_count*]
      set_max_delay -from $prbs_soft_accumulators_rx_prbs_err_snapshot_col -to $prbs_soft_accumulators_avmm_prbs_err_count_col 200
      set_min_delay -from $prbs_soft_accumulators_rx_prbs_err_snapshot_col -to $prbs_soft_accumulators_avmm_prbs_err_count_col -200
  
      # Set false paths for the asynchronous resets no-cut synchronizers
      set_false_path -through [get_pins -nowarn -compat  $prbs_path|rx_clk_reset_sync|resync_chains[0].synchronizer_nocut|din_s1|clrn] -to [get_registers -nowarn $prbs_path|rx_clk_reset_sync|resync_chains[0].synchronizer_nocut|din_s1]
      set_false_path -through [get_pins -nowarn -compat  $prbs_path|rx_clk_reset_sync|resync_chains[0].synchronizer_nocut|dreg*|clrn]  -to [get_registers -nowarn $prbs_path|rx_clk_reset_sync|resync_chains[0].synchronizer_nocut|dreg[?]]
                                                                          
      set embedded_debug_soft_csr_col [get_registers -nowarn g_recal_*_rcfg_opt_logic.alt_xcvr_native_optional_rcfg_logic|g_optional_chnl_reconfig_logic[*].g_avmm_csr_enabled.embedded_debug_soft_csr|g_prbs_reg_en*]
      set_false_path -from $embedded_debug_soft_csr_col -to [get_registers -nowarn $prbs_path|rx_clk_prbs_reset_sync|resync_chains[0].synchronizer_nocut|din_s1]
      set_false_path -from $embedded_debug_soft_csr_col -to [get_registers -nowarn $prbs_path|rx_clk_prbs_reset_sync|resync_chains[0].synchronizer_nocut|dreg[?]]

      set_false_path -through [get_pins -nowarn -compat $prbs_path|rx_clk_prbs_err_sync|resync_chains[0].synchronizer_nocut|din_s1|clrn] -to [get_registers -nowarn $prbs_path|rx_clk_prbs_err_sync|resync_chains[0].synchronizer_nocut|din_s1]
      set_false_path -through [get_pins -nowarn -compat $prbs_path|rx_clk_prbs_err_sync|resync_chains[0].synchronizer_nocut|dreg*|clrn] -to  [get_registers -nowarn $prbs_path|rx_clk_prbs_err_sync|resync_chains[0].synchronizer_nocut|dreg[?]]
      
      set_false_path -through [get_pins -nowarn -compat $prbs_path|rx_clk_prbs_done_sync|resync_chains[0].synchronizer_nocut|din_s1|clrn] -to [get_registers -nowarn $prbs_path|rx_clk_prbs_done_sync|resync_chains[0].synchronizer_nocut|din_s1]
      set_false_path -through [get_pins -nowarn -compat $prbs_path|rx_clk_prbs_done_sync|resync_chains[0].synchronizer_nocut|dreg*|clrn]  -to [get_registers -nowarn $prbs_path|rx_clk_prbs_done_sync|resync_chains[0].synchronizer_nocut|dreg[?]]
            
      # Set false paths for data no-cut synchronizers
      set_false_path -to [get_registers -nowarn $prbs_path|avmm_clk_prbs_done_sync|resync_chains[0].synchronizer_nocut|din_s1]
      set_false_path -to [get_registers -nowarn $prbs_path|avmm_clk_bit_count_edge|resync_chains[0].synchronizer_nocut|din_s1]

    } else {
      if {$native_debug == 1} {
        post_message -type warning "IP SDC: Reconfiguration and PRBS soft accumulators are enabled, but IP SDC is unable to find any matching registers for PRBS soft accumulators"
      }
    }
  }

  #--------------------------------------------- #
  #---                                       --- #
  #--- RX EIOS Protection  Constraints       --- #
  #---                                       --- #
  #--------------------------------------------- # 
  set eios_path  "g_recal_disable_rcfg_opt_logic.alt_xcvr_native_optional_rcfg_logic|g_eios_rp_enable.pcie_rx_eios_prot_inst"
  set eios_sync_din_col [get_registers -nowarn $eios_path|*_sync|din_s1]
  # Check if there are resync registers for EIOS
  if { [get_collection_size $eios_sync_din_col] > 0 } {
       # Set false paths for data no-cut synchronizers
       set_false_path -to $eios_sync_din_col    
  
    set eios_sync_nreset_col [get_registers -nowarn $eios_path|u_sync_nreset|din_s1]
    if { [get_collection_size $eios_sync_nreset_col] > 0 } {
      # Set false paths for the asynchronous resets no-cut synchronizers
      set_false_path -through [get_pins -nowarn -compat $eios_path|u_sync_nreset|din_s1|clrn] -to $eios_sync_nreset_col
      set_false_path -through [get_pins -nowarn -compat $eios_path|u_sync_nreset|dreg[?]|clrn] -to [get_registers -nowarn $eios_path|u_sync_nreset|dreg[?]]
    }                                                                        
  }


  #-------------------------------------------------- #
  #---                                            --- #
  #--- AVMM wrapper constraints                   --- #
  #---                                            --- #
  #-------------------------------------------------- #
  # Check that reconfiguration is enabled
  if {[dict get $native_phy_ip_params rcfg_enable_profile0]} {

    set ct2_xcvr_avmm_reset_clrn_col [get_pins -nowarn -compat g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct1_xcvr_avmm1|avmm_if_soft_logic[*].ct1_xcvr_avmm_soft_logic_inst|sync_r[?]|clrn]

    if { [get_collection_size $ct2_xcvr_avmm_reset_clrn_col] > 0 } {
      # Set false path to avmm_reset synchronizer
      set ct2_xcvr_avmm_reset_sync_reg_col [get_registers -nowarn g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct1_xcvr_avmm1|avmm_if_soft_logic[*].ct1_xcvr_avmm_soft_logic_inst|sync_r[?]]
      set_false_path -through $ct2_xcvr_avmm_reset_clrn_col -to $ct2_xcvr_avmm_reset_sync_reg_col
    } else {
      if {$native_debug == 1} {
        post_message -type warning "IP SDC: Reconfiguration is enabled, but IP SDC is unable to find any matching nodes for AVMM soft logic"
      }

    }
  }

  #-------------------------------------------------- #
  #---                                            --- #
  #--- SET_FALSE_PATH for MAIB ASYNC signals      --- #
  #---                                            --- #
  #-------------------------------------------------- #
  # Create a set of all asynchronous signals to be looped over for setting false paths
  # These signals are async input signals to Nadder Adapter
  set altera_xcvr_native_s10_async_signals {
    pld_pma_fpll_up_dn_lc_lf_rstn
    pld_pma_txdetectrx
    pld_ltr
    pld_pma_ltd_b
    pld_txelecidle
    pld_10g_krfec_rx_clr_errblk_cnt
    pld_10g_rx_clr_ber_count
    pld_10g_tx_bitslip
    pld_10g_tx_diag_status
    pld_8g_a1a2_size
    pld_8g_bitloc_rev_en
    pld_8g_byte_rev_en
    pld_8g_encdt
    pld_8g_tx_boundary_sel
    pld_bitslip
    pld_pma_adapt_start
    pld_pma_early_eios
    pld_pma_eye_monitor
    pld_pma_pcie_switch
    pld_pma_rs_lpbk_b
    pld_pmaif_rxclkslip
    pld_pma_tx_qpi_pulldn
    pld_pma_tx_qpi_pullup
    pld_pma_rx_qpi_pullup
    pld_polinv_rx
    pld_polinv_tx
    pld_syncsm_en
    pld_rx_prbs_err_clr
    pld_10g_tx_wordslip
    pld_pma_tx_bitslip
    pld_8g_eidleinfersel
    pld_tx_fifo_latency_adj_en
    pld_rx_fifo_latency_adj_en
  }

  if { [ info exists altera_xcvr_native_s10_async_xcvr_pins ] } {
    unset altera_xcvr_native_s10_async_xcvr_pins
  }

  # Set false paths for each item in the set
  foreach altera_xcvr_native_s10_async_signal_name $altera_xcvr_native_s10_async_signals {
    set altera_xcvr_native_s10_async_xcvr_pins [get_pins -nowarn -compatibility_mode g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_?x.inst_ct1_hssi_pldadapt_?x|${altera_xcvr_native_s10_async_signal_name}*]
    if { [get_collection_size $altera_xcvr_native_s10_async_xcvr_pins] > 0 } {
      set_false_path -to $altera_xcvr_native_s10_async_xcvr_pins
    }
  }


  #-------------------------------------------------- #
  #---                                            --- #
  #--- TX BURST ENABLE MIN/MAX CONSTRAINTS        --- #
  #---                                            --- #
  #-------------------------------------------------- #
  # For TX burst enable, even though its an asynchronous signal, set a bound, since we need the fitter to place it some-what close to the periphery for interlaken
  set altera_xcvr_native_s10_async_tx_burst_en_pins [get_pins -nowarn -compatibility_mode g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_10g_tx_burst_en*]
  if { [get_collection_size $altera_xcvr_native_s10_async_tx_burst_en_pins] > 0 } {
    set_max_delay -to $altera_xcvr_native_s10_async_tx_burst_en_pins 200ns
    set_min_delay -to $altera_xcvr_native_s10_async_tx_burst_en_pins -200ns
  }
  
    # alt_xcvr_resync_reset
  set aib_reset_out_stage_to_clrn [get_registers -nowarn g_non_hip_reset.alt_xcvr_native_reset_seq|g_trs.rx_dig_reset_seq|aib_reset_out_stage[*]]
  
  set dreg_clrn_to_alt_xcvr_sync_aibreset [get_pins -nowarn -compat g_lf_conditions[*].g_enforce_local_fault.transfer_ready_synchronizers|resync_chains[*].synchronizer_nocut|dreg[*]|clrn]
  set alt_xcvr_sync_aibreset_to_rx_parallel_data [get_registers -nowarn g_lf_conditions[*].g_enforce_local_fault.transfer_ready_synchronizers|resync_chains[*].synchronizer_nocut|dreg[*]]
  if {[get_collection_size $aib_reset_out_stage_to_clrn] > 0 && [get_collection_size $dreg_clrn_to_alt_xcvr_sync_aibreset] > 0 && [get_collection_size $alt_xcvr_sync_aibreset_to_rx_parallel_data] > 0} {
    set_false_path -from $aib_reset_out_stage_to_clrn -through $dreg_clrn_to_alt_xcvr_sync_aibreset -to $alt_xcvr_sync_aibreset_to_rx_parallel_data
  }
  
  set s1_clrn_to_alt_xcvr_sync_aibreset [get_pins -nowarn -compat g_lf_conditions[*].g_enforce_local_fault.transfer_ready_synchronizers|resync_chains[0].synchronizer_nocut|din_s1|clrn]
  set alt_xcvr_sync_din_to_rx_parallel_data [get_registers -nowarn g_lf_conditions[*].g_enforce_local_fault.transfer_ready_synchronizers|resync_chains[*].synchronizer_nocut|din_s1]
  if {[get_collection_size $aib_reset_out_stage_to_clrn] > 0 && [get_collection_size $s1_clrn_to_alt_xcvr_sync_aibreset] > 0 && [get_collection_size $alt_xcvr_sync_din_to_rx_parallel_data] > 0} {
    set_false_path -from $aib_reset_out_stage_to_clrn -through $s1_clrn_to_alt_xcvr_sync_aibreset -to $alt_xcvr_sync_din_to_rx_parallel_data
  }


}; #foreach inst

#-------------------------------------------------- #
#---                                            --- #
#--- DISABLE MIN_PULSE_WIDTH CHECK on fPLL      --- #
#---                                            --- #
#-------------------------------------------------- #

# Disable min_width_pulse for fPLL counter nodes
set all_ports_list [get_ports *]
foreach_in_collection port $all_ports_list {

  set fpll_counter_nodes_list [get_nodes -nowarn [get_node_info -name $port]~inputFITTER_INSERTED_FITTER_INSERTED~fpll_c?_div]

  if {[get_collection_size $fpll_counter_nodes_list] > 0} {
    foreach_in_collection fpll_counter_node $fpll_counter_nodes_list {
      disable_min_pulse_width [get_node_info -name $fpll_counter_node]
    }
  }
}

msg_vdebug "IP SDC: End of Native PHY IP SDC file!"


 13 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 2 ip 13 sdi_xcvr_test 37 sdi_xcvr_test_xcvr_native_s10_htile_0 33 altera_xcvr_native_s10_htile_1930 5 synth 63 sdi_xcvr_test_xcvr_native_s10_htile_0_ip_parameters_5rlvnya.tcl 2147 if {0} {
   unset native_phy_ip_params
}

set native_phy_ip_params [dict create]

dict set native_phy_ip_params profile_cnt "1"
set ::GLOBAL_corename sdi_xcvr_test_xcvr_native_s10_htile_0_altera_xcvr_native_s10_htile_1930_5rlvnya
# -------------------------------- #
# --- Default Profile settings --- #
# -------------------------------- #
dict set native_phy_ip_params channels_profile0 "1"
dict set native_phy_ip_params set_data_rate_profile0 "5940"
dict set native_phy_ip_params bonded_mode_profile0 "not_bonded"
dict set native_phy_ip_params tx_enable_profile0 "1"
dict set native_phy_ip_params rx_enable_profile0 "1"
dict set native_phy_ip_params rcfg_enable_profile0 "1"
dict set native_phy_ip_params set_prbs_soft_logic_enable_profile0 "1"
dict set native_phy_ip_params l_tx_fifo_transfer_mode_profile0 "x2"
dict set native_phy_ip_params l_rx_fifo_transfer_mode_profile0 "x2"
dict set native_phy_ip_params std_pcs_pma_width_profile0 "10"
dict set native_phy_ip_params enh_pcs_pma_width_profile0 "64"
dict set native_phy_ip_params pcs_direct_width_profile0 "8"
dict set native_phy_ip_params datapath_select_profile0 "Enhanced"
dict set native_phy_ip_params protocol_mode_profile0 "basic_enh"
dict set native_phy_ip_params tx_fifo_mode_profile0 "Phase compensation"
dict set native_phy_ip_params rx_fifo_mode_profile0 "Phase compensation"
dict set native_phy_ip_params std_tx_byte_ser_mode_profile0 "Disabled"
dict set native_phy_ip_params std_rx_byte_deser_mode_profile0 "Disabled"
dict set native_phy_ip_params duplex_mode_profile0 "duplex"
dict set native_phy_ip_params enable_hip_profile0 "0"
dict set native_phy_ip_params tx_clkout_sel_profile0 "pcs_clkout"
dict set native_phy_ip_params rx_clkout_sel_profile0 "pcs_clkout"
dict set native_phy_ip_params enable_port_tx_clkout2_profile0 "1"
dict set native_phy_ip_params enable_port_rx_clkout2_profile0 "1"
dict set native_phy_ip_params tx_clkout2_sel_profile0 "pma_div_clkout"
dict set native_phy_ip_params rx_clkout2_sel_profile0 "pma_div_clkout"
dict set native_phy_ip_params tx_pma_div_clkout_divider_profile0 "2"
dict set native_phy_ip_params rx_pma_div_clkout_divider_profile0 "2"
 13 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 2 ip 13 sdi_xcvr_test 38 sdi_xcvr_test_xcvr_reset_control_s10_0 34 altera_xcvr_reset_control_s10_1911 5 synth 22 alt_xcvr_reset_s10.sdc 3137 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# ---------------------------------------------------------------- #
# -                                                              - #
# --- THIS IS AN AUTO-GENERATED FILE!                          --- #
# --- Do not change the contents of this file.                 --- # 
# --- Your changes will be lost once the IP is regenerated!    --- #
# ---                                                          --- #
# -                                                              - # 
# ---------------------------------------------------------------- #

#set current_inst [get_current_instance]

#-----------------------------------#
#-- Async user reset synchronizer --#
#-----------------------------------#
set resync_reset_din_s1 [get_registers -nowarn alt_xcvr_resync_reset|resync_chains[0].synchronizer_nocut|din_s1]
set resync_reset_dreg [get_registers -nowarn alt_xcvr_resync_reset|resync_chains[0].synchronizer_nocut|dreg[0]]
set resync_din_s1_clrn_pin [get_pins -compat -nowarn alt_xcvr_resync_reset|resync_chains[0].synchronizer_nocut|din_s1|clrn]
set resync_dreg_clrn_pin [get_pins -compat -nowarn alt_xcvr_resync_reset|resync_chains[0].synchronizer_nocut|dreg[0]|clrn]

if {[get_collection_size $resync_reset_din_s1] > 0 } {
  foreach_in_collection reg $resync_reset_din_s1 {
    foreach_in_collection pin $resync_din_s1_clrn_pin {
      set_false_path -to $reg -through $pin
    }
  }
}

if {[get_collection_size $resync_reset_dreg] > 0 } {
  foreach_in_collection reg $resync_reset_dreg {
    foreach_in_collection pin $resync_dreg_clrn_pin {
      set_false_path -to $reg -through $pin
    }
  }
}

#-----------------------------------#
#-- TX async signals synchronizer --#
#-----------------------------------#
set resync_tx_signals [get_keepers -nowarn g_tx.g_tx[*].g_tx.resync_tx_cal_busy|resync_chains[?].synchronizer_nocut|din_s1]
if {[get_collection_size $resync_tx_signals] > 0 } {
  foreach_in_collection kpr $resync_tx_signals {
    set_false_path -to $kpr
  }
}

#-----------------------------------#
#-- RX async signals synchronizer --#
#-----------------------------------#
set resync_rx_signals [get_keepers -nowarn g_rx.g_rx[*].g_rx.resync_rx_cal_busy|resync_chains[?].synchronizer_nocut|din_s1]
if {[get_collection_size $resync_rx_signals] > 0 } {
  foreach_in_collection kpr $resync_rx_signals {
    set_false_path -to $kpr
  }
}
 13 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 2 ip 16 xcvr_test_system 24 xcvr_test_system_rx_fifo 9 fifo_1923 5 synth 46 xcvr_test_system_rx_fifo_fifo_1923_lpyfjcq.sdc 3711 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# constraints for DCFIFO sdc
#
# top-level sdc
# convention for module sdc apply_sdc_<module_name>
#
proc apply_sdc_mw_dcfifo {hier_path} {
# gray_rdptr
apply_sdc_mw_dcfifo_rdptr $hier_path
# gray_wrptr
apply_sdc_mw_dcfifo_wrptr $hier_path
}
#
# common constraint setting proc
#
proc apply_sdc_mw_dcfifo_for_ptrs {from_node_list to_node_list} {
# control skew for bits
set_max_skew -from $from_node_list -to $to_node_list -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8
# path delay (exception for net delay)
if { ![string equal "quartus_syn" $::TimeQuestInfo(nameofexecutable)] } {
set_net_delay -from $from_node_list -to $to_node_list -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8
}
#relax setup and hold calculation
set_max_delay -from $from_node_list -to $to_node_list 100
set_min_delay -from $from_node_list -to $to_node_list -100
}
#
# mstable propgation delay
#
proc apply_sdc_mw_dcfifo_mstable_delay {from_node_list to_node_list} {
# mstable delay
if { ![string equal "quartus_syn" $::TimeQuestInfo(nameofexecutable)] } {
set_net_delay -from $from_node_list -to $to_node_list -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8
}
}
#
# rdptr constraints
#
proc apply_sdc_mw_dcfifo_rdptr {hier_path} {
# get from and to list
set from_node_list [get_keepers $hier_path|dcfifo_mixed_widths_component|auto_generated|*rdptr_g*]
set to_node_list [get_keepers $hier_path|dcfifo_mixed_widths_component|auto_generated|ws_dgrp|dffpipe*|dffe*]
apply_sdc_mw_dcfifo_for_ptrs $from_node_list $to_node_list
# mstable
set from_node_mstable_list [get_keepers $hier_path|dcfifo_mixed_widths_component|auto_generated|ws_dgrp|dffpipe*|dffe*]
set to_node_mstable_list [get_keepers $hier_path|dcfifo_mixed_widths_component|auto_generated|ws_dgrp|dffpipe*|dffe*]
apply_sdc_mw_dcfifo_mstable_delay $from_node_mstable_list $to_node_mstable_list
}
#
# wrptr constraints
#
proc apply_sdc_mw_dcfifo_wrptr {hier_path} {
# control skew for bits
set from_node_list [get_keepers $hier_path|dcfifo_mixed_widths_component|auto_generated|delayed_wrptr_g*]
set to_node_list [get_keepers $hier_path|dcfifo_mixed_widths_component|auto_generated|rs_dgwp|dffpipe*|dffe*]
apply_sdc_mw_dcfifo_for_ptrs $from_node_list $to_node_list
# mstable
set from_node_mstable_list [get_keepers $hier_path|dcfifo_mixed_widths_component|auto_generated|rs_dgwp|dffpipe*|dffe*]
set to_node_mstable_list [get_keepers $hier_path|dcfifo_mixed_widths_component|auto_generated|rs_dgwp|dffpipe*|dffe*]
apply_sdc_mw_dcfifo_mstable_delay $from_node_mstable_list $to_node_mstable_list
}

proc apply_sdc_pre_mw_dcfifo {entity_name} {

set inst_list [get_entity_instances $entity_name]

foreach each_inst $inst_list {

        apply_sdc_mw_dcfifo ${each_inst} 

    }
}
apply_sdc_pre_mw_dcfifo xcvr_test_system_rx_fifo_fifo_1923_lpyfjcq
 13 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 2 ip 16 xcvr_test_system 24 xcvr_test_system_tx_fifo 9 fifo_1923 5 synth 46 xcvr_test_system_tx_fifo_fifo_1923_bynk7da.sdc 3711 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# constraints for DCFIFO sdc
#
# top-level sdc
# convention for module sdc apply_sdc_<module_name>
#
proc apply_sdc_mw_dcfifo {hier_path} {
# gray_rdptr
apply_sdc_mw_dcfifo_rdptr $hier_path
# gray_wrptr
apply_sdc_mw_dcfifo_wrptr $hier_path
}
#
# common constraint setting proc
#
proc apply_sdc_mw_dcfifo_for_ptrs {from_node_list to_node_list} {
# control skew for bits
set_max_skew -from $from_node_list -to $to_node_list -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8
# path delay (exception for net delay)
if { ![string equal "quartus_syn" $::TimeQuestInfo(nameofexecutable)] } {
set_net_delay -from $from_node_list -to $to_node_list -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8
}
#relax setup and hold calculation
set_max_delay -from $from_node_list -to $to_node_list 100
set_min_delay -from $from_node_list -to $to_node_list -100
}
#
# mstable propgation delay
#
proc apply_sdc_mw_dcfifo_mstable_delay {from_node_list to_node_list} {
# mstable delay
if { ![string equal "quartus_syn" $::TimeQuestInfo(nameofexecutable)] } {
set_net_delay -from $from_node_list -to $to_node_list -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8
}
}
#
# rdptr constraints
#
proc apply_sdc_mw_dcfifo_rdptr {hier_path} {
# get from and to list
set from_node_list [get_keepers $hier_path|dcfifo_mixed_widths_component|auto_generated|*rdptr_g*]
set to_node_list [get_keepers $hier_path|dcfifo_mixed_widths_component|auto_generated|ws_dgrp|dffpipe*|dffe*]
apply_sdc_mw_dcfifo_for_ptrs $from_node_list $to_node_list
# mstable
set from_node_mstable_list [get_keepers $hier_path|dcfifo_mixed_widths_component|auto_generated|ws_dgrp|dffpipe*|dffe*]
set to_node_mstable_list [get_keepers $hier_path|dcfifo_mixed_widths_component|auto_generated|ws_dgrp|dffpipe*|dffe*]
apply_sdc_mw_dcfifo_mstable_delay $from_node_mstable_list $to_node_mstable_list
}
#
# wrptr constraints
#
proc apply_sdc_mw_dcfifo_wrptr {hier_path} {
# control skew for bits
set from_node_list [get_keepers $hier_path|dcfifo_mixed_widths_component|auto_generated|delayed_wrptr_g*]
set to_node_list [get_keepers $hier_path|dcfifo_mixed_widths_component|auto_generated|rs_dgwp|dffpipe*|dffe*]
apply_sdc_mw_dcfifo_for_ptrs $from_node_list $to_node_list
# mstable
set from_node_mstable_list [get_keepers $hier_path|dcfifo_mixed_widths_component|auto_generated|rs_dgwp|dffpipe*|dffe*]
set to_node_mstable_list [get_keepers $hier_path|dcfifo_mixed_widths_component|auto_generated|rs_dgwp|dffpipe*|dffe*]
apply_sdc_mw_dcfifo_mstable_delay $from_node_mstable_list $to_node_mstable_list
}

proc apply_sdc_pre_mw_dcfifo {entity_name} {

set inst_list [get_entity_instances $entity_name]

foreach each_inst $inst_list {

        apply_sdc_mw_dcfifo ${each_inst} 

    }
}
apply_sdc_pre_mw_dcfifo xcvr_test_system_tx_fifo_fifo_1923_bynk7da
 11 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 5 q_sys 15 hs_clk_xer_1940 5 synth 44 altera_avalon_st_handshake_clock_crosser.sdc 10166 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# (C) 2001-2020 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# (C) 2001-2020 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# (C) 2001-2018 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#------------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Altera timing constraints for Avalon clock domain crossing (CDC) paths.
# The purpose of these constraints is to remove the false paths and replace with timing bounded 
# requirements for compilation.
#
# ***Important note *** 
#
# The clocks involved in this transfer must be kept synchronous and no false path
# should be set on these paths for these constraints to apply correctly.
# -----------------------------------------------------------------------------

set crosser_entity "altera_avalon_st_clock_crosser:"
set_max_delay -from [get_registers *${crosser_entity}*|in_data_buffer* ] -to [get_registers *${crosser_entity}*|out_data_buffer* ] 100
set_min_delay -from [get_registers *${crosser_entity}*|in_data_buffer* ] -to [get_registers *${crosser_entity}*|out_data_buffer* ] -100

set sync_entity "altera_avalon_st_clock_crosser:*|altera_std_synchronizer_nocut:"
set_max_delay -from [get_registers *${crosser_entity}* ] -to [get_registers *${sync_entity}*|din_s1 ] 100
set_min_delay -from [get_registers *${crosser_entity}* ] -to [get_registers *${sync_entity}*|din_s1 ] -100

foreach_in_collection list_of_out_data_buffers [get_registers *${crosser_entity}*|out_data_buffer* ] {
   set regname [get_register_info -name $list_of_out_data_buffers]
   set sync_path [ regsub "(.*)(out_data_buffer)(.*)" $regname "\\1" ]
   set input_data_buffer ""
   append input_data_buffer $sync_path "in_data_buffer*"
   set output_data_buffer ""
   append output_data_buffer $sync_path "out_data_buffer*"
 
    if { $::quartus(nameofexecutable) ne "quartus_syn" && $::quartus(nameofexecutable) ne "quartus_map" } { 
        set_net_delay -from [get_registers $input_data_buffer ] -to [get_registers $output_data_buffer] -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8
    }
   set_max_skew  -from [get_registers $input_data_buffer ] -to [get_registers $output_data_buffer] -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8 -nowarn 
}

foreach_in_collection list_in_data_toggle [ get_registers *${crosser_entity}*|in_data_toggle ] { 
   set in_flop [ get_register_info -name $list_in_data_toggle ] 
   # replace last occurence of string
   set in_sync_path [ regsub "(.*)(in_data_toggle)" $in_flop "\\1" ]
   set in_to_out_din_s1 ""
   set in_to_out_sync_din_s1 [ get_registers -nowarn [ append in_to_out_din_s1 $in_sync_path "in_to_out_synchronizer|din_s1" ] ]
   set in_data_toggle ""
   set in_data_toggle_with_path [ get_registers -nowarn [ append in_data_toggle $in_sync_path "in_data_toggle" ] ]
   
   # check for the presence of din_s1 and set the net_delay after that
   if { [ expr { [ llength [ query_collection -report -all $in_to_out_sync_din_s1 ] ] > 0 } ] } {
		if { $::quartus(nameofexecutable) ne "quartus_syn" && $::quartus(nameofexecutable) ne "quartus_map" } {
			set_net_delay -from  $in_data_toggle_with_path -to $in_to_out_sync_din_s1 -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8  
		}
      set_max_skew  -from  $in_data_toggle_with_path -to $in_to_out_sync_din_s1 -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8  -nowarn
   }
} 

foreach_in_collection list_out_data_toggle_flopped_n [ get_registers *${crosser_entity}*|out_data_toggle_flopped_n ] { 
   set out_flop [ get_register_info -name $list_out_data_toggle_flopped_n ] 
   # replace last occurence of string
   set out_sync_path [ regsub "(.*)(out_data_toggle_flopped_n)" $out_flop "\\1" ]
   set out_to_in_din_s1 ""
   set out_to_in_sync_din_s1 [ get_registers -nowarn [ append out_to_in_din_s1 $out_sync_path "out_to_in_synchronizer|din_s1" ] ]
   set out_data_toggle ""
   set out_data_toggle_with_path [ get_registers -nowarn [ append out_data_toggle $out_sync_path "out_data_toggle_flopped_n" ] ]

   # check for the presence of din_s1 and set the net_delay after that
   if { [ expr { [ llength [ query_collection -report -all $out_to_in_sync_din_s1 ] ]  > 0 } ] } { 
		if { $::quartus(nameofexecutable) ne "quartus_syn" && $::quartus(nameofexecutable) ne "quartus_map" } {
			set_net_delay -from $out_data_toggle_with_path -to $out_to_in_sync_din_s1 -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8  
		}
      set_max_skew  -from $out_data_toggle_with_path -to $out_to_in_sync_din_s1 -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8  -nowarn
   }
} 

set aclr_collection_in [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_req_sync_in_rst|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection_in [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_req_sync_in_rst|altera_reset_synchronizer_int_chain*|clrn]
set aclr_counter_in [get_collection_size $aclr_collection_in]
set clrn_counter_in [get_collection_size $clrn_collection_in]

if {$aclr_counter_in > 0} {
set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_req_sync_in_rst|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter_in > 0} {
set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_req_sync_in_rst|altera_reset_synchronizer_int_chain*|clrn]
}


set aclr_collection_out [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_req_sync_out_rst|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection_out [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_req_sync_out_rst|altera_reset_synchronizer_int_chain*|clrn]
set aclr_counter_out [get_collection_size $aclr_collection_out]
set clrn_counter_out [get_collection_size $clrn_collection_out]

if {$aclr_counter_out > 0} {
set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_req_sync_out_rst|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter_out > 0} {
set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_req_sync_out_rst|altera_reset_synchronizer_int_chain*|clrn]
}





# -----------------------------------------------------------------------------
# This procedure constrains the skew between the token and data bits, and should
# be called from the top level SDC, once per instance of the clock crosser.
#
# The hierarchy path to the handshake clock crosser instance is required as an 
# argument.
#
# In practice, the token and data bits tend to be placed close together, making
# excessive skew less of an issue.
# -----------------------------------------------------------------------------
proc constrain_alt_handshake_clock_crosser_skew { path } {

    set in_regs  [ get_registers $path|*clock_xer|in_data_buffer* ] 
    set out_regs [ get_registers $path|*clock_xer|out_data_buffer* ] 

    set in_regs [ add_to_collection $in_regs  [ get_registers $path|*clock_xer|in_data_toggle ] ]
    set out_regs [ add_to_collection $out_regs [ get_registers $path|*clock_xer|in_to_out_synchronizer|din_s1 ] ]

    set_max_skew -from $in_regs -to $out_regs -get_skew_value_from_clock_period dst_clock_period -skew_value_multiplier 0.8
}

 11 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 14 qsfp_xcvr_test 28 altera_reset_controller_1922 5 synth 27 altera_reset_controller.sdc 2326 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0

if {[get_current_instance] == ""} {set hpath ""} else {set hpath "[get_current_instance]|*"} 
post_message -type info "Following instance found in the design -  $hpath"

set aclr_collection [get_pins -compatibility_mode -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set num_sync_stage [get_registers -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[*]]
set num_sync_count [get_collection_size $num_sync_stage]   
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter == 0 &&  $clrn_counter == 0 && $num_sync_count > 0} {
    set_max_delay  -to [get_registers ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[[expr $num_sync_count-1]]] 100
    set_min_delay  -to [get_registers ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[[expr $num_sync_count-1]]] -100
}

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 11 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 14 qsfp_xcvr_test 15 hs_clk_xer_1940 5 synth 44 altera_avalon_st_handshake_clock_crosser.sdc 10166 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# (C) 2001-2020 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# (C) 2001-2020 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# (C) 2001-2018 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#------------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Altera timing constraints for Avalon clock domain crossing (CDC) paths.
# The purpose of these constraints is to remove the false paths and replace with timing bounded 
# requirements for compilation.
#
# ***Important note *** 
#
# The clocks involved in this transfer must be kept synchronous and no false path
# should be set on these paths for these constraints to apply correctly.
# -----------------------------------------------------------------------------

set crosser_entity "altera_avalon_st_clock_crosser:"
set_max_delay -from [get_registers *${crosser_entity}*|in_data_buffer* ] -to [get_registers *${crosser_entity}*|out_data_buffer* ] 100
set_min_delay -from [get_registers *${crosser_entity}*|in_data_buffer* ] -to [get_registers *${crosser_entity}*|out_data_buffer* ] -100

set sync_entity "altera_avalon_st_clock_crosser:*|altera_std_synchronizer_nocut:"
set_max_delay -from [get_registers *${crosser_entity}* ] -to [get_registers *${sync_entity}*|din_s1 ] 100
set_min_delay -from [get_registers *${crosser_entity}* ] -to [get_registers *${sync_entity}*|din_s1 ] -100

foreach_in_collection list_of_out_data_buffers [get_registers *${crosser_entity}*|out_data_buffer* ] {
   set regname [get_register_info -name $list_of_out_data_buffers]
   set sync_path [ regsub "(.*)(out_data_buffer)(.*)" $regname "\\1" ]
   set input_data_buffer ""
   append input_data_buffer $sync_path "in_data_buffer*"
   set output_data_buffer ""
   append output_data_buffer $sync_path "out_data_buffer*"
 
    if { $::quartus(nameofexecutable) ne "quartus_syn" && $::quartus(nameofexecutable) ne "quartus_map" } { 
        set_net_delay -from [get_registers $input_data_buffer ] -to [get_registers $output_data_buffer] -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8
    }
   set_max_skew  -from [get_registers $input_data_buffer ] -to [get_registers $output_data_buffer] -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8 -nowarn 
}

foreach_in_collection list_in_data_toggle [ get_registers *${crosser_entity}*|in_data_toggle ] { 
   set in_flop [ get_register_info -name $list_in_data_toggle ] 
   # replace last occurence of string
   set in_sync_path [ regsub "(.*)(in_data_toggle)" $in_flop "\\1" ]
   set in_to_out_din_s1 ""
   set in_to_out_sync_din_s1 [ get_registers -nowarn [ append in_to_out_din_s1 $in_sync_path "in_to_out_synchronizer|din_s1" ] ]
   set in_data_toggle ""
   set in_data_toggle_with_path [ get_registers -nowarn [ append in_data_toggle $in_sync_path "in_data_toggle" ] ]
   
   # check for the presence of din_s1 and set the net_delay after that
   if { [ expr { [ llength [ query_collection -report -all $in_to_out_sync_din_s1 ] ] > 0 } ] } {
		if { $::quartus(nameofexecutable) ne "quartus_syn" && $::quartus(nameofexecutable) ne "quartus_map" } {
			set_net_delay -from  $in_data_toggle_with_path -to $in_to_out_sync_din_s1 -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8  
		}
      set_max_skew  -from  $in_data_toggle_with_path -to $in_to_out_sync_din_s1 -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8  -nowarn
   }
} 

foreach_in_collection list_out_data_toggle_flopped_n [ get_registers *${crosser_entity}*|out_data_toggle_flopped_n ] { 
   set out_flop [ get_register_info -name $list_out_data_toggle_flopped_n ] 
   # replace last occurence of string
   set out_sync_path [ regsub "(.*)(out_data_toggle_flopped_n)" $out_flop "\\1" ]
   set out_to_in_din_s1 ""
   set out_to_in_sync_din_s1 [ get_registers -nowarn [ append out_to_in_din_s1 $out_sync_path "out_to_in_synchronizer|din_s1" ] ]
   set out_data_toggle ""
   set out_data_toggle_with_path [ get_registers -nowarn [ append out_data_toggle $out_sync_path "out_data_toggle_flopped_n" ] ]

   # check for the presence of din_s1 and set the net_delay after that
   if { [ expr { [ llength [ query_collection -report -all $out_to_in_sync_din_s1 ] ]  > 0 } ] } { 
		if { $::quartus(nameofexecutable) ne "quartus_syn" && $::quartus(nameofexecutable) ne "quartus_map" } {
			set_net_delay -from $out_data_toggle_with_path -to $out_to_in_sync_din_s1 -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8  
		}
      set_max_skew  -from $out_data_toggle_with_path -to $out_to_in_sync_din_s1 -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8  -nowarn
   }
} 

set aclr_collection_in [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_req_sync_in_rst|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection_in [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_req_sync_in_rst|altera_reset_synchronizer_int_chain*|clrn]
set aclr_counter_in [get_collection_size $aclr_collection_in]
set clrn_counter_in [get_collection_size $clrn_collection_in]

if {$aclr_counter_in > 0} {
set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_req_sync_in_rst|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter_in > 0} {
set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_req_sync_in_rst|altera_reset_synchronizer_int_chain*|clrn]
}


set aclr_collection_out [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_req_sync_out_rst|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection_out [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_req_sync_out_rst|altera_reset_synchronizer_int_chain*|clrn]
set aclr_counter_out [get_collection_size $aclr_collection_out]
set clrn_counter_out [get_collection_size $clrn_collection_out]

if {$aclr_counter_out > 0} {
set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_req_sync_out_rst|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter_out > 0} {
set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_req_sync_out_rst|altera_reset_synchronizer_int_chain*|clrn]
}





# -----------------------------------------------------------------------------
# This procedure constrains the skew between the token and data bits, and should
# be called from the top level SDC, once per instance of the clock crosser.
#
# The hierarchy path to the handshake clock crosser instance is required as an 
# argument.
#
# In practice, the token and data bits tend to be placed close together, making
# excessive skew less of an issue.
# -----------------------------------------------------------------------------
proc constrain_alt_handshake_clock_crosser_skew { path } {

    set in_regs  [ get_registers $path|*clock_xer|in_data_buffer* ] 
    set out_regs [ get_registers $path|*clock_xer|out_data_buffer* ] 

    set in_regs [ add_to_collection $in_regs  [ get_registers $path|*clock_xer|in_data_toggle ] ]
    set out_regs [ add_to_collection $out_regs [ get_registers $path|*clock_xer|in_to_out_synchronizer|din_s1 ] ]

    set_max_skew -from $in_regs -to $out_regs -get_skew_value_from_clock_period dst_clock_period -skew_value_multiplier 0.8
}

 11 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 13 sdi_xcvr_test 28 altera_reset_controller_1922 5 synth 27 altera_reset_controller.sdc 2326 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0

if {[get_current_instance] == ""} {set hpath ""} else {set hpath "[get_current_instance]|*"} 
post_message -type info "Following instance found in the design -  $hpath"

set aclr_collection [get_pins -compatibility_mode -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set num_sync_stage [get_registers -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[*]]
set num_sync_count [get_collection_size $num_sync_stage]   
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter == 0 &&  $clrn_counter == 0 && $num_sync_count > 0} {
    set_max_delay  -to [get_registers ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[[expr $num_sync_count-1]]] 100
    set_min_delay  -to [get_registers ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[[expr $num_sync_count-1]]] -100
}

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 11 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 13 sdi_xcvr_test 15 hs_clk_xer_1940 5 synth 44 altera_avalon_st_handshake_clock_crosser.sdc 10166 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# (C) 2001-2020 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# (C) 2001-2020 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# (C) 2001-2018 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#------------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Altera timing constraints for Avalon clock domain crossing (CDC) paths.
# The purpose of these constraints is to remove the false paths and replace with timing bounded 
# requirements for compilation.
#
# ***Important note *** 
#
# The clocks involved in this transfer must be kept synchronous and no false path
# should be set on these paths for these constraints to apply correctly.
# -----------------------------------------------------------------------------

set crosser_entity "altera_avalon_st_clock_crosser:"
set_max_delay -from [get_registers *${crosser_entity}*|in_data_buffer* ] -to [get_registers *${crosser_entity}*|out_data_buffer* ] 100
set_min_delay -from [get_registers *${crosser_entity}*|in_data_buffer* ] -to [get_registers *${crosser_entity}*|out_data_buffer* ] -100

set sync_entity "altera_avalon_st_clock_crosser:*|altera_std_synchronizer_nocut:"
set_max_delay -from [get_registers *${crosser_entity}* ] -to [get_registers *${sync_entity}*|din_s1 ] 100
set_min_delay -from [get_registers *${crosser_entity}* ] -to [get_registers *${sync_entity}*|din_s1 ] -100

foreach_in_collection list_of_out_data_buffers [get_registers *${crosser_entity}*|out_data_buffer* ] {
   set regname [get_register_info -name $list_of_out_data_buffers]
   set sync_path [ regsub "(.*)(out_data_buffer)(.*)" $regname "\\1" ]
   set input_data_buffer ""
   append input_data_buffer $sync_path "in_data_buffer*"
   set output_data_buffer ""
   append output_data_buffer $sync_path "out_data_buffer*"
 
    if { $::quartus(nameofexecutable) ne "quartus_syn" && $::quartus(nameofexecutable) ne "quartus_map" } { 
        set_net_delay -from [get_registers $input_data_buffer ] -to [get_registers $output_data_buffer] -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8
    }
   set_max_skew  -from [get_registers $input_data_buffer ] -to [get_registers $output_data_buffer] -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8 -nowarn 
}

foreach_in_collection list_in_data_toggle [ get_registers *${crosser_entity}*|in_data_toggle ] { 
   set in_flop [ get_register_info -name $list_in_data_toggle ] 
   # replace last occurence of string
   set in_sync_path [ regsub "(.*)(in_data_toggle)" $in_flop "\\1" ]
   set in_to_out_din_s1 ""
   set in_to_out_sync_din_s1 [ get_registers -nowarn [ append in_to_out_din_s1 $in_sync_path "in_to_out_synchronizer|din_s1" ] ]
   set in_data_toggle ""
   set in_data_toggle_with_path [ get_registers -nowarn [ append in_data_toggle $in_sync_path "in_data_toggle" ] ]
   
   # check for the presence of din_s1 and set the net_delay after that
   if { [ expr { [ llength [ query_collection -report -all $in_to_out_sync_din_s1 ] ] > 0 } ] } {
		if { $::quartus(nameofexecutable) ne "quartus_syn" && $::quartus(nameofexecutable) ne "quartus_map" } {
			set_net_delay -from  $in_data_toggle_with_path -to $in_to_out_sync_din_s1 -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8  
		}
      set_max_skew  -from  $in_data_toggle_with_path -to $in_to_out_sync_din_s1 -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8  -nowarn
   }
} 

foreach_in_collection list_out_data_toggle_flopped_n [ get_registers *${crosser_entity}*|out_data_toggle_flopped_n ] { 
   set out_flop [ get_register_info -name $list_out_data_toggle_flopped_n ] 
   # replace last occurence of string
   set out_sync_path [ regsub "(.*)(out_data_toggle_flopped_n)" $out_flop "\\1" ]
   set out_to_in_din_s1 ""
   set out_to_in_sync_din_s1 [ get_registers -nowarn [ append out_to_in_din_s1 $out_sync_path "out_to_in_synchronizer|din_s1" ] ]
   set out_data_toggle ""
   set out_data_toggle_with_path [ get_registers -nowarn [ append out_data_toggle $out_sync_path "out_data_toggle_flopped_n" ] ]

   # check for the presence of din_s1 and set the net_delay after that
   if { [ expr { [ llength [ query_collection -report -all $out_to_in_sync_din_s1 ] ]  > 0 } ] } { 
		if { $::quartus(nameofexecutable) ne "quartus_syn" && $::quartus(nameofexecutable) ne "quartus_map" } {
			set_net_delay -from $out_data_toggle_with_path -to $out_to_in_sync_din_s1 -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8  
		}
      set_max_skew  -from $out_data_toggle_with_path -to $out_to_in_sync_din_s1 -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8  -nowarn
   }
} 

set aclr_collection_in [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_req_sync_in_rst|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection_in [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_req_sync_in_rst|altera_reset_synchronizer_int_chain*|clrn]
set aclr_counter_in [get_collection_size $aclr_collection_in]
set clrn_counter_in [get_collection_size $clrn_collection_in]

if {$aclr_counter_in > 0} {
set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_req_sync_in_rst|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter_in > 0} {
set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_req_sync_in_rst|altera_reset_synchronizer_int_chain*|clrn]
}


set aclr_collection_out [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_req_sync_out_rst|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection_out [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_req_sync_out_rst|altera_reset_synchronizer_int_chain*|clrn]
set aclr_counter_out [get_collection_size $aclr_collection_out]
set clrn_counter_out [get_collection_size $clrn_collection_out]

if {$aclr_counter_out > 0} {
set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_req_sync_out_rst|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter_out > 0} {
set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_req_sync_out_rst|altera_reset_synchronizer_int_chain*|clrn]
}





# -----------------------------------------------------------------------------
# This procedure constrains the skew between the token and data bits, and should
# be called from the top level SDC, once per instance of the clock crosser.
#
# The hierarchy path to the handshake clock crosser instance is required as an 
# argument.
#
# In practice, the token and data bits tend to be placed close together, making
# excessive skew less of an issue.
# -----------------------------------------------------------------------------
proc constrain_alt_handshake_clock_crosser_skew { path } {

    set in_regs  [ get_registers $path|*clock_xer|in_data_buffer* ] 
    set out_regs [ get_registers $path|*clock_xer|out_data_buffer* ] 

    set in_regs [ add_to_collection $in_regs  [ get_registers $path|*clock_xer|in_data_toggle ] ]
    set out_regs [ add_to_collection $out_regs [ get_registers $path|*clock_xer|in_to_out_synchronizer|din_s1 ] ]

    set_max_skew -from $in_regs -to $out_regs -get_skew_value_from_clock_period dst_clock_period -skew_value_multiplier 0.8
}

 11 0 2 C: 5 Users 6 Haas1S 9 Downloads 7 stratix 12 qts_qsfp_sdi 12 qts_qsfp_sdi 16 xcvr_test_system 28 altera_reset_controller_1922 5 synth 27 altera_reset_controller.sdc 2326 # (C) 2001-2023 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0

if {[get_current_instance] == ""} {set hpath ""} else {set hpath "[get_current_instance]|*"} 
post_message -type info "Following instance found in the design -  $hpath"

set aclr_collection [get_pins -compatibility_mode -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set num_sync_stage [get_registers -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[*]]
set num_sync_count [get_collection_size $num_sync_stage]   
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter == 0 &&  $clrn_counter == 0 && $num_sync_count > 0} {
    set_max_delay  -to [get_registers ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[[expr $num_sync_count-1]]] 100
    set_min_delay  -to [get_registers ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[[expr $num_sync_count-1]]] -100
}

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 1
